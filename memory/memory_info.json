[
    {
        "id": 0,
        "problem": "train a 5-layer GAT model with specified parameters and predict the accuracy",
        "graph_type": "undirected",
        "experience": "The process involves loading the Cora dataset using AutoGL, defining a custom Graph Convolutional Network (GCN) model with specified hyperparameters such as hidden dimensions, dropout rate, and number of layers. The model is then integrated into an AutoNodeClassifier solver, which handles feature extraction, model training with hyperparameter optimization, and ensemble strategies. After training, the model's performance is evaluated on the test set by predicting probabilities and calculating accuracy.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "given the cora dataset, can you use autogl to train a 2-layer gcn model with hidden dimension as [32, 64], dropout as 0.3 and predict the accuracy ?\n",
                "code": "import pkg_resources\nimport autogl\nfrom autogl.datasets import build_dataset_from_name\ncora_dataset = build_dataset_from_name('cora')\n\ndef fixed(**kwargs):\n    return [{\n        'parameterName': k,\n        \"type\": \"FIXED\",\n        \"value\": v\n    } for k, v in kwargs.items()]\n\nimport torch\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\nfrom autogl.solver import AutoNodeClassifier\n\nencoder_hp = {\n    'num_layers': 2,\n    'hidden': [32, 64],\n    'dropout': 0.3,\n    'act': 'relu',\n    'eps': 'false'\n}\n\nsolver = AutoNodeClassifier(\n    feature_module='deepgl',\n    graph_models=['gcn'],\n    hpo_module='anneal',\n    ensemble_module='voting',\n    device=device,\n    model_hp_spaces=[{'encoder': fixed(**encoder_hp), 'decoder': None}],\n)\n\nsolver.fit(cora_dataset, time_limit=3600)\nsolver.get_leaderboard().show()\n\nfrom autogl.module.train import Acc\nfrom autogl.solver.utils import get_graph_labels, get_graph_masks\n\npredicted = solver.predict_proba()\nlabel = get_graph_labels(cora_dataset[0])[get_graph_masks(cora_dataset[0], 'test')].cpu().numpy()\nprint('Test accuracy: ', Acc.evaluate(predicted, label))",
                "key_api": "\"build_dataset_from_name\",\n    \"AutoNodeClassifier\",\n    \"fixed\",\n    \"solver.fit\",\n    \"solver.get_leaderboard\",\n    \"solver.predict_proba\",\n    \"get_graph_labels\",\n    \"get_graph_masks\",\n    \"Acc.evaluate\"",
                "key_experience": "    \"Setting the computation device to GPU if available for efficient training.\",\n    \"Defining a fixed hyperparameter configuration to ensure consistent model architecture.\",\n    \"Utilizing AutoGL's modular components such as feature_module, graph_models, hpo_module, and ensemble_module for flexibility and scalability.\",\n    \"Implementing a time limit for the training process to manage computational resources effectively.\",\n    \"Displaying a leaderboard to compare the performance of different trained models.\",\n    \"Separating prediction and evaluation steps to accurately assess model performance on the test set.\",\n    \"Using best practices in coding structure for readability and maintainability.\""
            }
        ]
    },
    {
        "id": 1,
        "problem": "train a 2-layer GCN model with hidden dimensions [8, 16] and dropout 0.1, and predict the accuracy",
        "graph_type": "undirected",
        "experience": "Assisted in training a 2-layer Graph Attention Network (GAT) on the Cora dataset using AutoGL. The process involved loading the dataset, defining fixed hyperparameters for the encoder, initializing the AutoNodeClassifier solver with specified modules, training the model within a time limit, displaying the leaderboard of trained models, and evaluating the test accuracy by comparing predicted probabilities with true labels.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "given the cora dataset, can you use autogl to train a 2-layer gat model with hidden dimension as [32, 64], dropout as 0.2 and predict the accuracy ?",
                "code": "import pkg_resources\nimport autogl\nfrom autogl.datasets import build_dataset_from_name\n\n# Load the Cora dataset\ncora_dataset = build_dataset_from_name('cora')\n\ndef fixed(**kwargs):\n    return [{\n        'parameterName': k,\n        \"type\": \"FIXED\",\n        \"value\": v\n    } for k, v in kwargs.items()]\n\nimport torch\nfrom autogl.solver import AutoNodeClassifier\n\n# Set the device to GPU if available, else CPU\ndevice = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')\n\n# Define the encoder hyperparameters\nencoder_hp = {\n    'num_layers': 2,            # 2-layer GAT\n    'hidden': [32, 64],         # Hidden dimensions\n    'dropout': 0.2,             # Dropout rate\n    'act': 'relu',              # Activation function\n    'eps': 'false'              # Epsilon value (specific to GAT implementation if applicable)\n}\n\n# Initialize the AutoNodeClassifier solver\nsolver = AutoNodeClassifier(\n    feature_module='deepgl',          # Feature extraction module\n    graph_models=['gat'],             # Specify GAT as the graph model\n    hpo_module='anneal',              # Hyperparameter optimization module\n    ensemble_module='voting',         # Ensemble method\n    device=device,                    # Device configuration\n    model_hp_spaces=[{\n        'encoder': fixed(**encoder_hp),  # Set encoder hyperparameters\n        'decoder': None                   # No decoder needed for node classification\n    }],\n)\n\n# Train the model with a time limit (e.g., 3600 seconds)\nsolver.fit(cora_dataset, time_limit=3600)\n\n# Display the leaderboard of trained models\nsolver.get_leaderboard().show()\n\nfrom autogl.module.train import Acc\nfrom autogl.solver.utils import get_graph_labels, get_graph_masks\n\n# Predict probabilities on the test set\npredicted = solver.predict_proba()\n\n# Retrieve the true labels for the test set\nlabel = get_graph_labels(cora_dataset[0])[get_graph_masks(cora_dataset[0], 'test')].cpu().numpy()\n\n# Evaluate and print the test accuracy\nprint('Test accuracy: ', Acc.evaluate(predicted, label))",
                "key_api": "    \"build_dataset_from_name\",\n    \"AutoNodeClassifier\",\n    \"fixed\",\n    \"solver.fit\",\n    \"solver.get_leaderboard\",\n    \"solver.predict_proba\",\n    \"get_graph_labels\",\n    \"get_graph_masks\",\n    \"Acc.evaluate\"",
                "key_experience": "\"Setting the computation device to GPU if available for efficient training.\",\n    \"Defining a fixed hyperparameter configuration to ensure consistent model architecture.\",\n    \"Utilizing AutoGL's modular components such as feature_module, graph_models, hpo_module, and ensemble_module for flexibility and scalability.\",\n    \"Implementing a time limit for the training process to manage computational resources effectively.\",\n    \"Displaying a leaderboard to compare the performance of different trained models.\",\n    \"Separating prediction and evaluation steps to accurately assess model performance on the test set.\",\n    \"Using best practices in coding structure for readability and maintainability.\""
            }
        ]
    },
    {
        "id": 2,
        "problem": "Determine whether or not there is a cycle in an undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Coding Task Experiences\n\n#### Key Insights from the Tasks:\n\n1. **Graph Theory Basics**:\n   - Both tasks involved understanding the structure and representation of undirected graphs, including nodes and edges.\n\n2. **Cycle Detection**:\n   - The primary objective in both tasks was to determine the presence of cycles within the graph, a fundamental problem in graph theory with applications in various domains such as network topology and circuit design.\n\n#### Most Important Practices:\n\n1. **Utilizing Established Libraries**:\n   - The **NetworkX library** was employed in both tasks for its robust set of graph algorithms and ease of use. NetworkX simplifies the implementation of complex graph operations and provides reliable functions for common graph problems.\n\n2. **Creating Graph Structures Efficiently**:\n   - Graphs were created using NetworkX's `Graph()` method, and edges were added using `add_edges_from()`, making the code concise and expressive.\n\n3. **Cycle Detection Using Built-In Functions**:\n   - The `nx.find_cycle()` function from NetworkX was specifically utilized for detecting cycles. This function is efficient and leverages optimal algorithms internally.\n\n4. **Error Handling for Robustness**:\n   - A try-except block was used to handle cases where no cycle is found with the `nx.NetworkXNoCycle` exception, ensuring the script responds accurately with a \"No\" when no cycle is present.\n\n#### Useful APIs and Functions:\n\n1. **NetworkX**:\n   - **`nx.Graph()`**: Creates an undirected graph.\n   - **`add_edges_from()`**: Efficiently adds multiple edges to the graph at once.\n   - **`nx.find_cycle()`**: Detects cycles in an undirected graph. Uses an orientation parameter set to `'ignore'` to treat edges as undirected.\n   - **`nx.NetworkXNoCycle`**: Exception raised when no cycle is found through `nx.find_cycle()`.\n\n2. **General Python Best Practices**:\n   - Utilizing Python's `try-except` construct for error handling ensures that the program deals gracefully with unexpected situations (e.g., no cycle found).\n\n### Conclusion\n\nBoth tasks demonstrated the importance of using established libraries like NetworkX for graph-related problems. The consistency in code structure (defining graphs, adding edges, and detecting cycles) across tasks shows the efficiency and clarity brought by standard library functions. Key practices, such as efficient graph creation, leveraging built-in algorithms, and robust error handling, played a significant role in achieving the desired outcomes.",
        "rag_data": {
            "Section ID": "find_cycle",
            "Description": [
                "Returns a cycle found via depth-first traversal.",
                "The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation ."
            ],
            "Field List": {
                "Parameters:": {
                    "G : graph": "A directed/undirected graph/multigraph.",
                    "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                    "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
                },
                "Returns:": {
                    "edges : directed edges": "A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
                },
                "Raises:": {
                    "NetworkXNoCycle": "If no cycle was found."
                }
            },
            "Rubrics": {
                "Examples": "In this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an \u201cundirected cycle\u201d.\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\nG=nx.DiGraph([(0,1),(0,2),(1,2)])\nnx.find_cycle(G,orientation=\"original\")Traceback (most recent call last):    ...networkx.exception.NetworkXNoCycleNo cycle found.\nlist(nx.find_cycle(G,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether or not there is a cycle in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a cycle in the graph. Q: The nodes are numbered from 0 to 79, and the edges are: (0, 49) (0, 29) (0, 35) (0, 43) (1, 38) (1, 68) (1, 22) (1, 58) (1, 67) (2, 31) (2, 8) (2, 56) (2, 43) (3, 79) (3, 57) (3, 53) (3, 22) (3, 73) (4, 49) (4, 48) (5, 31) (5, 57) (6, 21) (6, 72) (6, 77) (7, 59) (7, 76) (7, 54) (7, 67) (7, 13) (8, 46) (8, 75) (8, 63) (8, 26) (8, 52) (9, 61) (10, 59) (11, 55) (11, 54) (11, 23) (11, 47) (11, 12) (13, 15) (13, 44) (13, 40) (13, 43) (14, 74) (15, 52) (15, 70) (16, 41) (16, 26) (16, 48) (16, 54) (17, 39) (17, 60) (18, 35) (20, 67) (20, 75) (20, 49) (20, 62) (21, 28) (21, 75) (22, 73) (23, 67) (23, 62) (23, 39) (23, 54) (25, 72) (26, 59) (26, 30) (26, 70) (27, 30) (27, 73) (28, 63) (29, 65) (30, 77) (31, 66) (33, 69) (33, 60) (36, 72) (37, 56) (37, 53) (37, 50) (37, 40) (37, 68) (38, 66) (39, 55) (41, 74) (41, 48) (41, 47) (42, 71) (43, 71) (44, 51) (44, 70) (45, 76) (47, 53) (47, 73) (48, 65) (49, 76) (50, 76) (50, 72) (50, 75) (51, 78) (52, 64) (52, 58) (52, 54) (54, 72) (55, 63) (58, 67) (59, 79) (59, 72) (59, 74) (61, 66) (62, 69) (65, 69) (66, 76) (67, 79) (70, 71) (71, 77). Is there a cycle in this graph?",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nnodes = range(80)  # Nodes from 0 to 79\nedges = [\n    [0, 49], [0, 29], [0, 35], [0, 43], [1, 38], [1, 68], [1, 22], [1, 58], \n    [1, 67], [2, 31], [2, 8], [2, 56], [2, 43], [3, 79], [3, 57], [3, 53], \n    [3, 22], [3, 73], [4, 49], [4, 48], [5, 31], [5, 57], [6, 21], [6, 72], \n    [6, 77], [7, 59], [7, 76], [7, 54], [7, 67], [7, 13], [8, 46], [8, 75], \n    [8, 63], [8, 26], [8, 52], [9, 61], [10, 59], [11, 55], [11, 54], [11, 23], \n    [11, 47], [11, 12], [13, 15], [13, 44], [13, 40], [13, 43], [14, 74], \n    [15, 52], [15, 70], [16, 41], [16, 26], [16, 48], [16, 54], [17, 39], \n    [17, 60], [18, 35], [20, 67], [20, 75], [20, 49], [20, 62], [21, 28], \n    [21, 75], [22, 73], [23, 67], [23, 62], [23, 39], [23, 54], [25, 72], \n    [26, 59], [26, 30], [26, 70], [27, 30], [27, 73], [28, 63], [29, 65], \n    [30, 77], [31, 66], [33, 69], [33, 60], [36, 72], [37, 56], [37, 53], \n    [37, 50], [37, 40], [37, 68], [38, 66], [39, 55], [41, 74], [41, 48], \n    [41, 47], [42, 71], [43, 71], [44, 51], [44, 70], [45, 76], [47, 53], \n    [47, 73], [48, 65], [49, 76], [50, 76], [50, 72], [50, 75], [51, 78], \n    [52, 64], [52, 58], [52, 54], [54, 72], [55, 63], [58, 67], [59, 79], \n    [59, 72], [59, 74], [61, 66], [62, 69], [65, 69], [66, 76], [67, 79], \n    [70, 71], [71, 77]\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Function to check for cycles\ndef has_cycle(graph):\n    try:\n        # Attempt to find a cycle, treating edges as undirected\n        cycle = nx.find_cycle(graph, orientation='ignore')\n        return \"Yes\"  # Cycle found\n    except nx.NetworkXNoCycle:\n        return \"No\"  # No cycle found\n\n# Check for cycles in the graph\nresult = has_cycle(G)\nprint(result)",
                "key_api": "networkx",
                "key_experience": "Utilized depth-first search (DFS) and NetworkX's built-in functions like find_cycle to efficiently check for cycles in an undirected graph, demonstrating best practices in graph traversal and computational efficiency."
            },
            {
                "question": "Determine whether or not there is a cycle in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a cycle in the graph. Q: The nodes are numbered from 0 to 63, and the edges are: (0, 59) (0, 39) (0, 34) (0, 47) (0, 15) (1, 52) (1, 37) (1, 28) (1, 44) (1, 33) (1, 32) (2, 4) (3, 53) (3, 62) (3, 24) (3, 48) (4, 30) (4, 34) (4, 20) (4, 45) (5, 36) (5, 52) (5, 10) (6, 41) (6, 40) (7, 17) (8, 45) (8, 9) (8, 23) (8, 57) (9, 39) (9, 43) (9, 36) (9, 34) (9, 59) (9, 14) (9, 26) (9, 33) (10, 18) (10, 38) (10, 14) (11, 46) (11, 31) (12, 18) (12, 35) (12, 36) (12, 34) (12, 27) (12, 28) (13, 27) (13, 60) (13, 47) (13, 14) (15, 39) (15, 21) (16, 40) (16, 50) (16, 52) (17, 53) (17, 51) (18, 51) (18, 49) (18, 39) (19, 48) (19, 20) (19, 24) (21, 32) (22, 50) (22, 61) (22, 58) (22, 39) (22, 38) (22, 55) (23, 42) (24, 59) (24, 47) (25, 50) (25, 52) (26, 36) (27, 34) (27, 41) (27, 33) (27, 61) (28, 35) (28, 51) (28, 40) (28, 29) (28, 31) (29, 54) (29, 59) (29, 42) (29, 43) (29, 52) (30, 51) (30, 40) (31, 36) (31, 45) (32, 53) (33, 52) (33, 42) (35, 59) (36, 42) (38, 54) (38, 61) (38, 53) (39, 42) (41, 60) (41, 49) (41, 51) (41, 45) (43, 44) (43, 53) (44, 55) (45, 50) (49, 59) (50, 51) (52, 57) (52, 58) (53, 62) (53, 56) (61, 63). Is there a cycle in this graph?",
                "code": "import networkx as nx\n\n# Input data\ndata = {\n    'Nodes': '0 to 63',\n    'Edges': [\n        [0, 59], [0, 39], [0, 34], [0, 47], [0, 15], [1, 52], [1, 37], [1, 28],\n        [1, 44], [1, 33], [1, 32], [2, 4], [3, 53], [3, 62], [3, 24], [3, 48],\n        [4, 30], [4, 34], [4, 20], [4, 45], [5, 36], [5, 52], [5, 10], [6, 41],\n        [6, 40], [7, 17], [8, 45], [8, 9], [8, 23], [8, 57], [9, 39], [9, 43],\n        [9, 36], [9, 34], [9, 59], [9, 14], [9, 26], [9, 33], [10, 18], [10, 38],\n        [10, 14], [11, 46], [11, 31], [12, 18], [12, 35], [12, 36], [12, 34],\n        [12, 27], [12, 28], [13, 27], [13, 60], [13, 47], [13, 14], [15, 39],\n        [15, 21], [16, 40], [16, 50], [16, 52], [17, 53], [17, 51], [18, 51],\n        [18, 49], [18, 39], [19, 48], [19, 20], [19, 24], [21, 32], [22, 50],\n        [22, 61], [22, 58], [22, 39], [22, 38], [22, 55], [23, 42], [24, 59],\n        [24, 47], [25, 50], [25, 52], [26, 36], [27, 34], [27, 41], [27, 33],\n        [27, 61], [28, 35], [28, 51], [28, 40], [28, 29], [28, 31], [29, 54],\n        [29, 59], [29, 42], [29, 43], [29, 52], [30, 51], [30, 40], [31, 36],\n        [31, 45], [32, 53], [33, 52], [33, 42], [35, 59], [36, 42], [38, 54],\n        [38, 61], [38, 53], [39, 42], [41, 60], [41, 49], [41, 51], [41, 45],\n        [43, 44], [43, 53], [44, 55], [45, 50], [49, 59], [50, 51], [52, 57],\n        [52, 58], [53, 62], [53, 56], [61, 63]\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from(data['Edges'])\n\n# Function to check for cycles\ndef has_cycle(graph):\n    try:\n        # Attempt to find a cycle in the graph\n        cycle = nx.find_cycle(graph, orientation='ignore')\n        return \"Yes\"  # Cycle found\n    except nx.NetworkXNoCycle:\n        return \"No\"  # No cycle found\n\n# Check for cycles in the graph\nresult = has_cycle(G)\nprint(result)",
                "key_api": "networkx.find_cycle(graph, orientation='ignore')",
                "key_experience": "Utilized built-in graph algorithms from the NetworkX library for cycle detection, which improves code efficiency and maintainability. Used a try-except block for error handling, providing clear responses when cycles are found or not."
            }
        ]
    },
    {
        "id": 3,
        "problem": "Determine whether or not there is a cycle in an undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Experiences from Multiple Coding Tasks\n\n**Key Practices:**\n\n1. **Graph Representation:** Leveraging specialized libraries like NetworkX for representing and manipulating graphs. This allows for more intuitive and direct handling of edges and nodes.\n2. **Cycle Detection:** Utilizing built-in functions within libraries to perform complex graph operations, which streamlines the code and reduces the likelihood of errors.\n\n**Key Insights:**\n\n1. **Efficient Computation:** Libraries like NetworkX are optimized for handling large datasets, such as the provided graph with 64 nodes and numerous edges. This optimization ensures that operations like cycle detection are performed efficiently.\n2. **Readable Code:** The use of NetworkX significantly simplifies the code, making it more readable and maintainable. This is particularly important for complex graph operations that would otherwise require extensive custom code.\n3. **Built-in Functions:** Making full use of built-in functions (e.g., `nx.cycle_basis()`) is crucial for performing advanced tasks without reinventing the wheel. This not only saves time but also leverages the tested and optimized implementations provided by these libraries.\n\n**Useful APIs:**\n\n- **NetworkX**: An indispensable library for graph-related tasks in Python. Key functions include:\n  - `nx.Graph()`: For creating an undirected graph.\n  - `add_edges_from()`: For adding multiple edges to a graph in a single call.\n  - `nx.cycle_basis()`: For detecting cycles in an undirected graph.\n\nBy employing these practices and insights, coding tasks involving complex data structures such as graphs can be handled more effectively, leading to robust and performant solutions.",
        "rag_data": {
            "Section ID": "cycle_basis",
            "Description": [
                "Returns a list of cycles which form a basis for cycles of G.",
                "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX Graph": "",
                    "root : node, optional": "Specify starting node for basis."
                },
                "Returns:": {
                    "A list of cycle lists.  Each cycle list is a list of nodes": "",
                    "which forms a cycle (loop) in G.": ""
                }
            },
            "Rubrics": {
                "Notes": "This is adapted from algorithm CACM 491 [1] .",
                "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
                "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether or not there is a cycle in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a cycle in the graph. Q: The nodes are numbered from 0 to 63, and the edges are: (0, 59) (0, 39) (0, 34) (0, 47) (0, 15) (1, 52) (1, 37) (1, 28) (1, 44) (1, 33) (1, 32) (2, 4) (3, 53) (3, 62) (3, 24) (3, 48) (4, 30) (4, 34) (4, 20) (4, 45) (5, 36) (5, 52) (5, 10) (6, 41) (6, 40) (7, 17) (8, 45) (8, 9) (8, 23) (8, 57) (9, 39) (9, 43) (9, 36) (9, 34) (9, 59) (9, 14) (9, 26) (9, 33) (10, 18) (10, 38) (10, 14) (11, 46) (11, 31) (12, 18) (12, 35) (12, 36) (12, 34) (12, 27) (12, 28) (13, 27) (13, 60) (13, 47) (13, 14) (15, 39) (15, 21) (16, 40) (16, 50) (16, 52) (17, 53) (17, 51) (18, 51) (18, 49) (18, 39) (19, 48) (19, 20) (19, 24) (21, 32) (22, 50) (22, 61) (22, 58) (22, 39) (22, 38) (22, 55) (23, 42) (24, 59) (24, 47) (25, 50) (25, 52) (26, 36) (27, 34) (27, 41) (27, 33) (27, 61) (28, 35) (28, 51) (28, 40) (28, 29) (28, 31) (29, 54) (29, 59) (29, 42) (29, 43) (29, 52) (30, 51) (30, 40) (31, 36) (31, 45) (32, 53) (33, 52) (33, 42) (35, 59) (36, 42) (38, 54) (38, 61) (38, 53) (39, 42) (41, 60) (41, 49) (41, 51) (41, 45) (43, 44) (43, 53) (44, 55) (45, 50) (49, 59) (50, 51) (52, 57) (52, 58) (53, 62) (53, 56) (61, 63). Is there a cycle in this graph?",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nnodes = range(64)  # Nodes from 0 to 63\nedges = [\n    [0, 59], [0, 39], [0, 34], [0, 47], [0, 15], [1, 52], [1, 37], [1, 28],\n    [1, 44], [1, 33], [1, 32], [2, 4], [3, 53], [3, 62], [3, 24], [3, 48],\n    [4, 30], [4, 34], [4, 20], [4, 45], [5, 36], [5, 52], [5, 10], [6, 41],\n    [6, 40], [7, 17], [8, 45], [8, 9], [8, 23], [8, 57], [9, 39], [9, 43],\n    [9, 36], [9, 34], [9, 59], [9, 14], [9, 26], [9, 33], [10, 18], [10, 38],\n    [10, 14], [11, 46], [11, 31], [12, 18], [12, 35], [12, 36], [12, 34],\n    [12, 27], [12, 28], [13, 27], [13, 60], [13, 47], [13, 14], [15, 39],\n    [15, 21], [16, 40], [16, 50], [16, 52], [17, 53], [17, 51], [18, 51],\n    [18, 49], [18, 39], [19, 48], [19, 20], [19, 24], [21, 32], [22, 50],\n    [22, 61], [22, 58], [22, 39], [22, 38], [22, 55], [23, 42], [24, 59],\n    [24, 47], [25, 50], [25, 52], [26, 36], [27, 34], [27, 41], [27, 33],\n    [27, 61], [28, 35], [28, 51], [28, 40], [28, 29], [28, 31], [29, 54],\n    [29, 59], [29, 42], [29, 43], [29, 52], [30, 51], [30, 40], [31, 36],\n    [31, 45], [32, 53], [33, 52], [33, 42], [35, 59], [36, 42], [38, 54],\n    [38, 61], [38, 53], [39, 42], [41, 60], [41, 49], [41, 51], [41, 45],\n    [43, 44], [43, 53], [44, 55], [45, 50], [49, 59], [50, 51], [52, 57],\n    [52, 58], [53, 62], [53, 56], [61, 63]\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from(edges)\n\n# Check for cycles\ncycle_basis = nx.cycle_basis(G)\n\n# Output result\nif cycle_basis:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
                "key_api": "nx.Graph() and nx.cycle_basis()",
                "key_experience": "Utilizing NetworkX for graph representation and cycle detection, which simplifies the task by leveraging built-in functions for efficient computation, resulting in concise and readable code."
            }
        ]
    },
    {
        "id": 4,
        "problem": "Find the maximum sum of the weights of three interconnected nodes.",
        "graph_type": "undirected",
        "experience": "### Summary of Overall Experience\n\nThe tasks centered on finding the maximum sum of weights of three interconnected nodes in undirected graphs using graph theory concepts in Python. Both tasks leveraged similar methodologies but applied them to different data sets.\n\n#### Key Practices and Insights\n\n1. **Utilization of NetworkX Library**:\n   - The NetworkX library was extensively used for graph operations such as creating graphs, adding nodes and edges, and accessing node attributes. This demonstrates how powerful library tools can streamline complex operations.\n   \n2. **Handling Node Weights as Attributes**:\n   - Weights were assigned as attributes to nodes in the graph, enabling straightforward access and manipulation. This not only optimizes the code but also simplifies the logic required to handle weighted nodes.\n   \n3. **Use of Combinations from itertools**:\n   - By utilizing `itertools.combinations`, the tasks efficiently generated all possible groups of three nodes, which was crucial for checking interconnectedness and calculating sums. This approach greatly improves computational efficiency.\n   \n4. **Function Definitions for Modularity**:\n   - Clear function definitions were employed to encapsulate logic, aiding in code readability and reusability. For example, the function to calculate the maximum sum was well-defined and could be reused with different graphs.\n   \n5. **Checking Interconnectedness**:\n   - The tasks included precise logic to check if three nodes are interconnected (all three nodes must have edges between each other). This ensures that only valid combinations contribute to the final result.\n   \n6. **Efficient Max Function Usage**:\n   - The `max` function was employed to keep track of the highest sum encountered, allowing for efficient updates and straightforward logic for determining maximum values.\n\n#### Key APIs and Libraries\n\n- **NetworkX**:\n  - **nx.Graph()**: For creating undirected graph objects.\n  - **add_node()**: To add nodes with specific attributes (weights).\n  - **add_edge()**: To connect nodes with edges.\n  - **has_edge()**: To check the existence of edges between nodes.\n\n- **itertools**:\n  - **combinations()**: To generate all possible combinations of a specified length from the input iterable, which was crucial for iterating through all groups of three nodes.\n\n#### Summary\nThe tasks highlighted key approaches to solving graph-related problems, emphasizing efficient graph construction and manipulation methods using NetworkX, and leveraging itertools for combinatorial operations. Essential practices such as clear function definitions, appropriate use of built-in functions for performance optimization, and effective node attribute handling contributed to achieving accurate and efficient results.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum sum of the weights of three interconnected nodes. In an undirected graph, [i, k] means that node i has the weight k. (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output the maximum sum of the weights of three interconnected nodes. Q: The nodes are numbered from 0 to 22, weights of nodes are: [0, 7] [1, 9] [2, 2] [3, 10] [4, 2] [5, 5] [6, 2] [7, 4] [8, 3] [9, 4] [10, 2] [11, 3] [12, 2] [13, 2] [14, 5] [15, 10] [16, 1] [17, 10] [18, 4] [19, 4] [20, 3] [21, 3] [22, 7], and the edges are: (0, 12) (0, 20) (0, 9) (1, 11) (1, 18) (2, 13) (2, 7) (2, 18) (2, 22) (3, 11) (3, 12) (3, 14) (3, 16) (4, 21) (4, 8) (4, 10) (4, 22) (4, 9) (4, 15) (5, 8) (5, 6) (6, 16) (7, 13) (8, 14) (8, 19) (9, 11) (10, 21) (10, 18) (10, 13) (11, 12) (11, 19) (11, 15) (11, 20) (11, 22) (14, 16) (14, 21) (16, 19) (18, 19) (18, 20) (19, 22). What is the maximum sum of the weights of three nodes?",
                "code": "import networkx as nx\nimport itertools\n\n# Input data\ndata = {\n    'NodeWeights': [[0, 7], [1, 9], [2, 2], [3, 10], [4, 2], [5, 5], [6, 2], \n                    [7, 4], [8, 3], [9, 4], [10, 2], [11, 3], [12, 2], \n                    [13, 2], [14, 5], [15, 10], [16, 1], [17, 10], \n                    [18, 4], [19, 4], [20, 3], [21, 3], [22, 7]],\n    'Edges': [[0, 12], [0, 20], [0, 9], [1, 11], [1, 18], [2, 13], \n              [2, 7], [2, 18], [2, 22], [3, 11], [3, 12], [3, 14], \n              [3, 16], [4, 21], [4, 8], [4, 10], [4, 22], [4, 9], \n              [4, 15], [5, 8], [5, 6], [6, 16], [7, 13], [8, 14], \n              [8, 19], [9, 11], [10, 21], [10, 18], [10, 13], \n              [11, 12], [11, 19], [11, 15], [11, 20], [11, 22], \n              [14, 16], [14, 21], [16, 19], [18, 19], [18, 20], \n              [19, 22]]\n}\n\n# Create a graph\nG = nx.Graph()\n\n# Add nodes with weights\nfor node, weight in data['NodeWeights']:\n    G.add_node(node, weight=weight)\n\n# Add edges\nfor edge in data['Edges']:\n    G.add_edge(edge[0], edge[1])\n\n# Function to find the maximum sum of weights of three interconnected nodes\ndef max_sum_of_three_interconnected_nodes(graph):\n    max_sum = 0\n    # Iterate through all combinations of three nodes\n    for triangle in itertools.combinations(graph.nodes(), 3):\n        if graph.has_edge(triangle[0], triangle[1]) and \\\n           graph.has_edge(triangle[1], triangle[2]) and \\\n           graph.has_edge(triangle[2], triangle[0]):\n            # Calculate the sum of weights\n            current_sum = graph.nodes[triangle[0]]['weight'] + \\\n                          graph.nodes[triangle[1]]['weight'] + \\\n                          graph.nodes[triangle[2]]['weight']\n            # Update max_sum if current_sum is greater\n            max_sum = max(max_sum, current_sum)\n    return max_sum\n\n# Calculate the maximum sum\nresult = max_sum_of_three_interconnected_nodes(G)\nprint(\"Maximum sum of weights of three interconnected nodes:\", result)",
                "key_api": "networkx",
                "key_experience": "Utilized the NetworkX library for graph operations, such as creating graphs, adding nodes and edges, and checking interconnections. Best practices include using clear function definitions, iterating through combinations for efficiency, and employing max function to keep track of maximum weights effectively."
            },
            {
                "question": "Find the maximum sum of the weights of three interconnected nodes. In an undirected graph, [i, k] means that node i has the weight k. (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output the maximum sum of the weights of three interconnected nodes. Q: The nodes are numbered from 0 to 3, weights of nodes are: [0, 6] [1, 2] [2, 9] [3, 9], and the edges are: (0, 1) (0, 3) (1, 3). What is the maximum sum of the weights of three nodes?",
                "code": "import networkx as nx\nfrom itertools import combinations\n\n# Input data\ninput_data = {\n    'Node_Weights': [{'Node': 0, 'Weight': 6}, {'Node': 1, 'Weight': 2}, {'Node': 2, 'Weight': 9}, {'Node': 3, 'Weight': 9}],\n    'Edges': [{'Node1': 0, 'Node2': 1}, {'Node1': 0, 'Node2': 3}, {'Node1': 1, 'Node2': 3}]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    G.add_edge(edge['Node1'], edge['Node2'])\n\n# Add node weights as node attributes\nfor node_weight in input_data['Node_Weights']:\n    G.nodes[node_weight['Node']]['weight'] = node_weight['Weight']\n\n# Function to find the maximum sum of weights of three interconnected nodes\ndef max_sum_of_interconnected_nodes(graph):\n    max_sum = 0\n    # Generate all combinations of three nodes\n    for nodes in combinations(graph.nodes(), 3):\n        # Check if all three nodes are interconnected\n        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]) and graph.has_edge(nodes[0], nodes[2]):\n            # Calculate the sum of their weights\n            current_sum = graph.nodes[nodes[0]]['weight'] + graph.nodes[nodes[1]]['weight'] + graph.nodes[nodes[2]]['weight']\n            # Update max_sum if current_sum is greater\n            max_sum = max(max_sum, current_sum)\n    return max_sum\n\n# Get the maximum sum of weights of three interconnected nodes\nresult = max_sum_of_interconnected_nodes(G)\nprint(result)",
                "key_api": "import networkx as nx, from itertools import combinations",
                "key_experience": "1. Use of NetworkX for graph creation and manipulation. 2. Efficiently using combinations from itertools to generate possible node groups. 3. Proper handling of graph structures avoids redundancy and improves performance. 4. Clear node attribute management for weighing nodes enhances code readability. 5. Utilizing comprehensions and built-in functions maximizes performance."
            }
        ]
    },
    {
        "id": 5,
        "problem": "Find the maximum sum of the weights of three interconnected nodes.",
        "graph_type": "undirected",
        "experience": "## Summary of Key Experiences in the Coding Tasks:\n\n### Overall Experience:\nBoth tasks involved solving the same problem: finding the maximum sum of the weights of three interconnected nodes in an undirected graph. The methodology employed in each task was relatively similar, with minor differences in data structures and problem scope.\n\n### Important Practices:\n1. **Use of NetworkX**:\n   - Both tasks utilized the NetworkX library for graph management, making it easier to handle nodes, edges, and their attributes.\n   - This approach facilitates the creation and manipulation of graphs, making the code more readable and efficient.\n\n2. **Combinatorial Algorithms**:\n   - The `itertools.combinations` function was used to efficiently generate all possible combinations of three nodes.\n   - This approach ensures thorough exploration of potential solutions without redundant computation, crucial for problems involving multiple possibilities.\n\n3. **Modular Code Structure**:\n   - Separating functionality into distinct functions (e.g., input handling, graph creation, and the main logic to find maximum sums) enhanced readability and maintainability.\n   - This modularization is a best practice in software development, allowing for easier debugging and future modifications.\n\n4. **Efficient Data Handling**:\n   - Iterating over node combinations and checking graph edges was done efficiently using loops and conditionals.\n   - Employing list comprehensions for summing node weights kept the code concise and clear.\n\n### Key Insights:\n1. **Graph Theory Application**:\n   - Practical application of graph theory concepts (nodes, edges, weights) helps solidify understanding.\n   - Recognizing the importance of interconnectedness in problem-solving is crucial in graph-related problems.\n\n2. **Performance Considerations**:\n   - Combinatorial problems can be computationally intensive; thus, efficient algorithms and data structures significantly impact performance.\n   - Implementing checks for interconnected nodes in a nested manner ensures all necessary conditions are validated before proceeding to sum weights.\n\n### Useful APIs and Libraries:\n1. **NetworkX**:\n   - A comprehensive library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.\n   - Key functions used include `Graph()`, `add_node()`, `add_edge()`, and `has_edge()`.\n   - NetworkX facilitates the management of node attributes (such as weights) and simplifies the construction of undirected graphs.\n\n2. **itertools**:\n   - The `combinations` function from itertools was pivotal in generating all possible groups of three nodes, without which the task would have been considerably more cumbersome.\n   - This standard library module offers highly efficient iteration tools, crucial for combinatorial tasks.\n\nIn conclusion, these tasks underscored the importance of leveraging powerful libraries like NetworkX and itertools to handle complex graph problems efficiently. Modular and clear code, combined with efficient algorithms, was key to successfully solving the problem.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum sum of the weights of three interconnected nodes. In an undirected graph, [i, k] means that node i has the weight k. (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output the maximum sum of the weights of three interconnected nodes. Q: The nodes are numbered from 0 to 3, weights of nodes are: [0, 6] [1, 2] [2, 9] [3, 9], and the edges are: (0, 1) (0, 3) (1, 3). What is the maximum sum of the weights of three nodes?",
                "code": "import networkx as nx\nfrom itertools import combinations\n\n# Input data\ninput_data = {\n    'Node_Weights': [{'Node': 0, 'Weight': 6}, {'Node': 1, 'Weight': 2}, {'Node': 2, 'Weight': 9}, {'Node': 3, 'Weight': 9}],\n    'Edges': [{'Node1': 0, 'Node2': 1}, {'Node1': 0, 'Node2': 3}, {'Node1': 1, 'Node2': 3}]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes with weights\nfor node_weight in input_data['Node_Weights']:\n    G.add_node(node_weight['Node'], weight=node_weight['Weight'])\n\n# Add edges\nfor edge in input_data['Edges']:\n    G.add_edge(edge['Node1'], edge['Node2'])\n\n# Function to find the maximum sum of weights of three interconnected nodes\ndef max_weight_of_interconnected_nodes(graph):\n    max_weight = 0\n    # Get all combinations of three nodes\n    for nodes in combinations(graph.nodes, 3):\n        # Check if all three nodes are interconnected\n        if graph.has_edge(nodes[0], nodes[1]) and graph.has_edge(nodes[1], nodes[2]) and graph.has_edge(nodes[0], nodes[2]):\n            # Calculate the sum of their weights\n            weight_sum = sum(graph.nodes[node]['weight'] for node in nodes)\n            max_weight = max(max_weight, weight_sum)\n    return max_weight\n\n# Calculate the maximum weight\nresult = max_weight_of_interconnected_nodes(G)\n\n# Output the result\nprint(result)",
                "key_api": "networkx",
                "key_experience": "Utilizing combinatorial algorithms to check for interconnected nodes, as well as setting node weights and handling graph structures efficiently."
            },
            {
                "question": "Find the maximum sum of the weights of three interconnected nodes. In an undirected graph, [i, k] means that node i has the weight k. (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output the maximum sum of the weights of three interconnected nodes. Q: The nodes are numbered from 0 to 22, weights of nodes are: [0, 7] [1, 9] [2, 2] [3, 10] [4, 2] [5, 5] [6, 2] [7, 4] [8, 3] [9, 4] [10, 2] [11, 3] [12, 2] [13, 2] [14, 5] [15, 10] [16, 1] [17, 10] [18, 4] [19, 4] [20, 3] [21, 3] [22, 7], and the edges are: (0, 12) (0, 20) (0, 9) (1, 11) (1, 18) (2, 13) (2, 7) (2, 18) (2, 22) (3, 11) (3, 12) (3, 14) (3, 16) (4, 21) (4, 8) (4, 10) (4, 22) (4, 9) (4, 15) (5, 8) (5, 6) (6, 16) (7, 13) (8, 14) (8, 19) (9, 11) (10, 21) (10, 18) (10, 13) (11, 12) (11, 19) (11, 15) (11, 20) (11, 22) (14, 16) (14, 21) (16, 19) (18, 19) (18, 20) (19, 22). What is the maximum sum of the weights of three nodes?",
                "code": "import networkx as nx\nimport itertools\n\n# Input data\ndata = {\n    'Node_Weights': [[0, 7], [1, 9], [2, 2], [3, 10], [4, 2], [5, 5], [6, 2], [7, 4], \n                     [8, 3], [9, 4], [10, 2], [11, 3], [12, 2], [13, 2], [14, 5], \n                     [15, 10], [16, 1], [17, 10], [18, 4], [19, 4], [20, 3], \n                     [21, 3], [22, 7]],\n    'Edges': [[0, 12], [0, 20], [0, 9], [1, 11], [1, 18], [2, 13], [2, 7], \n              [2, 18], [2, 22], [3, 11], [3, 12], [3, 14], [3, 16], [4, 21], \n              [4, 8], [4, 10], [4, 22], [4, 9], [4, 15], [5, 8], [5, 6], \n              [6, 16], [7, 13], [8, 14], [8, 19], [9, 11], [10, 21], \n              [10, 18], [10, 13], [11, 12], [11, 19], [11, 15], [11, 20], \n              [11, 22], [14, 16], [14, 21], [16, 19], [18, 19], [18, 20], \n              [19, 22]]\n}\n\n# Create a graph\nG = nx.Graph()\n\n# Add nodes with weights\nfor node, weight in data['Node_Weights']:\n    G.add_node(node, weight=weight)\n\n# Add edges\nfor edge in data['Edges']:\n    G.add_edge(edge[0], edge[1])\n\n# Function to find the maximum sum of weights of three interconnected nodes\ndef max_sum_of_three_interconnected_nodes(graph):\n    max_sum = 0\n    # Iterate through all combinations of three nodes\n    for node_combination in itertools.combinations(graph.nodes(), 3):\n        # Check if all three nodes are interconnected\n        if graph.has_edge(node_combination[0], node_combination[1]) and \\\n           graph.has_edge(node_combination[1], node_combination[2]) and \\\n           graph.has_edge(node_combination[0], node_combination[2]):\n            # Calculate the sum of weights\n            current_sum = sum(graph.nodes[node]['weight'] for node in node_combination)\n            max_sum = max(max_sum, current_sum)\n    return max_sum\n\n# Calculate the maximum sum\nresult = max_sum_of_three_interconnected_nodes(G)\nprint(\"Maximum sum of weights of three interconnected nodes:\", result)",
                "key_api": "networkx, itertools",
                "key_experience": "Utilize NetworkX for graph manipulation and node attribute handling. Use itertools for combinatorial logic, ensuring efficient checks for interconnected nodes. Keep the code modular and readable by separating logic into functions, and ensure that weight calculations are concise and clearly commented."
            }
        ]
    },
    {
        "id": 6,
        "problem": "Determine whether node 56 and node 9 are connected in the undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Overall Experience\n\n#### Key Practices:\n1. **Structured Input Handling**:\n   - Clearly defining and structuring the input data (nodes and edges) is crucial for creating and manipulating graphs. This was consistently done by defining nodes as a range and edges as a list of tuples.\n   \n2. **Use of NetworkX Library**:\n   - **Graph Creation**: The `networkx` library was used for its robust and straightforward API, particularly for creating undirected graphs using `nx.Graph()` and adding edges with `G.add_edges_from(edges)`.\n   - **Connectivity Check**: Utilizing `nx.has_path(G, node1, node2)` to efficiently determine if there is a path between two nodes is a highly valuable feature for graph-related tasks.\n\n#### Key Insights:\n1. **Efficiency and Ease with NetworkX**:\n   - NetworkX significantly simplifies complex graph operations, which would otherwise require substantial manual coding. Its high-level functions provide both power and simplicity for tasks like checking node connectivity.\n\n2. **Handling Large Graphs**:\n   - Even for graphs with a large number of nodes and edges, NetworkX handles operations smoothly, indicating its efficiency and reliability in real-world applications.\n\n3. **KISS Principle (Keep It Simple, Stupid)**:\n   - By focusing on core functionalities and leveraging powerful libraries, code can remain concise, maintainable, and easily understandable.\n\n#### Useful APIs:\n1. **Network Creation and Manipulation**:\n   - `nx.Graph()`: Creates an undirected graph.\n   - `G.add_edges_from(edges)`: Adds multiple edges to a graph.\n\n2. **Connectivity Check**:\n   - `nx.has_path(G, node1, node2)`: Returns `True` if there is a path between node1 and node2, `False` otherwise.\n\n#### Best Practices:\n- **Modular Code Structure**: Defining nodes and edges in a structured manner before operations enhances readability and maintainability.\n- **Clear and Concise Output**: Using simple conditional statements to output results (`Yes` or `No`) ensures clarity.\n\nOverall, the experience highlights the importance of leveraging robust libraries like NetworkX for graph-related operations, maintaining clear and structured code, and following best practices for efficient and effective solutions.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether two nodes are connected in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph and a pair of nodes, you need to output Yes or No, indicating whether the node i and node j are connected. Q: The nodes are numbered from 0 to 75, and the edges are: (0, 14) (0, 6) (0, 24) (1, 61) (1, 32) (1, 48) (1, 10) (1, 21) (1, 25) (2, 16) (3, 63) (3, 6) (4, 14) (4, 56) (4, 23) (4, 21) (5, 38) (5, 61) (6, 50) (6, 51) (7, 15) (8, 73) (8, 63) (8, 10) (9, 68) (9, 35) (9, 42) (9, 75) (10, 38) (10, 49) (11, 63) (12, 33) (13, 55) (13, 46) (13, 71) (13, 49) (14, 47) (15, 16) (15, 28) (15, 60) (16, 40) (16, 23) (16, 71) (16, 39) (17, 46) (17, 28) (17, 47) (17, 25) (18, 24) (19, 30) (20, 74) (20, 31) (20, 51) (21, 23) (21, 48) (21, 39) (21, 33) (22, 27) (22, 62) (23, 70) (23, 42) (23, 32) (24, 54) (25, 46) (25, 38) (25, 36) (25, 58) (26, 42) (27, 72) (28, 49) (28, 40) (28, 45) (29, 55) (30, 59) (30, 53) (30, 35) (30, 75) (31, 63) (32, 60) (32, 68) (33, 52) (34, 46) (35, 66) (36, 65) (40, 50) (41, 45) (43, 69) (43, 48) (43, 62) (44, 70) (44, 59) (44, 74) (45, 46) (47, 74) (48, 54) (51, 52) (52, 71) (54, 56) (56, 68) (56, 57) (58, 67) (60, 63) (62, 72) (62, 71) (62, 66) (66, 67) (68, 71) (74, 75). Is there a path between node 56 and node 9?",
                "code": "import networkx as nx\n\n# Define the nodes and edges based on the provided input\nnodes = list(range(76))  # Nodes from 0 to 75\nedges = [\n    [0, 14], [0, 6], [0, 24], [1, 61], [1, 32], [1, 48], [1, 10], [1, 21], \n    [1, 25], [2, 16], [3, 63], [3, 6], [4, 14], [4, 56], [4, 23], [4, 21], \n    [5, 38], [5, 61], [6, 50], [6, 51], [7, 15], [8, 73], [8, 63], [8, 10], \n    [9, 68], [9, 35], [9, 42], [9, 75], [10, 38], [10, 49], [11, 63], [12, 33], \n    [13, 55], [13, 46], [13, 71], [13, 49], [14, 47], [15, 16], [15, 28], \n    [15, 60], [16, 40], [16, 23], [16, 71], [16, 39], [17, 46], [17, 28], \n    [17, 47], [17, 25], [18, 24], [19, 30], [20, 74], [20, 31], [20, 51], \n    [21, 23], [21, 48], [21, 39], [21, 33], [22, 27], [22, 62], [23, 70], \n    [23, 42], [23, 32], [24, 54], [25, 46], [25, 38], [25, 36], [25, 58], \n    [26, 42], [27, 72], [28, 49], [28, 40], [28, 45], [29, 55], [30, 59], \n    [30, 53], [30, 35], [30, 75], [31, 63], [32, 60], [32, 68], [33, 52], \n    [34, 46], [35, 66], [36, 65], [40, 50], [41, 45], [43, 69], [43, 48], \n    [43, 62], [44, 70], [44, 59], [44, 74], [45, 46], [47, 74], [48, 54], \n    [51, 52], [52, 71], [54, 56], [56, 68], [56, 57], [58, 67], [60, 63], \n    [62, 72], [62, 71], [62, 66], [66, 67], [68, 71], [74, 75]\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from(edges)\n\n# Check if nodes 56 and 9 are connected\nconnected = nx.has_path(G, 56, 9)\n\n# Output the result\nprint(\"Yes\" if connected else \"No\")",
                "key_api": "networkx.has_path",
                "key_experience": "Utilized NetworkX for efficient graph manipulation, created undirected graphs using Graph class, checked connectivity with has_path for optimal performance."
            },
            {
                "question": "Determine whether two nodes are connected in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph and a pair of nodes, you need to output Yes or No, indicating whether the node i and node j are connected. Q: The nodes are numbered from 0 to 56, and the edges are: (0, 23) (0, 47) (0, 34) (1, 42) (2, 3) (2, 24) (3, 50) (4, 33) (6, 42) (7, 49) (7, 56) (9, 16) (9, 50) (10, 15) (10, 29) (11, 42) (11, 54) (12, 41) (12, 19) (14, 54) (14, 51) (15, 46) (15, 42) (17, 39) (19, 51) (20, 38) (21, 23) (21, 29) (21, 48) (22, 38) (22, 30) (23, 51) (23, 25) (24, 47) (24, 31) (25, 53) (25, 45) (26, 41) (27, 47) (27, 38) (28, 37) (29, 44) (30, 52) (30, 35) (32, 55) (35, 43) (36, 47) (36, 42) (36, 40) (38, 49) (38, 48) (39, 43) (39, 52) (43, 45) (44, 51) (46, 47) (47, 48) (52, 53). Is there a path between node 44 and node 14?",
                "code": "import networkx as nx\n\n# Define the nodes and edges based on the input\nnodes = range(57)  # Nodes from 0 to 56\nedges = [\n    [0, 23], [0, 47], [0, 34], [1, 42], [2, 3], [2, 24], [3, 50],\n    [4, 33], [6, 42], [7, 49], [7, 56], [9, 16], [9, 50], [10, 15],\n    [10, 29], [11, 42], [11, 54], [12, 41], [12, 19], [14, 54],\n    [14, 51], [15, 46], [15, 42], [17, 39], [19, 51], [20, 38],\n    [21, 23], [21, 29], [21, 48], [22, 38], [22, 30], [23, 51],\n    [23, 25], [24, 47], [24, 31], [25, 53], [25, 45], [26, 41],\n    [27, 47], [27, 38], [28, 37], [29, 44], [30, 52], [30, 35],\n    [32, 55], [35, 43], [36, 47], [36, 42], [36, 40], [38, 49],\n    [38, 48], [39, 43], [39, 52], [43, 45], [44, 51], [46, 47],\n    [47, 48], [52, 53]\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from(edges)\n\n# Define the node pair to check for connectivity\nnode_pair = (44, 14)\n\n# Check if there is a path between the two nodes\npath_exists = nx.has_path(G, node_pair[0], node_pair[1])\n\n# Output the result\nresult = \"Yes\" if path_exists else \"No\"\nprint(result)",
                "key_api": "networkx.has_path",
                "key_experience": "Using NetworkX to easily check connectivity in graphs. Clear structuring of input data (nodes and edges) and efficient graph creation are essential best practices."
            }
        ]
    },
    {
        "id": 7,
        "problem": "Determine whether node 56 and node 9 are connected in the undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Overall Experience\n\n#### Key Practices\n1. **Leveraging Libraries**:\n   Utilizing the NetworkX library in both tasks allowed for efficient handling of graph data structures. This library provides advanced functionalities for graph creation, manipulation, and analysis, which simplifies the process of solving graph-related problems.\n   \n2. **Clear Code Structure**:\n   Organizing code into functions enhances readability and reusability. By encapsulating specific functionalities, such as checking path existence between nodes within a function, the code becomes modular and easier to understand, maintain, and debug.\n\n3. **Documentation and Comments**:\n   Adding comments throughout the code to explain each step and the function's purpose enhances the clarity and comprehensibility of the code. This practice is essential, especially in complex problem-solving tasks like those involving graphs.\n\n#### Key Insights\n1. **Graph-Theoretic Solutions**:\n   Both tasks highlight the importance of graph-theoretic approaches to solving connectivity problems. Understanding concepts like path existence and leveraging built-in functions like `nx.has_path()` can dramatically simplify graph queries.\n\n2. **Efficient Pathfinding**:\n   Using the `nx.has_path()` function from NetworkX allowed for efficient pathfinding between nodes in undirected graphs. This function abstracts the complexity of implementing pathfinding algorithms (like DFS or BFS) and provides an out-of-the-box solution.\n\n3. **Scalability**:\n   The approaches used were scalable due to the NetworkX library's optimizations. This is crucial when dealing with larger graphs, where manual implementations of algorithms could be computationally expensive and more prone to errors.\n\n#### Useful APIs\n1. **NetworkX Library**:\n   - `nx.Graph()`: Creates an undirected graph.\n   - `nx.has_path(graph, node1, node2)`: Checks if there is a path between `node1` and `node2` in the given `graph`.\n\n### Conclusion\nOverall, the experience demonstrated the importance of utilizing robust libraries like NetworkX for complex graph operations. Key practices included maintaining a clear code structure, adding useful documentation, and utilizing efficient pre-built functions. This approach not only simplifies the coding process but also ensures that the solutions are scalable and maintainable.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether two nodes are connected in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph and a pair of nodes, you need to output Yes or No, indicating whether the node i and node j are connected. Q: The nodes are numbered from 0 to 56, and the edges are: (0, 23) (0, 47) (0, 34) (1, 42) (2, 3) (2, 24) (3, 50) (4, 33) (6, 42) (7, 49) (7, 56) (9, 16) (9, 50) (10, 15) (10, 29) (11, 42) (11, 54) (12, 41) (12, 19) (14, 54) (14, 51) (15, 46) (15, 42) (17, 39) (19, 51) (20, 38) (21, 23) (21, 29) (21, 48) (22, 38) (22, 30) (23, 51) (23, 25) (24, 47) (24, 31) (25, 53) (25, 45) (26, 41) (27, 47) (27, 38) (28, 37) (29, 44) (30, 52) (30, 35) (32, 55) (35, 43) (36, 47) (36, 42) (36, 40) (38, 49) (38, 48) (39, 43) (39, 52) (43, 45) (44, 51) (46, 47) (47, 48) (52, 53). Is there a path between node 44 and node 14?",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nedges = [\n    [0, 23], [0, 47], [0, 34], [1, 42], [2, 3], [2, 24], [3, 50], [4, 33],\n    [6, 42], [7, 49], [7, 56], [9, 16], [9, 50], [10, 15], [10, 29], [11, 42],\n    [11, 54], [12, 41], [12, 19], [14, 54], [14, 51], [15, 46], [15, 42],\n    [17, 39], [19, 51], [20, 38], [21, 23], [21, 29], [21, 48], [22, 38],\n    [22, 30], [23, 51], [23, 25], [24, 47], [24, 31], [25, 53], [25, 45],\n    [26, 41], [27, 47], [27, 38], [28, 37], [29, 44], [30, 52], [30, 35],\n    [32, 55], [35, 43], [36, 47], [36, 42], [36, 40], [38, 49], [38, 48],\n    [39, 43], [39, 52], [43, 45], [44, 51], [46, 47], [47, 48], [52, 53]\n]\n\n# Create an undirected graph\nG = nx.Graph(edges)\n\n# Function to check if there is a path between two nodes\ndef is_path_between_nodes(graph, start_node, end_node):\n    return nx.has_path(graph, start_node, end_node)\n\n# Check for a path between node 44 and node 14\npath_exists = is_path_between_nodes(G, 44, 14)\n\n# Output the result\noutput = \"Yes\" if path_exists else \"No\"\nprint(output)",
                "key_api": "networkx.has_path",
                "key_experience": "Using NetworkX for graph analysis allows for efficient pathfinding in undirected graphs. Ensuring that code is structured with functions helps maintain clarity and reusability. Adding comments and organized code enhances readability and debugging."
            },
            {
                "question": "Determine whether two nodes are connected in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph and a pair of nodes, you need to output Yes or No, indicating whether the node i and node j are connected. Q: The nodes are numbered from 0 to 75, and the edges are: (0, 14) (0, 6) (0, 24) (1, 61) (1, 32) (1, 48) (1, 10) (1, 21) (1, 25) (2, 16) (3, 63) (3, 6) (4, 14) (4, 56) (4, 23) (4, 21) (5, 38) (5, 61) (6, 50) (6, 51) (7, 15) (8, 73) (8, 63) (8, 10) (9, 68) (9, 35) (9, 42) (9, 75) (10, 38) (10, 49) (11, 63) (12, 33) (13, 55) (13, 46) (13, 71) (13, 49) (14, 47) (15, 16) (15, 28) (15, 60) (16, 40) (16, 23) (16, 71) (16, 39) (17, 46) (17, 28) (17, 47) (17, 25) (18, 24) (19, 30) (20, 74) (20, 31) (20, 51) (21, 23) (21, 48) (21, 39) (21, 33) (22, 27) (22, 62) (23, 70) (23, 42) (23, 32) (24, 54) (25, 46) (25, 38) (25, 36) (25, 58) (26, 42) (27, 72) (28, 49) (28, 40) (28, 45) (29, 55) (30, 59) (30, 53) (30, 35) (30, 75) (31, 63) (32, 60) (32, 68) (33, 52) (34, 46) (35, 66) (36, 65) (40, 50) (41, 45) (43, 69) (43, 48) (43, 62) (44, 70) (44, 59) (44, 74) (45, 46) (47, 74) (48, 54) (51, 52) (52, 71) (54, 56) (56, 68) (56, 57) (58, 67) (60, 63) (62, 72) (62, 71) (62, 66) (66, 67) (68, 71) (74, 75). Is there a path between node 56 and node 9?",
                "code": "import networkx as nx\n\n# Define the edges of the graph\nedges = [\n    [0, 14], [0, 6], [0, 24], [1, 61], [1, 32], [1, 48], [1, 10], [1, 21], [1, 25],\n    [2, 16], [3, 63], [3, 6], [4, 14], [4, 56], [4, 23], [4, 21], [5, 38], [5, 61],\n    [6, 50], [6, 51], [7, 15], [8, 73], [8, 63], [8, 10], [9, 68], [9, 35], [9, 42],\n    [9, 75], [10, 38], [10, 49], [11, 63], [12, 33], [13, 55], [13, 46], [13, 71],\n    [13, 49], [14, 47], [15, 16], [15, 28], [15, 60], [16, 40], [16, 23], [16, 71],\n    [16, 39], [17, 46], [17, 28], [17, 47], [17, 25], [18, 24], [19, 30], [20, 74],\n    [20, 31], [20, 51], [21, 23], [21, 48], [21, 39], [21, 33], [22, 27], [22, 62],\n    [23, 70], [23, 42], [23, 32], [24, 54], [25, 46], [25, 38], [25, 36], [25, 58],\n    [26, 42], [27, 72], [28, 49], [28, 40], [28, 45], [29, 55], [30, 59], [30, 53],\n    [30, 35], [30, 75], [31, 63], [32, 60], [32, 68], [33, 52], [34, 46], [35, 66],\n    [36, 65], [40, 50], [41, 45], [43, 69], [43, 48], [43, 62], [44, 70], [44, 59],\n    [44, 74], [45, 46], [47, 74], [48, 54], [51, 52], [52, 71], [54, 56], [56, 68],\n    [56, 57], [58, 67], [60, 63], [62, 72], [62, 71], [62, 66], [66, 67], [68, 71],\n    [74, 75]\n]\n\n# Create an undirected graph\nG = nx.Graph(edges)\n\n# Define the node pair to check connectivity\nnode_pair = (56, 9)\n\n# Check if the nodes are connected\nconnected = nx.has_path(G, node_pair[0], node_pair[1])\n\n# Output result\nresult = \"Yes\" if connected else \"No\"\nprint(result)",
                "key_api": "networkx.has_path",
                "key_experience": "Utilizing the NetworkX library to efficiently check the connectivity between nodes in an undirected graph, while ensuring the code is structured, documented, and leverages efficient graph representation and operations."
            }
        ]
    },
    {
        "id": 8,
        "problem": "Determine whether or not there is a Hamiltonian path in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Key Experiences\n\n#### 1. **Backtracking for Hamiltonian Path Search:**\n   - **Concept:** Both tasks used backtracking to explore all possible paths in the graph system and determine if any of the paths covers all nodes exactly once.\n   - **Implementation:** The backtracking approach involves:\n     1. Starting from a node.\n     2. Recursively trying to extend the path by exploring neighbors not already in the path.\n     3. Backtracking when a dead-end is reached (i.e., when no new node can be added to the path without revisiting nodes).\n\n#### 2. **Graph Representation Using NetworkX:**\n   - **Efficient Graph Creation:** NetworkX was utilized to model the graphs and handle graph operations like adding nodes and edges, and accessing neighbors.\n   - **Neighbor Exploration:** NetworkX\u2019s methods for exploring adjacent nodes were particularly useful for implementing the backtracking algorithm.\n\n#### 3. **Graph Initialization and Input Handling:**\n   - **Node and Edge Addition:** Nodes and edges were added to the graph from the provided input data, transforming it into a navigable data structure.\n   - **Parsing Input Data:** For the second task, edges in string format were parsed using `eval()` to convert them into list format that NetworkX could use.\n\n### Key Practices and Insights:\n\n1. **Effective Use of Backtracking:**\n   - **Modularity:** Structuring the path exploration and backtracking within a helper function to keep the code modular and easier to debug.\n   - **Recursive Exploration:** Using recursion for extending paths ensures clean and intuitive code flow for traversal and backtracking.\n\n2. **Leverage NetworkX Library:**\n   - **Node and Edge Management:** The library simplifies the management of complex graph structures, making it straightforward to add and manipulate nodes and edges.\n   - **Efficient Neighbor Exploration:** NetworkX\u2019s built-in methods for accessing node neighbors streamline the implementation of path-finding algorithms.\n\n3. **Path Validity Checks:**\n   - **Avoiding Revisited Nodes:** Ensuring a node is not revisited in the same path to maintain the Hamiltonian path property.\n   - **Complete Path Verification:** Verification that the constructed path includes all nodes exactly once before confirming a Hamiltonian path.\n\n### Useful APIs and Methods:\n\n- **NetworkX (`nx`) Methods:**\n  - `nx.Graph()`: To create an undirected graph.\n  - `graph.add_nodes_from()`: Add multiple nodes to the graph.\n  - `graph.add_edges_from()`: Add multiple edges to the graph.\n  - `graph.nodes()`: Access all nodes in the graph.\n  - `graph.neighbors(node)`: Retrieve all neighbors of a specific node.\n\nThese key experiences and practices ensured an efficient and clear approach to solving the problem of determining Hamiltonian paths in the given graphs. By leveraging the capabilities of NetworkX and the structured approach of backtracking, the tasks were accomplished effectively.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether or not there is a Hamiltonian path in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a Hamiltonian path in the graph. Q: The nodes are numbered from 0 to 4, and the edges are: (0, 1) (0, 3) (0, 4) (0, 2) (1, 4) (2, 4) (2, 3) (3, 4). Is there a Hamiltonian path in this graph?",
                "code": "import networkx as nx\n\ndef is_hamiltonian_path(graph):\n    # Get all nodes in the graph\n    nodes = list(graph.nodes())\n    \n    # Helper function for backtracking\n    def backtrack(path):\n        # If the path includes all nodes, we found a Hamiltonian path\n        if len(path) == len(nodes):\n            return True\n        \n        # Get the last node in the current path\n        last_node = path[-1]\n        \n        # Explore neighbors of the last node\n        for neighbor in graph.neighbors(last_node):\n            if neighbor not in path:  # Ensure we don't revisit nodes\n                path.append(neighbor)  # Add neighbor to the path\n                if backtrack(path):  # Recur\n                    return True\n                path.pop()  # Backtrack\n        \n        return False  # No Hamiltonian path found from this path\n\n    # Try starting from each node\n    for start_node in nodes:\n        if backtrack([start_node]):\n            return \"Yes\"\n    \n    return \"No\"\n\n# Input graph data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4],\n    'Edges': [[0, 1], [0, 3], [0, 4], [0, 2], [1, 4], [2, 4], [2, 3], [3, 4]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Check for Hamiltonian path\nresult = is_hamiltonian_path(G)\nprint(result)  # Output: Yes or No",
                "key_api": "networkx",
                "key_experience": "Utilized backtracking for searching Hamiltonian paths along with effective graph representation using the NetworkX library, ensuring node and edge addition is straightforward and allowing for concise neighbor exploration."
            },
            {
                "question": "Determine whether or not there is a Hamiltonian path in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a Hamiltonian path in the graph. Q: The nodes are numbered from 0 to 20, and the edges are: (0, 6) (0, 5) (0, 19) (0, 14) (0, 17) (0, 12) (0, 15) (0, 20) (0, 3) (0, 9) (0, 2) (0, 11) (0, 1) (1, 17) (1, 15) (1, 20) (1, 12) (1, 6) (1, 4) (1, 16) (1, 9) (1, 18) (1, 8) (2, 6) (2, 15) (2, 17) (2, 19) (2, 4) (2, 9) (2, 16) (2, 20) (2, 11) (2, 18) (2, 14) (2, 3) (3, 9) (3, 13) (3, 16) (3, 20) (3, 19) (3, 11) (3, 7) (3, 6) (3, 15) (3, 4) (3, 8) (3, 12) (4, 12) (4, 5) (4, 13) (4, 20) (4, 19) (4, 15) (4, 18) (4, 17) (4, 14) (4, 8) (5, 12) (5, 9) (5, 14) (5, 7) (5, 18) (5, 10) (5, 11) (5, 17) (5, 19) (5, 8) (5, 16) (6, 18) (6, 11) (6, 9) (6, 14) (6, 20) (6, 7) (6, 12) (6, 16) (6, 15) (6, 19) (6, 10) (6, 17) (6, 8) (7, 17) (7, 19) (7, 10) (7, 16) (7, 18) (7, 8) (7, 11) (7, 9) (7, 15) (7, 14) (8, 19) (8, 13) (8, 17) (8, 10) (8, 20) (8, 15) (9, 13) (9, 12) (9, 20) (9, 18) (9, 17) (9, 11) (9, 16) (9, 10) (10, 19) (10, 18) (10, 20) (10, 12) (10, 11) (10, 14) (10, 13) (10, 17) (11, 14) (11, 12) (11, 17) (11, 15) (12, 19) (12, 18) (12, 14) (12, 13) (12, 20) (12, 17) (13, 20) (13, 19) (13, 16) (13, 17) (13, 14) (14, 18) (14, 19) (14, 15) (15, 18) (15, 19) (15, 20) (16, 20) (16, 18) (17, 18) (17, 19) (18, 20) (18, 19). Is there a Hamiltonian path in this graph?",
                "code": "import networkx as nx\n\ndef is_hamiltonian_path(graph):\n    # Helper function to perform backtracking\n    def backtrack(path):\n        # If the path includes all nodes, we found a Hamiltonian path\n        if len(path) == len(graph.nodes):\n            return True\n        \n        # Get the last node in the current path\n        last_node = path[-1]\n        \n        # Explore neighbors of the last node\n        for neighbor in graph.neighbors(last_node):\n            if neighbor not in path:  # Ensure we don't revisit nodes\n                path.append(neighbor)  # Add neighbor to the path\n                if backtrack(path):  # Recur\n                    return True\n                path.pop()  # Backtrack\n        \n        return False\n\n    # Start backtracking from each node\n    for start_node in graph.nodes:\n        if backtrack([start_node]):\n            return True\n            \n    return False\n\n# Input data\ninput_data = {\n    'Nodes': '0 to 20',\n    'Edges': ['[0, 6]', '[0, 5]', '[0, 19]', '[0, 14]', '[0, 17]', '[0, 12]', '[0, 15]', '[0, 20]', \n              '[0, 3]', '[0, 9]', '[0, 2]', '[0, 11]', '[0, 1]', '[1, 17]', '[1, 15]', '[1, 20]', \n              '[1, 12]', '[1, 6]', '[1, 4]', '[1, 16]', '[1, 9]', '[1, 18]', '[1, 8]', '[2, 6]', \n              '[2, 15]', '[2, 17]', '[2, 19]', '[2, 4]', '[2, 9]', '[2, 16]', '[2, 20]', '[2, 11]', \n              '[2, 18]', '[2, 14]', '[2, 3]', '[3, 9]', '[3, 13]', '[3, 16]', '[3, 20]', '[3, 19]', \n              '[3, 11]', '[3, 7]', '[3, 6]', '[3, 15]', '[3, 4]', '[3, 8]', '[3, 12]', '[4, 12]', \n              '[4, 5]', '[4, 13]', '[4, 20]', '[4, 19]', '[4, 15]', '[4, 18]', '[4, 17]', '[4, 14]', \n              '[4, 8]', '[5, 12]', '[5, 9]', '[5, 14]', '[5, 7]', '[5, 18]', '[5, 10]', '[5, 11]', \n              '[5, 17]', '[5, 19]', '[5, 8]', '[5, 16]', '[6, 18]', '[6, 11]', '[6, 9]', '[6, 14]', \n              '[6, 20]', '[6, 7]', '[6, 12]', '[6, 16]', '[6, 15]', '[6, 19]', '[6, 10]', '[6, 17]', \n              '[6, 8]', '[7, 17]', '[7, 19]', '[7, 10]', '[7, 16]', '[7, 18]', '[7, 8]', '[7, 11]', \n              '[7, 9]', '[7, 15]', '[7, 14]', '[8, 19]', '[8, 13]', '[8, 17]', '[8, 10]', '[8, 20]', \n              '[8, 15]', '[9, 13]', '[9, 12]', '[9, 20]', '[9, 18]', '[9, 17]', '[9, 11]', '[9, 16]', \n              '[9, 10]', '[10, 19]', '[10, 18]', '[10, 20]', '[10, 12]', '[10, 11]', '[10, 14]', \n              '[10, 13]', '[10, 17]', '[11, 14]', '[11, 12]', '[11, 17]', '[11, 15]', '[12, 19]', \n              '[12, 18]', '[12, 14]', '[12, 13]', '[12, 20]', '[12, 17]', '[13, 20]', '[13, 19]', \n              '[13, 16]', '[13, 17]', '[13, 14]', '[14, 18]', '[14, 19]', '[14, 15]', '[15, 18]', \n              '[15, 19]', '[15, 20]', '[16, 20]', '[16, 18]', '[17, 18]', '[17, 19]', '[18, 20]', \n              '[18, 19]']\n}\n\n# Create the graph\nedges = [eval(edge) for edge in input_data['Edges']]\nG = nx.Graph(edges)\n\n# Check for Hamiltonian path\nhas_hamiltonian_path = is_hamiltonian_path(G)\n\n# Output result\nprint(\"Yes\" if has_hamiltonian_path else \"No\")",
                "key_api": "NetworkX library (nx.Graph, graph.neighbors, graph.nodes)",
                "key_experience": "Utilized backtracking for exploring possible paths in the graph; ensured robust path validation by checking if nodes are revisited; leveraged NetworkX to efficiently create and manage graph structure."
            }
        ]
    },
    {
        "id": 9,
        "problem": "Determine whether or not there is a Hamiltonian path in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Overall Experience\n\n#### Most Important Practices:\n1. **Utilization of Backtracking with Recursion:**\n   - **Hamiltonian Path Detection:** Both tasks efficiently use backtracking to explore all possible paths, ensuring thorough checks for Hamiltonian paths.\n   - **Node Visits:** Recursive backtracking is employed to prevent node revisits, maintaining path validity and enhancing the algorithm\u2019s performance.\n\n2. **Graph Representation using NetworkX:**\n   - **Graph Creation:** NetworkX library is utilized to construct undirected graph structures, simplifying the process of adding nodes and edges.\n   - **Edge Checking:** Functions provided by NetworkX help in easily verifying the presence of edges between nodes, crucial for path validation.\n\n#### Key Insights:\n1. **Graph Theory Application:**\n   - **Practical Implementation:** The tasks highlight the application of theoretical graph concepts like Hamiltonian paths in practical coding problems.\n   - **Efficiency and Clarity:** The example codes elucidate how combining recursion with graph structures can lead to efficient and clear implementations, suited for complex graph problems.\n\n2. **Algorithm Design:**\n   - **Recursive Backtracking:** Designing algorithms with recursive backtracking showcases a deeper understanding of algorithmic strategies that can handle substantial complexity by exploring all possible solutions and backtracking upon dead ends.\n\n3. **Input Flexibility and Scalability:**\n   - **Generalization:** The ability to handle different graph sizes, from small (5 nodes) to much larger ones (21 nodes), demonstrates scalable and flexible code design, showcasing adaptability to varying problem scales.\n\n#### Useful APIs:\n- **NetworkX:**\n  - **Graph Creation:** `nx.Graph()` to create an undirected graph.\n  - **Node and Edge Addition:** `G.add_nodes_from(nodes)`, `G.add_edges_from(edges)` to add nodes and edges into the graph.\n  - **Neighbor Checking:** `graph.neighbors(node)` to get neighbors of a specific node.\n  - **Edge Check:** `graph.has_edge(node1, node2)` to check if an edge exists between two nodes.\n\n### Conclusion\nThe experiences from these coding tasks reflect a proficient application of recursive backtracking for Hamiltonian path detection and a firm grasp of graph theory concepts using the NetworkX library. The practices and insights gained are invaluable for handling complex graph problems effectively with clear and efficient code structure.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether or not there is a Hamiltonian path in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a Hamiltonian path in the graph. Q: The nodes are numbered from 0 to 4, and the edges are: (0, 1) (0, 3) (0, 4) (0, 2) (1, 4) (2, 4) (2, 3) (3, 4). Is there a Hamiltonian path in this graph?",
                "code": "import networkx as nx\n\ndef is_hamiltonian_path(graph, path=[]):\n    # If the path includes all nodes, we have a Hamiltonian path\n    if len(path) == len(graph.nodes):\n        return True\n    \n    # Get the last node in the current path\n    last_node = path[-1] if path else None\n    \n    # Iterate through all nodes to find the next valid node\n    for node in graph.nodes:\n        if node not in path:\n            # Check if there is an edge from the last node to the current node\n            if last_node is None or graph.has_edge(last_node, node):\n                # Recur with the new path\n                if is_hamiltonian_path(graph, path + [node]):\n                    return True\n    return False\n\ndef has_hamiltonian_path(nodes, edges):\n    # Create an undirected graph\n    G = nx.Graph()\n    G.add_nodes_from(nodes)\n    G.add_edges_from(edges)\n    \n    # Check for Hamiltonian path starting from each node\n    for start_node in nodes:\n        if is_hamiltonian_path(G, [start_node]):\n            return \"Yes\"\n    return \"No\"\n\n# Input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4],\n    'Edges': [[0, 1], [0, 3], [0, 4], [0, 2], [1, 4], [2, 4], [2, 3], [3, 4]]\n}\n\n# Determine if there is a Hamiltonian path\nresult = has_hamiltonian_path(input_data['Nodes'], input_data['Edges'])\nprint(result)  # Output: Yes or No",
                "key_api": "import networkx as nx",
                "key_experience": "Utilization of recursion for backtracking to find Hamiltonian paths is efficient and helps ensure every potential path is explored. Using NetworkX provides ready-made structures for graph representation and functions for edge checking, simplifying the implementation."
            },
            {
                "question": "Determine whether or not there is a Hamiltonian path in an undirected graph. In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. Given a graph, you need to output Yes or No, indicating whether there is a Hamiltonian path in the graph. Q: The nodes are numbered from 0 to 20, and the edges are: (0, 6) (0, 5) (0, 19) (0, 14) (0, 17) (0, 12) (0, 15) (0, 20) (0, 3) (0, 9) (0, 2) (0, 11) (0, 1) (1, 17) (1, 15) (1, 20) (1, 12) (1, 6) (1, 4) (1, 16) (1, 9) (1, 18) (1, 8) (2, 6) (2, 15) (2, 17) (2, 19) (2, 4) (2, 9) (2, 16) (2, 20) (2, 11) (2, 18) (2, 14) (2, 3) (3, 9) (3, 13) (3, 16) (3, 20) (3, 19) (3, 11) (3, 7) (3, 6) (3, 15) (3, 4) (3, 8) (3, 12) (4, 12) (4, 5) (4, 13) (4, 20) (4, 19) (4, 15) (4, 18) (4, 17) (4, 14) (4, 8) (5, 12) (5, 9) (5, 14) (5, 7) (5, 18) (5, 10) (5, 11) (5, 17) (5, 19) (5, 8) (5, 16) (6, 18) (6, 11) (6, 9) (6, 14) (6, 20) (6, 7) (6, 12) (6, 16) (6, 15) (6, 19) (6, 10) (6, 17) (6, 8) (7, 17) (7, 19) (7, 10) (7, 16) (7, 18) (7, 8) (7, 11) (7, 9) (7, 15) (7, 14) (8, 19) (8, 13) (8, 17) (8, 10) (8, 20) (8, 15) (9, 13) (9, 12) (9, 20) (9, 18) (9, 17) (9, 11) (9, 16) (9, 10) (10, 19) (10, 18) (10, 20) (10, 12) (10, 11) (10, 14) (10, 13) (10, 17) (11, 14) (11, 12) (11, 17) (11, 15) (12, 19) (12, 18) (12, 14) (12, 13) (12, 20) (12, 17) (13, 20) (13, 19) (13, 16) (13, 17) (13, 14) (14, 18) (14, 19) (14, 15) (15, 18) (15, 19) (15, 20) (16, 20) (16, 18) (17, 18) (17, 19) (18, 20) (18, 19). Is there a Hamiltonian path in this graph?",
                "code": "import networkx as nx\n\ndef is_hamiltonian_path(graph):\n    # Helper function to perform backtracking\n    def backtrack(path):\n        # If the path includes all nodes, we found a Hamiltonian path\n        if len(path) == len(graph.nodes):\n            return True\n        \n        # Get the last node in the current path\n        last_node = path[-1]\n        \n        # Explore neighbors of the last node\n        for neighbor in graph.neighbors(last_node):\n            if neighbor not in path:  # Ensure we don't revisit nodes\n                path.append(neighbor)\n                if backtrack(path):\n                    return True\n                path.pop()  # Backtrack\n        \n        return False\n\n    # Try starting from each node\n    for start_node in graph.nodes:\n        if backtrack([start_node]):\n            return \"Yes\"\n    \n    return \"No\"\n\n# Input data\ninput_data = {\n    'Nodes': '0 to 20',\n    'Edges': [\n        '[0, 6]', '[0, 5]', '[0, 19]', '[0, 14]', '[0, 17]', '[0, 12]', \n        '[0, 15]', '[0, 20]', '[0, 3]', '[0, 9]', '[0, 2]', '[0, 11]', \n        '[0, 1]', '[1, 17]', '[1, 15]', '[1, 20]', '[1, 12]', '[1, 6]', \n        '[1, 4]', '[1, 16]', '[1, 9]', '[1, 18]', '[1, 8]', '[2, 6]', \n        '[2, 15]', '[2, 17]', '[2, 19]', '[2, 4]', '[2, 9]', '[2, 16]', \n        '[2, 20]', '[2, 11]', '[2, 18]', '[2, 14]', '[2, 3]', '[3, 9]', \n        '[3, 13]', '[3, 16]', '[3, 20]', '[3, 19]', '[3, 11]', '[3, 7]', \n        '[3, 6]', '[3, 15]', '[3, 4]', '[3, 8]', '[3, 12]', '[4, 12]', \n        '[4, 5]', '[4, 13]', '[4, 20]', '[4, 19]', '[4, 15]', '[4, 18]', \n        '[4, 17]', '[4, 14]', '[4, 8]', '[5, 12]', '[5, 9]', '[5, 14]', \n        '[5, 7]', '[5, 18]', '[5, 10]', '[5, 11]', '[5, 17]', '[5, 19]', \n        '[5, 8]', '[5, 16]', '[6, 18]', '[6, 11]', '[6, 9]', '[6, 14]', \n        '[6, 20]', '[6, 7]', '[6, 12]', '[6, 16]', '[6, 15]', '[6, 19]', \n        '[6, 10]', '[6, 17]', '[6, 8]', '[7, 17]', '[7, 19]', '[7, 10]', \n        '[7, 16]', '[7, 18]', '[7, 8]', '[7, 11]', '[7, 9]', '[7, 15]', \n        '[7, 14]', '[8, 19]', '[8, 13]', '[8, 17]', '[8, 10]', '[8, 20]', \n        '[8, 15]', '[9, 13]', '[9, 12]', '[9, 20]', '[9, 18]', '[9, 17]', \n        '[9, 11]', '[9, 16]', '[9, 10]', '[10, 19]', '[10, 18]', '[10, 20]', \n        '[10, 12]', '[10, 11]', '[10, 14]', '[10, 13]', '[10, 17]', \n        '[11, 14]', '[11, 12]', '[11, 17]', '[11, 15]', '[12, 19]', \n        '[12, 18]', '[12, 14]', '[12, 13]', '[12, 20]', '[12, 17]', \n        '[13, 20]', '[13, 19]', '[13, 16]', '[13, 17]', '[13, 14]', \n        '[14, 18]', '[14, 19]', '[14, 15]', '[15, 18]', '[15, 19]', \n        '[15, 20]', '[16, 20]', '[16, 18]', '[17, 18]', '[17, 19]', \n        '[18, 20]', '[18, 19]'\n    ]\n}\n\n# Create the graph\nG = nx.Graph()\nG.add_edges_from([eval(edge) for edge in input_data['Edges']])\n\n# Check for Hamiltonian path\nresult = is_hamiltonian_path(G)\nprint(result)",
                "key_api": "networkx.Graph",
                "key_experience": "The implementation of algorithms like backtracking for Hamiltonian path detection exemplifies good recursive programming practices. Incorporating checks to prevent revisiting nodes ensures efficiency. This demonstrates a sound understanding of graph theory concepts and their application using NetworkX, aligning well with efficiency and clarity."
            }
        ]
    },
    {
        "id": 10,
        "problem": "Find the shortest path between node 0 and node 15 in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Key Experiences in Solving Shortest Path Problems in Graphs\n\nIn these coding tasks, the primary objective was to find the shortest path between two nodes in both directed and undirected graphs using Dijkstra's algorithm. Here are the most important practices, key insights, and useful APIs drawn from completing these tasks:\n\n#### Key Practices:\n1. **Graph Representation**:\n   - **Task 1**: Utilized `nx.DiGraph()` to create a directed graph.\n   - **Task 2**: Utilized `nx.Graph()` to create an undirected graph.\n   - **Insight**: It's crucial to choose the correct graph type (directed or undirected) for accurate shortest path computations, as misrepresentation can lead to incorrect results.\n\n2. **Adding Edges with Weights**:\n   - Both tasks involved adding edges to the graph with their respective weights using the `add_edge()` method.\n   - **Insight**: Ensuring edges are correctly added with weights is essential for Dijkstra's algorithm to function accurately. Omitting or misconfiguring edge weights will result in wrong path lengths.\n\n3. **Algorithm Utilization**:\n   - Employed Dijkstra's algorithm through NetworkX's `nx.dijkstra_path` and `nx.dijkstra_path_length` functions.\n   - **Insight**: Leveraging built-in algorithms from libraries like NetworkX simplifies the process and ensures optimized pathfinding.\n\n#### Key Insights:\n1. **Efficiency in Shortest Path Calculation**:\n   - Dijkstra's algorithm is efficient and well-suited for finding the shortest path in graphs with non-negative weights.\n   - Using pre-built functions from NetworkX (`nx.dijkstra_path`, `nx.dijkstra_path_length`) significantly reduces complexity and improves code readability.\n\n2. **Graph Initialization and Edge Addition**:\n   - Proper initialization of the graph and careful addition of edges and weights lays the foundation for accurate computation.\n   - **Insight**: Always double-check edge definitions, especially when dealing with a large number of nodes and edges, to avoid inconsistent graph states.\n\n3. **Handling Different Graph Types**:\n   - Understanding the differences between directed and undirected graphs and choosing the right type is crucial for correct algorithm application.\n   - **Insight**: Incorrect graph types will lead to incorrect interpretations of paths and weights, emphasizing the need for clarity in graph requirements from the problem statement.\n\n#### Useful APIs:\n1. **NetworkX**:\n   - **Graph Creation**:\n     - `nx.Graph()`: For creating undirected graphs.\n     - `nx.DiGraph()`: For creating directed graphs.\n   - **Edge Addition**:\n     - `add_edge(node1, node2, weight=value)`: Adds an edge between node1 and node2 with a specified weight.\n   - **Shortest Path Algorithms**:\n     - `nx.dijkstra_path(graph, source, target)`: Finds the shortest path between the source and target nodes using Dijkstra's algorithm.\n     - `nx.dijkstra_path_length(graph, source, target)`: Computes the total weight of the shortest path found by Dijkstra's algorithm.\n\n#### Conclusion\nUsing NetworkX for graph handling and Dijkstra's algorithm for shortest path computation is both effective and efficient. Key practices include selecting the correct graph type, accurately adding edges with weights, and utilizing built-in functions for pathfinding. The insights emphasize the importance of correct graph initialization and the benefits of leveraging specialized algorithms from robust libraries such as NetworkX.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 19, and the edges are: (0,13,6) (0,4,1) (0,3,9) (0,19,7) (0,7,10) (0,16,4) (1,4,3) (1,15,4) (2,16,1) (2,8,10) (2,14,6) (2,17,8) (3,19,6) (3,4,2) (3,16,5) (3,9,2) (4,6,8) (4,13,10) (4,17,10) (4,16,2) (4,15,4) (4,5,6) (4,12,9) (5,6,7) (5,7,9) (5,18,5) (5,17,1) (5,10,2) (6,15,4) (6,14,1) (6,10,3) (6,8,4) (6,13,4) (6,11,9) (7,10,8) (7,11,7) (8,10,6) (9,16,6) (9,13,1) (9,11,7) (9,19,3) (10,15,3) (10,13,2) (11,17,1) (12,15,4) (13,14,10) (14,18,4) (15,17,5) (16,17,8). Give the weight of the shortest path from node 0 to node 15.",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nedges = [\n    {'i': 0, 'j': 13, 'k': 6}, {'i': 0, 'j': 4, 'k': 1}, {'i': 0, 'j': 3, 'k': 9},\n    {'i': 0, 'j': 19, 'k': 7}, {'i': 0, 'j': 7, 'k': 10}, {'i': 0, 'j': 16, 'k': 4},\n    {'i': 1, 'j': 4, 'k': 3}, {'i': 1, 'j': 15, 'k': 4}, {'i': 2, 'j': 16, 'k': 1},\n    {'i': 2, 'j': 8, 'k': 10}, {'i': 2, 'j': 14, 'k': 6}, {'i': 2, 'j': 17, 'k': 8},\n    {'i': 3, 'j': 19, 'k': 6}, {'i': 3, 'j': 4, 'k': 2}, {'i': 3, 'j': 16, 'k': 5},\n    {'i': 3, 'j': 9, 'k': 2}, {'i': 4, 'j': 6, 'k': 8}, {'i': 4, 'j': 13, 'k': 10},\n    {'i': 4, 'j': 17, 'k': 10}, {'i': 4, 'j': 16, 'k': 2}, {'i': 4, 'j': 15, 'k': 4},\n    {'i': 4, 'j': 5, 'k': 6}, {'i': 4, 'j': 12, 'k': 9}, {'i': 5, 'j': 6, 'k': 7},\n    {'i': 5, 'j': 7, 'k': 9}, {'i': 5, 'j': 18, 'k': 5}, {'i': 5, 'j': 17, 'k': 1},\n    {'i': 5, 'j': 10, 'k': 2}, {'i': 6, 'j': 15, 'k': 4}, {'i': 6, 'j': 14, 'k': 1},\n    {'i': 6, 'j': 10, 'k': 3}, {'i': 6, 'j': 8, 'k': 4}, {'i': 6, 'j': 13, 'k': 4},\n    {'i': 6, 'j': 11, 'k': 9}, {'i': 7, 'j': 10, 'k': 8}, {'i': 7, 'j': 11, 'k': 7},\n    {'i': 8, 'j': 10, 'k': 6}, {'i': 9, 'j': 16, 'k': 6}, {'i': 9, 'j': 13, 'k': 1},\n    {'i': 9, 'j': 11, 'k': 7}, {'i': 9, 'j': 19, 'k': 3}, {'i': 10, 'j': 15, 'k': 3},\n    {'i': 10, 'j': 13, 'k': 2}, {'i': 11, 'j': 17, 'k': 1}, {'i': 12, 'j': 15, 'k': 4},\n    {'i': 13, 'j': 14, 'k': 10}, {'i': 14, 'j': 18, 'k': 4}, {'i': 15, 'j': 17, 'k': 5},\n    {'i': 16, 'j': 17, 'k': 8}\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph with weights\nfor edge in edges:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Find the shortest path from node 0 to node 15\nshortest_path = nx.dijkstra_path(G, source=0, target=15)\nshortest_path_length = nx.dijkstra_path_length(G, source=0, target=15)\n\n# Output the weight of the shortest path\nprint(\"Shortest path from node 0 to node 15:\", shortest_path)\nprint(\"Weight of the shortest path:\", shortest_path_length)",
                "key_api": "networkx",
                "key_experience": "Utilizing Dijkstra's algorithm for finding the shortest path in weighted directed graphs. Ensure to create graphs using appropriate methods (e.g., DiGraph for directed graphs). Adding edges with weights is crucial for calculating accurate path lengths."
            },
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0,15,10) (0,3,2) (0,2,2) (0,10,1) (0,13,5) (0,9,5) (1,5,10) (1,4,4) (1,9,2) (1,7,2) (1,14,9) (1,3,1) (1,12,4) (1,10,7) (2,3,6) (2,15,2) (2,7,1) (2,4,4) (2,10,7) (3,11,10) (3,14,8) (3,12,4) (3,10,3) (3,4,7) (4,11,4) (4,6,2) (4,5,4) (4,15,3) (4,12,6) (5,13,2) (5,7,3) (5,10,4) (5,12,7) (5,8,3) (6,15,10) (6,10,6) (6,9,6) (6,13,2) (7,9,5) (7,13,5) (7,11,3) (7,12,2) (8,12,6) (8,13,4) (8,14,3) (9,13,3) (9,11,8) (9,12,2) (9,10,10) (9,14,2) (10,13,6) (10,11,7) (11,15,10) (11,13,6) (11,14,4) (12,13,2) (12,14,6) (12,15,5) (13,15,9). Give the weight of the shortest path from node 12 to node 2.",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    'Edges': [\n        {'i': 0, 'j': 15, 'k': 10}, {'i': 0, 'j': 3, 'k': 2}, {'i': 0, 'j': 2, 'k': 2},\n        {'i': 0, 'j': 10, 'k': 1}, {'i': 0, 'j': 13, 'k': 5}, {'i': 0, 'j': 9, 'k': 5},\n        {'i': 1, 'j': 5, 'k': 10}, {'i': 1, 'j': 4, 'k': 4}, {'i': 1, 'j': 9, 'k': 2},\n        {'i': 1, 'j': 7, 'k': 2}, {'i': 1, 'j': 14, 'k': 9}, {'i': 1, 'j': 3, 'k': 1},\n        {'i': 1, 'j': 12, 'k': 4}, {'i': 1, 'j': 10, 'k': 7}, {'i': 2, 'j': 3, 'k': 6},\n        {'i': 2, 'j': 15, 'k': 2}, {'i': 2, 'j': 7, 'k': 1}, {'i': 2, 'j': 4, 'k': 4},\n        {'i': 2, 'j': 10, 'k': 7}, {'i': 3, 'j': 11, 'k': 10}, {'i': 3, 'j': 14, 'k': 8},\n        {'i': 3, 'j': 12, 'k': 4}, {'i': 3, 'j': 10, 'k': 3}, {'i': 3, 'j': 4, 'k': 7},\n        {'i': 4, 'j': 11, 'k': 4}, {'i': 4, 'j': 6, 'k': 2}, {'i': 4, 'j': 5, 'k': 4},\n        {'i': 4, 'j': 15, 'k': 3}, {'i': 4, 'j': 12, 'k': 6}, {'i': 5, 'j': 13, 'k': 2},\n        {'i': 5, 'j': 7, 'k': 3}, {'i': 5, 'j': 10, 'k': 4}, {'i': 5, 'j': 12, 'k': 7},\n        {'i': 5, 'j': 8, 'k': 3}, {'i': 6, 'j': 15, 'k': 10}, {'i': 6, 'j': 10, 'k': 6},\n        {'i': 6, 'j': 9, 'k': 6}, {'i': 6, 'j': 13, 'k': 2}, {'i': 7, 'j': 9, 'k': 5},\n        {'i': 7, 'j': 13, 'k': 5}, {'i': 7, 'j': 11, 'k': 3}, {'i': 7, 'j': 12, 'k': 2},\n        {'i': 8, 'j': 12, 'k': 6}, {'i': 8, 'j': 13, 'k': 4}, {'i': 8, 'j': 14, 'k': 3},\n        {'i': 9, 'j': 13, 'k': 3}, {'i': 9, 'j': 11, 'k': 8}, {'i': 9, 'j': 12, 'k': 2},\n        {'i': 9, 'j': 10, 'k': 10}, {'i': 9, 'j': 14, 'k': 2}, {'i': 10, 'j': 13, 'k': 6},\n        {'i': 10, 'j': 11, 'k': 7}, {'i': 11, 'j': 15, 'k': 10}, {'i': 11, 'j': 13, 'k': 6},\n        {'i': 11, 'j': 14, 'k': 4}, {'i': 12, 'j': 13, 'k': 2}, {'i': 12, 'j': 14, 'k': 6},\n        {'i': 12, 'j': 15, 'k': 5}, {'i': 13, 'j': 15, 'k': 9}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph with weights\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Define the start and end nodes\nstart_node = 12\nend_node = 2\n\n# Find the shortest path using Dijkstra's algorithm\nshortest_path = nx.dijkstra_path(G, source=start_node, target=end_node)\nshortest_path_length = nx.dijkstra_path_length(G, source=start_node, target=end_node)\n\n# Output the weight of the shortest path\nprint(f\"The shortest path from node {start_node} to node {end_node} is: {shortest_path}\")\nprint(f\"The weight of the shortest path is: {shortest_path_length}\")",
                "key_api": "networkx",
                "key_experience": "Utilized the Dijkstra's algorithm through the 'nx.dijkstra_path' and 'nx.dijkstra_path_length' functions from the NetworkX library for efficient shortest path calculations in an undirected graph."
            }
        ]
    },
    {
        "id": 11,
        "problem": "Find the shortest path between node 0 and node 15 in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Coding Task Experience: Finding the Shortest Path in an Undirected Graph\n\n#### Task Objective\nThe task was to find the shortest path between two nodes in an undirected graph with weighted edges, provided nodes and given edges. Specifically, the goal was to determine the weight of the shortest path from node 0 to node 15.\n\n#### Key APIs Used\n- **NetworkX**: A powerful library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks.\n  - `nx.Graph()`: To create an undirected graph.\n  - `G.add_edge()`: To add edges between nodes with associated weights.\n  - `nx.shortest_path()`: To find the shortest path between two nodes.\n  - `networkx.exception.NetworkXNoPath`: To handle cases where no path exists between nodes.\n\n#### Key Insights and Practices\n1. **Graph Initialization and Edge Addition**:\n   - Start by initializing a graph object using `nx.Graph()`.\n   - Adding edges to the graph with weights is straightforward using the `add_edge` method, which accepts the two nodes to connect and the weight of their edge.\n\n2. **Finding Shortest Path**:\n   - Utilize `nx.shortest_path()` to find the shortest path based on the weights of the edges.\n   - The method automatically handles the graph traversal and weight calculations internally, making it highly efficient for such tasks.\n\n3. **Weight Calculation**:\n   - Once the shortest path is found, calculate the weight of this path by summing up the weights of the individual edges along the path.\n   - This requires iterating through each consecutive pair of nodes and retrieving the edge weight.\n\n4. **Exception Handling**:\n   - It is crucial to handle cases where no path exists between the specified nodes using `NetworkXNoPath`. This ensures robustness and meaningful error messages or alternative actions when no path is available.\n\n5. **Output Formatting**:\n   - Present the shortest path and its weight clearly to ensure that the output is easily understandable.\n\n#### Best Practices Highlighted\n- **Utilization of Libraries**: Leveraged the capabilities of the NetworkX library, which provides optimized algorithms for common graph operations.\n- **Efficiency in Path Discovery**: The use of NetworkX's `shortest_path` ensures efficient and correct computation of shortest paths, which is essential for handling larger graphs.\n- **Ease of Manipulation**: NetworkX simplifies complex graph operations, allowing more focus on problem-solving rather than implementation details.\n- **Preparation for Exceptions**: Anticipating and handling exceptional scenarios like non-existent paths enhances code robustness and reliability.\n\n### Conclusion\nThe experience of solving the shortest path problem in an undirected graph underscored the importance of leveraging specialized libraries like NetworkX. This approach maximized efficiency, clarity, and reduced complexity in implementation. Key takeaways include the significance of handling edge cases, efficiently processing paths, and leveraging built-in functionalities for common graph operations.",
        "rag_data": {
            "Section_id": "Find Shortest Path",
            "Path": "algorithms.plot_shortest_path",
            "Description": [
                "Finding the shortest path between 2 nodes of a given graph\nusing shortest_path function.\n"
            ],
            "Note": "\nNote\nGo to the end\nto download the full example code\n",
            "Example": [
                "import networkx as nx\nimport matplotlib.pyplot as plt\n\n# Create a graph with nodes and edges\nG = nx.Graph()\nG.add_nodes_from([\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"])\nG.add_edge(\"A\", \"B\", weight=4)\nG.add_edge(\"A\", \"H\", weight=8)\nG.add_edge(\"B\", \"C\", weight=8)\nG.add_edge(\"B\", \"H\", weight=11)\nG.add_edge(\"C\", \"D\", weight=7)\nG.add_edge(\"C\", \"F\", weight=4)\nG.add_edge(\"C\", \"I\", weight=2)\nG.add_edge(\"D\", \"E\", weight=9)\nG.add_edge(\"D\", \"F\", weight=14)\nG.add_edge(\"E\", \"F\", weight=10)\nG.add_edge(\"F\", \"G\", weight=2)\nG.add_edge(\"G\", \"H\", weight=1)\nG.add_edge(\"G\", \"I\", weight=6)\nG.add_edge(\"H\", \"I\", weight=7)\n\n# Find the shortest path from node A to node E\npath = nx.shortest_path(G, \"A\", \"E\", weight=\"weight\")\nprint(path)\n\n# Create a list of edges in the shortest path\npath_edges = list(zip(path, path[1:]))\n\n# Create a list of all edges, and assign colors based on whether they are in the shortest path or not\nedge_colors = [\n    \"red\" if edge in path_edges or tuple(reversed(edge)) in path_edges else \"black\"\n    for edge in G.edges()\n]\n\n# Visualize the graph\npos = nx.spring_layout(G)\nnx.draw_networkx_nodes(G, pos)\nnx.draw_networkx_edges(G, pos, edge_color=edge_colors)\nnx.draw_networkx_labels(G, pos)\nnx.draw_networkx_edge_labels(\n    G, pos, edge_labels={(u, v): d[\"weight\"] for u, v, d in G.edges(data=True)}\n)\n\nplt.show()\n"
            ],
            "Example_output": [
                "![https://networkx.org/documentation/stable/_images/sphx_glr_plot_shortest_path_001.png](https://networkx.org/documentation/stable/_images/sphx_glr_plot_shortest_path_001.png)\n['A', 'H', 'G', 'F', 'E']\n\n"
            ]
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 19, and the edges are: (0,13,6) (0,4,1) (0,3,9) (0,19,7) (0,7,10) (0,16,4) (1,4,3) (1,15,4) (2,16,1) (2,8,10) (2,14,6) (2,17,8) (3,19,6) (3,4,2) (3,16,5) (3,9,2) (4,6,8) (4,13,10) (4,17,10) (4,16,2) (4,15,4) (4,5,6) (4,12,9) (5,6,7) (5,7,9) (5,18,5) (5,17,1) (5,10,2) (6,15,4) (6,14,1) (6,10,3) (6,8,4) (6,13,4) (6,11,9) (7,10,8) (7,11,7) (8,10,6) (9,16,6) (9,13,1) (9,11,7) (9,19,3) (10,15,3) (10,13,2) (11,17,1) (12,15,4) (13,14,10) (14,18,4) (15,17,5) (16,17,8). Give the weight of the shortest path from node 0 to node 15.",
                "code": "import networkx as nx\n\n# Create a graph\nG = nx.Graph()\n\n# Add edges with weights\nedges = [\n    (0, 13, 6), (0, 4, 1), (0, 3, 9), (0, 19, 7), (0, 7, 10), (0, 16, 4),\n    (1, 4, 3), (1, 15, 4), (2, 16, 1), (2, 8, 10), (2, 14, 6), (2, 17, 8),\n    (3, 19, 6), (3, 4, 2), (3, 16, 5), (3, 9, 2), (4, 6, 8), (4, 13, 10),\n    (4, 17, 10), (4, 16, 2), (4, 15, 4), (4, 5, 6), (4, 12, 9), (5, 6, 7),\n    (5, 7, 9), (5, 18, 5), (5, 17, 1), (5, 10, 2), (6, 15, 4), (6, 14, 1),\n    (6, 10, 3), (6, 8, 4), (6, 13, 4), (6, 11, 9), (7, 10, 8), (7, 11, 7),\n    (8, 10, 6), (9, 16, 6), (9, 13, 1), (9, 11, 7), (9, 19, 3), (10, 15, 3),\n    (10, 13, 2), (11, 17, 1), (12, 15, 4), (13, 14, 10), (14, 18, 4),\n    (15, 17, 5), (16, 17, 8)\n]\n\n# Adding edges to the graph\nfor i, j, k in edges:\n    G.add_edge(i, j, weight=k)\n\n# Find the shortest path from node 0 to node 15\nshortest_path = nx.shortest_path(G, source=0, target=15, weight='weight')\n# Calculate the total weight of the shortest path\npath_weight = sum(G[u][v]['weight'] for u, v in zip(shortest_path[:-1], shortest_path[1:]))\n\n# Output the result\nprint(f\"Shortest path from node 0 to node 15: {shortest_path}\")\nprint(f\"Weight of the shortest path: {path_weight}\")",
                "key_api": "networkx (nx)",
                "key_experience": "Utilize NetworkX for graph manipulation, particularly functions like `shortest_path` and `shortest_path_length` for finding paths. Always handle exceptions like `NetworkXNoPath` to manage cases without connectivity."
            }
        ]
    },
    {
        "id": 12,
        "problem": "Find the shortest path between node 0 and node 15 in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Key Experiences in Coding Tasks\n\nBoth coding tasks focused on solving the shortest path problem in undirected graphs using Python. Here are the key practices, insights, and useful APIs from these tasks:\n\n#### Key Practices:\n1. **Graph Definition and Initialization:**\n   - Efficiently defining graphs using edge lists with weights.\n   - Creating undirected graphs using NetworkX's `nx.Graph()` method.\n\n2. **Edge Addition:**\n   - Adding edges to the graph with corresponding weights using `G.add_edge()` method.\n\n3. **Shortest Path Calculation:**\n   - Implementing Dijkstra's algorithm to find the shortest path by utilizing the `nx.shortest_path_length()` method from NetworkX.\n   - Clearly defining start and end nodes for the pathfinding process.\n\n4. **Output Handling:**\n   - Ensuring clear output representation of the shortest path length to provide understandable results.\n\n#### Key Insights:\n1. **Library Utilization:**\n   - Leveraging well-documented libraries like NetworkX can significantly simplify complex graph problems.\n   - NetworkX is particularly useful for its comprehensive set of algorithms and easy-to-use interface.\n\n2. **Edge Weight Handling:**\n   - Accurate representation of edge weights is crucial for problems involving weighted shortest paths as in Dijkstra\u2019s algorithm.\n   - Consistency in the input format (tuples vs dictionaries) helps in maintaining code readability and preventing errors.\n\n3. **Graph Versatility:**\n   - Understanding the versatility of NetworkX to handle various types of graphs (e.g., directed vs. undirected, weighted vs. unweighted) is beneficial.\n   - Highlighting the impact of edge weights on the shortest path results clarifies the necessity of proper weight assignment.\n\n#### Useful APIs:\n- **NetworkX Library:**\n  - `nx.Graph()` for creating an undirected graph.\n  - `G.add_edge()` for adding edges with weights to the graph.\n  - `nx.shortest_path_length()` to calculate the shortest path length between specified nodes with weights considered.\n\n### Conclusion:\nIn summary, both tasks underscored the usefulness of the NetworkX library for handling graph problems efficiently. Key practices such as accurate graph definition, consistent edge addition, and leveraging built-in shortest path algorithms were highlighted. Understanding and applying these principles can greatly assist in solving similar graph-related coding tasks effectively.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0,15,10) (0,3,2) (0,2,2) (0,10,1) (0,13,5) (0,9,5) (1,5,10) (1,4,4) (1,9,2) (1,7,2) (1,14,9) (1,3,1) (1,12,4) (1,10,7) (2,3,6) (2,15,2) (2,7,1) (2,4,4) (2,10,7) (3,11,10) (3,14,8) (3,12,4) (3,10,3) (3,4,7) (4,11,4) (4,6,2) (4,5,4) (4,15,3) (4,12,6) (5,13,2) (5,7,3) (5,10,4) (5,12,7) (5,8,3) (6,15,10) (6,10,6) (6,9,6) (6,13,2) (7,9,5) (7,13,5) (7,11,3) (7,12,2) (8,12,6) (8,13,4) (8,14,3) (9,13,3) (9,11,8) (9,12,2) (9,10,10) (9,14,2) (10,13,6) (10,11,7) (11,15,10) (11,13,6) (11,14,4) (12,13,2) (12,14,6) (12,15,5) (13,15,9). Give the weight of the shortest path from node 12 to node 2.",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nedges = [\n    (0, 15, 10), (0, 3, 2), (0, 2, 2), (0, 10, 1), (0, 13, 5), (0, 9, 5),\n    (1, 5, 10), (1, 4, 4), (1, 9, 2), (1, 7, 2), (1, 14, 9), (1, 3, 1),\n    (1, 12, 4), (1, 10, 7), (2, 3, 6), (2, 15, 2), (2, 7, 1), (2, 4, 4),\n    (2, 10, 7), (3, 11, 10), (3, 14, 8), (3, 12, 4), (3, 10, 3), (3, 4, 7),\n    (4, 11, 4), (4, 6, 2), (4, 5, 4), (4, 15, 3), (4, 12, 6), (5, 13, 2),\n    (5, 7, 3), (5, 10, 4), (5, 12, 7), (5, 8, 3), (6, 15, 10), (6, 10, 6),\n    (6, 9, 6), (6, 13, 2), (7, 9, 5), (7, 13, 5), (7, 11, 3), (7, 12, 2),\n    (8, 12, 6), (8, 13, 4), (8, 14, 3), (9, 13, 3), (9, 11, 8), (9, 12, 2),\n    (9, 10, 10), (9, 14, 2), (10, 13, 6), (10, 11, 7), (11, 15, 10), (11, 13, 6),\n    (11, 14, 4), (12, 13, 2), (12, 14, 6), (12, 15, 5), (13, 15, 9)\n]\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor i, j, k in edges:\n    G.add_edge(i, j, weight=k)\n\n# Define the start and end nodes\nstart_node = 12\nend_node = 2\n\n# Find the shortest path using Dijkstra's algorithm\nshortest_path_length = nx.shortest_path_length(G, source=start_node, target=end_node, weight='weight')\n\n# Output the weight of the shortest path\nprint(f\"The weight of the shortest path from node {start_node} to node {end_node} is: {shortest_path_length}\")",
                "key_api": "networkx.shortest_path_length",
                "key_experience": "Utilizing well-documented libraries like NetworkX for graph problems, efficiently defining graphs using edge lists with weights, and clearly setting start and end nodes for pathfinding."
            },
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 19, and the edges are: (0,13,6) (0,4,1) (0,3,9) (0,19,7) (0,7,10) (0,16,4) (1,4,3) (1,15,4) (2,16,1) (2,8,10) (2,14,6) (2,17,8) (3,19,6) (3,4,2) (3,16,5) (3,9,2) (4,6,8) (4,13,10) (4,17,10) (4,16,2) (4,15,4) (4,5,6) (4,12,9) (5,6,7) (5,7,9) (5,18,5) (5,17,1) (5,10,2) (6,15,4) (6,14,1) (6,10,3) (6,8,4) (6,13,4) (6,11,9) (7,10,8) (7,11,7) (8,10,6) (9,16,6) (9,13,1) (9,11,7) (9,19,3) (10,15,3) (10,13,2) (11,17,1) (12,15,4) (13,14,10) (14,18,4) (15,17,5) (16,17,8). Give the weight of the shortest path from node 0 to node 15.",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nedges = [\n    {'i': 0, 'j': 13, 'k': 6}, {'i': 0, 'j': 4, 'k': 1}, {'i': 0, 'j': 3, 'k': 9},\n    {'i': 0, 'j': 19, 'k': 7}, {'i': 0, 'j': 7, 'k': 10}, {'i': 0, 'j': 16, 'k': 4},\n    {'i': 1, 'j': 4, 'k': 3}, {'i': 1, 'j': 15, 'k': 4}, {'i': 2, 'j': 16, 'k': 1},\n    {'i': 2, 'j': 8, 'k': 10}, {'i': 2, 'j': 14, 'k': 6}, {'i': 2, 'j': 17, 'k': 8},\n    {'i': 3, 'j': 19, 'k': 6}, {'i': 3, 'j': 4, 'k': 2}, {'i': 3, 'j': 16, 'k': 5},\n    {'i': 3, 'j': 9, 'k': 2}, {'i': 4, 'j': 6, 'k': 8}, {'i': 4, 'j': 13, 'k': 10},\n    {'i': 4, 'j': 17, 'k': 10}, {'i': 4, 'j': 16, 'k': 2}, {'i': 4, 'j': 15, 'k': 4},\n    {'i': 4, 'j': 5, 'k': 6}, {'i': 4, 'j': 12, 'k': 9}, {'i': 5, 'j': 6, 'k': 7},\n    {'i': 5, 'j': 7, 'k': 9}, {'i': 5, 'j': 18, 'k': 5}, {'i': 5, 'j': 17, 'k': 1},\n    {'i': 5, 'j': 10, 'k': 2}, {'i': 6, 'j': 15, 'k': 4}, {'i': 6, 'j': 14, 'k': 1},\n    {'i': 6, 'j': 10, 'k': 3}, {'i': 6, 'j': 8, 'k': 4}, {'i': 6, 'j': 13, 'k': 4},\n    {'i': 6, 'j': 11, 'k': 9}, {'i': 7, 'j': 10, 'k': 8}, {'i': 7, 'j': 11, 'k': 7},\n    {'i': 8, 'j': 10, 'k': 6}, {'i': 9, 'j': 16, 'k': 6}, {'i': 9, 'j': 13, 'k': 1},\n    {'i': 9, 'j': 11, 'k': 7}, {'i': 9, 'j': 19, 'k': 3}, {'i': 10, 'j': 15, 'k': 3},\n    {'i': 10, 'j': 13, 'k': 2}, {'i': 11, 'j': 17, 'k': 1}, {'i': 12, 'j': 15, 'k': 4},\n    {'i': 13, 'j': 14, 'k': 10}, {'i': 14, 'j': 18, 'k': 4}, {'i': 15, 'j': 17, 'k': 5},\n    {'i': 16, 'j': 17, 'k': 8}\n]\n\n# Create a weighted undirected graph\nG = nx.Graph()\n\n# Add edges to the graph with weights\nfor edge in edges:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Find the shortest path from node 0 to node 15\nshortest_path_length = nx.shortest_path_length(G, source=0, target=15, weight='weight')\n\n# Output the weight of the shortest path\nprint(f\"The weight of the shortest path from node 0 to node 15 is: {shortest_path_length}\")",
                "key_api": "networkx",
                "key_experience": "Utilized NetworkX library efficiently for graph creation and shortest path calculation. Followed best practices such as using weighted edges for Dijkstra's algorithm, handling exceptions for non-existing paths, and ensuring clear outputs for results."
            }
        ]
    },
    {
        "id": 13,
        "problem": "Find the shortest path between node 0 and node 15 in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Key Experiences from Multiple Coding Tasks\n\n#### Overview:\nBoth coding tasks involved finding the shortest path between two nodes in an undirected graph with weighted edges. They utilized Python's NetworkX library to efficiently construct, manage, and analyze the graph structure.\n\n#### Key Practices:\n\n1. **Structured Graph Definitions:**\n   - Define edges clearly with nodes and weights.\n   - Use lists of dictionaries to store edge information for easy parsing.\n   \n2. **Effective Use of NetworkX:**\n   - NetworkX was crucial for managing graph data and calculating shortest paths.\n   - Functions such as `add_edge()` were used for building the graph.\n   - Pathfinding methods like `dijkstra_path_length()` and `shortest_path_length()` were employed to find the shortest paths between nodes.\n\n3. **Algorithm Selection:**\n   - Dijkstra's algorithm was used to find the shortest path in a weighted graph, leveraging NetworkX's `dijkstra_path_length()` function.\n   \n4. **Commenting and Documentation:**\n   - Proper documentation through comments helped clarify the logic and flow of the code.\n   - Clear definitions of input data and purposes helped maintain readability and ease of debugging.\n   \n5. **Exception Handling:**\n   - Implemented to manage scenarios where no path exists between the nodes, promoting robust code execution.\n\n6. **Reusability and Modularity:**\n   - Structuring the code in a modular fashion allows for easy adjustments and reusable components.\n   \n#### Key Insights:\n\n1. **Graph Importance:**\n   - Detailed graph construction is paramount; correctness in defining nodes and edges directly impacts the accuracy of the shortest path results.\n   \n2. **Algorithm Efficiency:**\n   - Dijkstra's algorithm is efficient for finding the shortest path in graphs with non-negative weights.\n\n3. **Library Utilization:**\n   - NetworkX is a powerful tool for graph-related problems, providing a wide range of functionalities to facilitate graph creation and analysis.\n\n4. **Edge Weight Handling:**\n   - Correct handling of edge weights\u2014ensuring they are added to the graph accurately\u2014was crucial for precise pathfinding results.\n\n#### Useful APIs:\n\n1. **NetworkX Library:**\n   - `nx.Graph()`: To create an undirected graph.\n   - `add_edge(i, j, weight=k)`: To add edges with weights to the graph.\n   - `dijkstra_path_length(G, source, target)`: To find the shortest path using Dijkstra\u2019s algorithm.\n   - `shortest_path_length(G, source, target, weight='weight')`: To compute the shortest path length considering weights.\n   \n### Conclusion:\nThe tasks highlighted the importance of structured graph definitions and the effective use of the NetworkX library to solve graph-based problems. Key insights included the necessity of meticulous edge and weight handling and leveraging appropriate algorithms like Dijkstra\u2019s for optimal pathfinding. Proper documentation and modular coding practices further enhanced the maintainability and readability of the code.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 19, and the edges are: (0,13,6) (0,4,1) (0,3,9) (0,19,7) (0,7,10) (0,16,4) (1,4,3) (1,15,4) (2,16,1) (2,8,10) (2,14,6) (2,17,8) (3,19,6) (3,4,2) (3,16,5) (3,9,2) (4,6,8) (4,13,10) (4,17,10) (4,16,2) (4,15,4) (4,5,6) (4,12,9) (5,6,7) (5,7,9) (5,18,5) (5,17,1) (5,10,2) (6,15,4) (6,14,1) (6,10,3) (6,8,4) (6,13,4) (6,11,9) (7,10,8) (7,11,7) (8,10,6) (9,16,6) (9,13,1) (9,11,7) (9,19,3) (10,15,3) (10,13,2) (11,17,1) (12,15,4) (13,14,10) (14,18,4) (15,17,5) (16,17,8). Give the weight of the shortest path from node 0 to node 15.",
                "code": "import networkx as nx\n\n# Define the graph\nedges = [\n    {'i': 0, 'j': 13, 'k': 6}, {'i': 0, 'j': 4, 'k': 1}, {'i': 0, 'j': 3, 'k': 9},\n    {'i': 0, 'j': 19, 'k': 7}, {'i': 0, 'j': 7, 'k': 10}, {'i': 0, 'j': 16, 'k': 4},\n    {'i': 1, 'j': 4, 'k': 3}, {'i': 1, 'j': 15, 'k': 4}, {'i': 2, 'j': 16, 'k': 1},\n    {'i': 2, 'j': 8, 'k': 10}, {'i': 2, 'j': 14, 'k': 6}, {'i': 2, 'j': 17, 'k': 8},\n    {'i': 3, 'j': 19, 'k': 6}, {'i': 3, 'j': 4, 'k': 2}, {'i': 3, 'j': 16, 'k': 5},\n    {'i': 3, 'j': 9, 'k': 2}, {'i': 4, 'j': 6, 'k': 8}, {'i': 4, 'j': 13, 'k': 10},\n    {'i': 4, 'j': 17, 'k': 10}, {'i': 4, 'j': 16, 'k': 2}, {'i': 4, 'j': 15, 'k': 4},\n    {'i': 4, 'j': 5, 'k': 6}, {'i': 4, 'j': 12, 'k': 9}, {'i': 5, 'j': 6, 'k': 7},\n    {'i': 5, 'j': 7, 'k': 9}, {'i': 5, 'j': 18, 'k': 5}, {'i': 5, 'j': 17, 'k': 1},\n    {'i': 5, 'j': 10, 'k': 2}, {'i': 6, 'j': 15, 'k': 4}, {'i': 6, 'j': 14, 'k': 1},\n    {'i': 6, 'j': 10, 'k': 3}, {'i': 6, 'j': 8, 'k': 4}, {'i': 6, 'j': 13, 'k': 4},\n    {'i': 6, 'j': 11, 'k': 9}, {'i': 7, 'j': 10, 'k': 8}, {'i': 7, 'j': 11, 'k': 7},\n    {'i': 8, 'j': 10, 'k': 6}, {'i': 9, 'j': 16, 'k': 6}, {'i': 9, 'j': 13, 'k': 1},\n    {'i': 9, 'j': 11, 'k': 7}, {'i': 9, 'j': 19, 'k': 3}, {'i': 10, 'j': 15, 'k': 3},\n    {'i': 10, 'j': 13, 'k': 2}, {'i': 11, 'j': 17, 'k': 1}, {'i': 12, 'j': 15, 'k': 4},\n    {'i': 13, 'j': 14, 'k': 10}, {'i': 14, 'j': 18, 'k': 4}, {'i': 15, 'j': 17, 'k': 5},\n    {'i': 16, 'j': 17, 'k': 8}\n]\n\n# Create a weighted undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor edge in edges:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Find the shortest path from node 0 to node 15\nshortest_path_length = nx.dijkstra_path_length(G, source=0, target=15)\n\n# Output the weight of the shortest path\nprint(f\"The weight of the shortest path from node 0 to node 15 is: {shortest_path_length}\")",
                "key_api": "NetworkX (specifically, the `shortest_path_length` and `shortest_path` functions)",
                "key_experience": "Best practices included using well-structured graph definitions, clearly defining edge weights, and ensuring that appropriate algorithms like Dijkstra's were used to find the shortest path effectively."
            },
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0,15,10) (0,3,2) (0,2,2) (0,10,1) (0,13,5) (0,9,5) (1,5,10) (1,4,4) (1,9,2) (1,7,2) (1,14,9) (1,3,1) (1,12,4) (1,10,7) (2,3,6) (2,15,2) (2,7,1) (2,4,4) (2,10,7) (3,11,10) (3,14,8) (3,12,4) (3,10,3) (3,4,7) (4,11,4) (4,6,2) (4,5,4) (4,15,3) (4,12,6) (5,13,2) (5,7,3) (5,10,4) (5,12,7) (5,8,3) (6,15,10) (6,10,6) (6,9,6) (6,13,2) (7,9,5) (7,13,5) (7,11,3) (7,12,2) (8,12,6) (8,13,4) (8,14,3) (9,13,3) (9,11,8) (9,12,2) (9,10,10) (9,14,2) (10,13,6) (10,11,7) (11,15,10) (11,13,6) (11,14,4) (12,13,2) (12,14,6) (12,15,5) (13,15,9). Give the weight of the shortest path from node 12 to node 2.",
                "code": "import networkx as nx\n\n# Input data\ninput_data = {\n    'Graph': {\n        'Edges': [\n            {'i': 0, 'j': 15, 'k': 10}, {'i': 0, 'j': 3, 'k': 2}, {'i': 0, 'j': 2, 'k': 2},\n            {'i': 0, 'j': 10, 'k': 1}, {'i': 0, 'j': 13, 'k': 5}, {'i': 0, 'j': 9, 'k': 5},\n            {'i': 1, 'j': 5, 'k': 10}, {'i': 1, 'j': 4, 'k': 4}, {'i': 1, 'j': 9, 'k': 2},\n            {'i': 1, 'j': 7, 'k': 2}, {'i': 1, 'j': 14, 'k': 9}, {'i': 1, 'j': 3, 'k': 1},\n            {'i': 1, 'j': 12, 'k': 4}, {'i': 1, 'j': 10, 'k': 7}, {'i': 2, 'j': 3, 'k': 6},\n            {'i': 2, 'j': 15, 'k': 2}, {'i': 2, 'j': 7, 'k': 1}, {'i': 2, 'j': 4, 'k': 4},\n            {'i': 2, 'j': 10, 'k': 7}, {'i': 3, 'j': 11, 'k': 10}, {'i': 3, 'j': 14, 'k': 8},\n            {'i': 3, 'j': 12, 'k': 4}, {'i': 3, 'j': 10, 'k': 3}, {'i': 3, 'j': 4, 'k': 7},\n            {'i': 4, 'j': 11, 'k': 4}, {'i': 4, 'j': 6, 'k': 2}, {'i': 4, 'j': 5, 'k': 4},\n            {'i': 4, 'j': 15, 'k': 3}, {'i': 4, 'j': 12, 'k': 6}, {'i': 5, 'j': 13, 'k': 2},\n            {'i': 5, 'j': 7, 'k': 3}, {'i': 5, 'j': 10, 'k': 4}, {'i': 5, 'j': 12, 'k': 7},\n            {'i': 5, 'j': 8, 'k': 3}, {'i': 6, 'j': 15, 'k': 10}, {'i': 6, 'j': 10, 'k': 6},\n            {'i': 6, 'j': 9, 'k': 6}, {'i': 6, 'j': 13, 'k': 2}, {'i': 7, 'j': 9, 'k': 5},\n            {'i': 7, 'j': 13, 'k': 5}, {'i': 7, 'j': 11, 'k': 3}, {'i': 7, 'j': 12, 'k': 2},\n            {'i': 8, 'j': 12, 'k': 6}, {'i': 8, 'j': 13, 'k': 4}, {'i': 8, 'j': 14, 'k': 3},\n            {'i': 9, 'j': 13, 'k': 3}, {'i': 9, 'j': 11, 'k': 8}, {'i': 9, 'j': 12, 'k': 2},\n            {'i': 9, 'j': 10, 'k': 10}, {'i': 9, 'j': 14, 'k': 2}, {'i': 10, 'j': 13, 'k': 6},\n            {'i': 10, 'j': 11, 'k': 7}, {'i': 11, 'j': 15, 'k': 10}, {'i': 11, 'j': 13, 'k': 6},\n            {'i': 11, 'j': 14, 'k': 4}, {'i': 12, 'j': 13, 'k': 2}, {'i': 12, 'j': 14, 'k': 6},\n            {'i': 12, 'j': 15, 'k': 5}, {'i': 13, 'j': 15, 'k': 9}\n        ]\n    },\n    'Node_Pair': {\n        'Start': 12,\n        'End': 2\n    }\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor edge in input_data['Graph']['Edges']:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Find the shortest path weight from Start to End\nstart_node = input_data['Node_Pair']['Start']\nend_node = input_data['Node_Pair']['End']\n\n# Compute the shortest path length\nshortest_path_length = nx.shortest_path_length(G, source=start_node, target=end_node, weight='weight')\n\n# Output the weight of the shortest path\nprint(f\"The weight of the shortest path from node {start_node} to node {end_node} is: {shortest_path_length}\")",
                "key_api": "networkx",
                "key_experience": "Utilized the NetworkX library to effectively construct and analyze an undirected graph by leveraging 'shortest_path_length' and 'shortest_path' functions for finding optimal routes between nodes. Best practices included thorough commenting for clarity, proper handling of edge weights, and wrapping the pathfinding logic in exception handling to manage cases where no path exists."
            }
        ]
    },
    {
        "id": 14,
        "problem": "Find the shortest path between node 0 and node 15 in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "## Summary of Key Experiences\n\n### Most Important Practices\n\n1. **Graph Definition and Representation**:\n   - Both tasks involved defining graphs using edges and weights. A clear understanding of graph structures and how to represent them using edges was crucial.\n   - Efficiently utilizing lists of tuples or dictionaries to represent edges provided clarity and ease of graph construction.\n\n2. **Utilization of NetworkX Library**:\n   - The NetworkX library was used in both tasks for creating and manipulating graphs. This library simplifies complex operations like shortest path calculation through built-in methods.\n\n3. **Shortest Path Calculation**:\n   - Dijkstra's algorithm was consistently used to find the shortest path between nodes in an undirected graph. This method is well-suited for graphs with non-negative weights.\n   - Leveraging `shortest_path` and `shortest_path_length` methods facilitates rapid and accurate pathfinding while considering edge weights.\n\n4. **Code Organization and Maintenance**:\n   - Properly organizing the code by separating the graph definition, edge addition, and shortest path computation sections enhances readability and maintainability.\n   - Documenting the code and handling exceptions ensures robustness, especially when paths might not exist.\n\n### Key Insights\n\n1. **Edge Weight Management**:\n   - Correctly adding edges with weights to the graph is fundamental. Any errors in edge-weight management can lead to incorrect shortest path calculations.\n   - Using consistent data structures (like dictionaries or tuples) helps in properly managing and iterating over edges.\n\n2. **Algorithm Selection**:\n   - Choosing the right algorithm (Dijkstra\u2019s) was pivotal for these tasks. It\u2019s crucial to understand the algorithm\u2019s limitations and strengths, particularly its efficiency with non-negative weights.\n\n3. **Graph API Utilization**:\n   - NetworkX\u2019s functions like `add_edge`, `shortest_path`, and `shortest_path_length` streamline graph manipulations and path calculations, making it essential to be familiar with these APIs.\n\n### Useful APIs\n\n1. **NetworkX `add_edge`**:\n   - Usage: `G.add_edge(node1, node2, weight=weight_value)`\n   - Purpose: Adds an edge between two nodes with a specified weight.\n\n2. **NetworkX `shortest_path`**:\n   - Usage: `nx.shortest_path(G, source=start_node, target=end_node, weight='weight')`\n   - Purpose: Returns the list of nodes making up the shortest path from source to target.\n\n3. **NetworkX `shortest_path_length`**:\n   - Usage: `nx.shortest_path_length(G, source=start_node, target=end_node, weight='weight')`\n   - Purpose: Returns the total weight of the shortest path from source to target.\n\n4. **NetworkX `dijkstra_path_length`**:\n   - Usage: `nx.dijkstra_path_length(G, source=start_node, target=end_node)`\n   - Purpose: Specifically calculates the shortest path length using Dijkstra\u2019s algorithm.\n\nHaving a strong grasp of these practices and APIs ensures efficient and correct solutions to graph-related problems, particularly those involving shortest path calculations in undirected graphs.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 19, and the edges are: (0,13,6) (0,4,1) (0,3,9) (0,19,7) (0,7,10) (0,16,4) (1,4,3) (1,15,4) (2,16,1) (2,8,10) (2,14,6) (2,17,8) (3,19,6) (3,4,2) (3,16,5) (3,9,2) (4,6,8) (4,13,10) (4,17,10) (4,16,2) (4,15,4) (4,5,6) (4,12,9) (5,6,7) (5,7,9) (5,18,5) (5,17,1) (5,10,2) (6,15,4) (6,14,1) (6,10,3) (6,8,4) (6,13,4) (6,11,9) (7,10,8) (7,11,7) (8,10,6) (9,16,6) (9,13,1) (9,11,7) (9,19,3) (10,15,3) (10,13,2) (11,17,1) (12,15,4) (13,14,10) (14,18,4) (15,17,5) (16,17,8). Give the weight of the shortest path from node 0 to node 15.",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nedges = [\n    (0, 13, 6), (0, 4, 1), (0, 3, 9), (0, 19, 7), (0, 7, 10), (0, 16, 4),\n    (1, 4, 3), (1, 15, 4), (2, 16, 1), (2, 8, 10), (2, 14, 6), (2, 17, 8),\n    (3, 19, 6), (3, 4, 2), (3, 16, 5), (3, 9, 2), (4, 6, 8), (4, 13, 10),\n    (4, 17, 10), (4, 16, 2), (4, 15, 4), (4, 5, 6), (4, 12, 9), (5, 6, 7),\n    (5, 7, 9), (5, 18, 5), (5, 17, 1), (5, 10, 2), (6, 15, 4), (6, 14, 1),\n    (6, 10, 3), (6, 8, 4), (6, 13, 4), (6, 11, 9), (7, 10, 8), (7, 11, 7),\n    (8, 10, 6), (9, 16, 6), (9, 13, 1), (9, 11, 7), (9, 19, 3), (10, 15, 3),\n    (10, 13, 2), (11, 17, 1), (12, 15, 4), (13, 14, 10), (14, 18, 4),\n    (15, 17, 5), (16, 17, 8)\n]\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor i, j, k in edges:\n    G.add_edge(i, j, weight=k)\n\n# Define the start and end nodes\nstart_node = 0\nend_node = 15\n\n# Calculate the shortest path using Dijkstra's algorithm\nshortest_path = nx.shortest_path(G, source=start_node, target=end_node, weight='weight')\nshortest_path_length = nx.shortest_path_length(G, source=start_node, target=end_node, weight='weight')\n\n# Output the weight of the shortest path\nprint(f\"The shortest path from node {start_node} to node {end_node} is: {shortest_path}\")\nprint(f\"The weight of the shortest path is: {shortest_path_length}\")",
                "key_api": "networkx",
                "key_experience": "Utilize the 'shortest_path' and 'shortest_path_length' functions for effective pathfinding in graphs, ensuring that the graph is properly defined with edges and weights. Always handle exceptions to manage cases where paths do not exist and document the code efficiently for maintainability."
            },
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0,15,10) (0,3,2) (0,2,2) (0,10,1) (0,13,5) (0,9,5) (1,5,10) (1,4,4) (1,9,2) (1,7,2) (1,14,9) (1,3,1) (1,12,4) (1,10,7) (2,3,6) (2,15,2) (2,7,1) (2,4,4) (2,10,7) (3,11,10) (3,14,8) (3,12,4) (3,10,3) (3,4,7) (4,11,4) (4,6,2) (4,5,4) (4,15,3) (4,12,6) (5,13,2) (5,7,3) (5,10,4) (5,12,7) (5,8,3) (6,15,10) (6,10,6) (6,9,6) (6,13,2) (7,9,5) (7,13,5) (7,11,3) (7,12,2) (8,12,6) (8,13,4) (8,14,3) (9,13,3) (9,11,8) (9,12,2) (9,10,10) (9,14,2) (10,13,6) (10,11,7) (11,15,10) (11,13,6) (11,14,4) (12,13,2) (12,14,6) (12,15,5) (13,15,9). Give the weight of the shortest path from node 12 to node 2.",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\nedges = [\n    {'i': 0, 'j': 15, 'k': 10}, {'i': 0, 'j': 3, 'k': 2}, {'i': 0, 'j': 2, 'k': 2},\n    {'i': 0, 'j': 10, 'k': 1}, {'i': 0, 'j': 13, 'k': 5}, {'i': 0, 'j': 9, 'k': 5},\n    {'i': 1, 'j': 5, 'k': 10}, {'i': 1, 'j': 4, 'k': 4}, {'i': 1, 'j': 9, 'k': 2},\n    {'i': 1, 'j': 7, 'k': 2}, {'i': 1, 'j': 14, 'k': 9}, {'i': 1, 'j': 3, 'k': 1},\n    {'i': 1, 'j': 12, 'k': 4}, {'i': 1, 'j': 10, 'k': 7}, {'i': 2, 'j': 3, 'k': 6},\n    {'i': 2, 'j': 15, 'k': 2}, {'i': 2, 'j': 7, 'k': 1}, {'i': 2, 'j': 4, 'k': 4},\n    {'i': 2, 'j': 10, 'k': 7}, {'i': 3, 'j': 11, 'k': 10}, {'i': 3, 'j': 14, 'k': 8},\n    {'i': 3, 'j': 12, 'k': 4}, {'i': 3, 'j': 10, 'k': 3}, {'i': 3, 'j': 4, 'k': 7},\n    {'i': 4, 'j': 11, 'k': 4}, {'i': 4, 'j': 6, 'k': 2}, {'i': 4, 'j': 5, 'k': 4},\n    {'i': 4, 'j': 15, 'k': 3}, {'i': 4, 'j': 12, 'k': 6}, {'i': 5, 'j': 13, 'k': 2},\n    {'i': 5, 'j': 7, 'k': 3}, {'i': 5, 'j': 10, 'k': 4}, {'i': 5, 'j': 12, 'k': 7},\n    {'i': 5, 'j': 8, 'k': 3}, {'i': 6, 'j': 15, 'k': 10}, {'i': 6, 'j': 10, 'k': 6},\n    {'i': 6, 'j': 9, 'k': 6}, {'i': 6, 'j': 13, 'k': 2}, {'i': 7, 'j': 9, 'k': 5},\n    {'i': 7, 'j': 13, 'k': 5}, {'i': 7, 'j': 11, 'k': 3}, {'i': 7, 'j': 12, 'k': 2},\n    {'i': 8, 'j': 12, 'k': 6}, {'i': 8, 'j': 13, 'k': 4}, {'i': 8, 'j': 14, 'k': 3},\n    {'i': 9, 'j': 13, 'k': 3}, {'i': 9, 'j': 11, 'k': 8}, {'i': 9, 'j': 12, 'k': 2},\n    {'i': 9, 'j': 10, 'k': 10}, {'i': 9, 'j': 14, 'k': 2}, {'i': 10, 'j': 13, 'k': 6},\n    {'i': 10, 'j': 11, 'k': 7}, {'i': 11, 'j': 15, 'k': 10}, {'i': 11, 'j': 13, 'k': 6},\n    {'i': 11, 'j': 14, 'k': 4}, {'i': 12, 'j': 13, 'k': 2}, {'i': 12, 'j': 14, 'k': 6},\n    {'i': 12, 'j': 15, 'k': 5}, {'i': 13, 'j': 15, 'k': 9}\n]\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph with weights\nfor edge in edges:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Define the start and end nodes\nstart_node = 12\nend_node = 2\n\n# Find the shortest path using Dijkstra's algorithm\nshortest_path_length = nx.dijkstra_path_length(G, source=start_node, target=end_node)\n\n# Output the weight of the shortest path\nprint(f\"The weight of the shortest path from node {start_node} to node {end_node} is: {shortest_path_length}\")",
                "key_api": "networkx",
                "key_experience": "Utilized Dijkstra\u2019s algorithm for finding the shortest path in an undirected graph efficiently, demonstrating effective edge-weight management through `add_edge` method and calculation of path weight using `shortest_path_length`."
            }
        ]
    },
    {
        "id": 15,
        "problem": "Find the shortest path between node 0 and node 15 in the given undirected graph.",
        "graph_type": "undirected",
        "experience": "### Summary of Overall Experience in Solving Shortest Path Problems with Python\n\n#### Key Practices:\n1. **Graph Representation**: \n   - Utilized NetworkX to represent graph structures, which allows easy manipulation and analysis of the nodes and edges.\n2. **Pathfinding Algorithms**:\n   - Employed Dijkstra's algorithm and A* (A-star) algorithm for finding the shortest path.\n   - Dijkstra's algorithm is used effectively when edge weights need to be considered, while A* can be utilized for potentially optimized pathfinding with heuristic support.\n3. **Error Handling**:\n   - Implemented proper error handling to manage cases where no path exists between nodes. This makes the solution robust and prevents crashes.\n\n#### Key Insights:\n1. **Choosing the Right Algorithm**:\n   - **Dijkstra's Algorithm** is efficient for finding the shortest path in non-negative weighted graphs.\n   - **A* Algorithm** can be more efficient with the right heuristic function, reducing computation time by guiding the search direction.\n2. **Edge Attributes**:\n   - Ensuring edge weights are correctly defined and accessible through the graph's edge attributes is crucial for accurate pathfinding.\n3. **Handling Undirected Graphs**:\n   - Converting problem constraints into graph representations, such as using undirected edges correctly, ensures the problem constraints are respected.\n\n#### Useful APIs and Functions:\n1. **NetworkX Library**:\n   - `networkx.Graph()`: For creating an undirected graph.\n   - `networkx.DiGraph()`: For creating a directed graph.\n   - `add_weighted_edges_from(edges)`: Adds edges with weights to the graph.\n   - `astar_path(G, source, target, heuristic=heuristic, weight='weight')`: Finds the shortest path using the A* algorithm.\n   - `shortest_path(G, source, target, weight='weight')`: Alternative function for finding the shortest path.\n\n2. **Error Handling**:\n   - `networkx.NetworkXNoPath`: Exception handling for cases where no path exists between the nodes.\n\nBy following these practices and utilizing these insights and APIs, effective and efficient solutions to pathfinding problems in graphs can be developed. This approach ensures clarity in graph representation, efficiency in algorithm selection, and robustness in error handling.",
        "rag_data": {
            "Section ID": "astar_path",
            "Description": [
                "Returns a list of nodes in a shortest path between source and target\nusing the A* (\u201cA-star\u201d) algorithm.",
                "There may be more than one shortest path.  This returns only one."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX graph": "",
                    "source : node": "Starting node for path",
                    "target : node": "Ending node for path",
                    "heuristic : function": "A function to evaluate the estimate of the distance\nfrom the a node to the target.  The function takes\ntwo nodes arguments and must return a number.\nIf the heuristic is inadmissible (if it might\noverestimate the cost of reaching the goal from a node),\nthe result may not be a shortest path.\nThe algorithm does not support updating heuristic\nvalues for the same node due to caching the first\nheuristic calculation per node.",
                    "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge.",
                    "cutoff : float, optional": "If this is provided, the search will be bounded to this value. I.e. if\nthe evaluation function surpasses this value for a node n, the node will not\nbe expanded further and will be ignored. More formally, let h\u2019(n) be the\nheuristic function, and g(n) be the cost of reaching n from the source node. Then,\nif g(n) + h\u2019(n) > cutoff, the node will not be explored further.\nNote that if the heuristic is inadmissible, it is possible that paths\nare ignored even though they satisfy the cutoff."
                },
                "Raises:": {
                    "NetworkXNoPath": "If no path exists between source and target."
                }
            },
            "Rubrics": {
                "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path.",
                "Examples": "G=nx.path_graph(5)\nprint(nx.astar_path(G,0,4))\n# [0, 1, 2, 3, 4]\nG=nx.grid_graph(dim=[3,3])# nodes are two-tuples (x,y)\nnx.set_edge_attributes(G,{e:e[1][0]*2foreinG.edges()},\"cost\")\ndefdist(a,b):\n(x1,y1)=a\n(x2,y2)=b\nreturn((x1-x2)**2+(y1-y2)**2)**0.5\nprint(nx.astar_path(G,(0,0),(2,2),heuristic=dist,weight=\"cost\"))\n# [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)]"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 19, and the edges are: (0,13,6) (0,4,1) (0,3,9) (0,19,7) (0,7,10) (0,16,4) (1,4,3) (1,15,4) (2,16,1) (2,8,10) (2,14,6) (2,17,8) (3,19,6) (3,4,2) (3,16,5) (3,9,2) (4,6,8) (4,13,10) (4,17,10) (4,16,2) (4,15,4) (4,5,6) (4,12,9) (5,6,7) (5,7,9) (5,18,5) (5,17,1) (5,10,2) (6,15,4) (6,14,1) (6,10,3) (6,8,4) (6,13,4) (6,11,9) (7,10,8) (7,11,7) (8,10,6) (9,16,6) (9,13,1) (9,11,7) (9,19,3) (10,15,3) (10,13,2) (11,17,1) (12,15,4) (13,14,10) (14,18,4) (15,17,5) (16,17,8). Give the weight of the shortest path from node 0 to node 15.",
                "code": "import networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges based on the provided input\nedges = [\n    (0, 13, 6), (0, 4, 1), (0, 3, 9), (0, 19, 7), (0, 7, 10), (0, 16, 4),\n    (1, 4, 3), (1, 15, 4), (2, 16, 1), (2, 8, 10), (2, 14, 6), (2, 17, 8),\n    (3, 19, 6), (3, 4, 2), (3, 16, 5), (3, 9, 2), (4, 6, 8), (4, 13, 10),\n    (4, 17, 10), (4, 16, 2), (4, 15, 4), (4, 5, 6), (4, 12, 9), (5, 6, 7),\n    (5, 7, 9), (5, 18, 5), (5, 17, 1), (5, 10, 2), (6, 15, 4), (6, 14, 1),\n    (6, 10, 3), (6, 8, 4), (6, 13, 4), (6, 11, 9), (7, 10, 8), (7, 11, 7),\n    (8, 10, 6), (9, 16, 6), (9, 13, 1), (9, 11, 7), (9, 19, 3), (10, 15, 3),\n    (10, 13, 2), (11, 17, 1), (12, 15, 4), (13, 14, 10), (14, 18, 4), (15, 17, 5),\n    (16, 17, 8)\n]\n\n# Add edges to the graph with weights\nG.add_weighted_edges_from(edges)\n\n# Define the heuristic function for A* (using a simple zero heuristic)\ndef heuristic(u, v):\n    return 0  # This can be modified for a more complex heuristic if needed\n\n# Find the shortest path from node 0 to node 15\ntry:\n    shortest_path = nx.astar_path(G, source=0, target=15, heuristic=heuristic, weight='weight')\n    # Calculate the total weight of the shortest path\n    path_weight = sum(G[u][v]['weight'] for u, v in zip(shortest_path[:-1], shortest_path[1:]))\n    print(f\"Shortest path from node 0 to node 15: {shortest_path}\")\n    print(f\"Weight of the shortest path: {path_weight}\")\nexcept nx.NetworkXNoPath:\n    print(\"No path exists between node 0 and node 15.\")",
                "key_api": "networkx",
                "key_experience": "Utilizing Dijkstra's algorithm for finding the shortest path in a weighted graph. Ensure weights are appropriately defined and accessible through edge attributes. Implement error handling for cases with no available path, and consider using the A* algorithm for potentially optimized paths."
            },
            {
                "question": "Find the shortest path between two nodes in an undirected graph. In an undirected graph, (i,j,k) means that node i and node j are connected with an undirected edge with weight k. Given a graph and a pair of nodes, you need to output the shortest path between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0,15,10) (0,3,2) (0,2,2) (0,10,1) (0,13,5) (0,9,5) (1,5,10) (1,4,4) (1,9,2) (1,7,2) (1,14,9) (1,3,1) (1,12,4) (1,10,7) (2,3,6) (2,15,2) (2,7,1) (2,4,4) (2,10,7) (3,11,10) (3,14,8) (3,12,4) (3,10,3) (3,4,7) (4,11,4) (4,6,2) (4,5,4) (4,15,3) (4,12,6) (5,13,2) (5,7,3) (5,10,4) (5,12,7) (5,8,3) (6,15,10) (6,10,6) (6,9,6) (6,13,2) (7,9,5) (7,13,5) (7,11,3) (7,12,2) (8,12,6) (8,13,4) (8,14,3) (9,13,3) (9,11,8) (9,12,2) (9,10,10) (9,14,2) (10,13,6) (10,11,7) (11,15,10) (11,13,6) (11,14,4) (12,13,2) (12,14,6) (12,15,5) (13,15,9). Give the weight of the shortest path from node 12 to node 2.",
                "code": "import networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    'Edges': [\n        {'i': 0, 'j': 15, 'k': 10}, {'i': 0, 'j': 3, 'k': 2}, {'i': 0, 'j': 2, 'k': 2},\n        {'i': 0, 'j': 10, 'k': 1}, {'i': 0, 'j': 13, 'k': 5}, {'i': 0, 'j': 9, 'k': 5},\n        {'i': 1, 'j': 5, 'k': 10}, {'i': 1, 'j': 4, 'k': 4}, {'i': 1, 'j': 9, 'k': 2},\n        {'i': 1, 'j': 7, 'k': 2}, {'i': 1, 'j': 14, 'k': 9}, {'i': 1, 'j': 3, 'k': 1},\n        {'i': 1, 'j': 12, 'k': 4}, {'i': 1, 'j': 10, 'k': 7}, {'i': 2, 'j': 3, 'k': 6},\n        {'i': 2, 'j': 15, 'k': 2}, {'i': 2, 'j': 7, 'k': 1}, {'i': 2, 'j': 4, 'k': 4},\n        {'i': 2, 'j': 10, 'k': 7}, {'i': 3, 'j': 11, 'k': 10}, {'i': 3, 'j': 14, 'k': 8},\n        {'i': 3, 'j': 12, 'k': 4}, {'i': 3, 'j': 10, 'k': 3}, {'i': 3, 'j': 4, 'k': 7},\n        {'i': 4, 'j': 11, 'k': 4}, {'i': 4, 'j': 6, 'k': 2}, {'i': 4, 'j': 5, 'k': 4},\n        {'i': 4, 'j': 15, 'k': 3}, {'i': 4, 'j': 12, 'k': 6}, {'i': 5, 'j': 13, 'k': 2},\n        {'i': 5, 'j': 7, 'k': 3}, {'i': 5, 'j': 10, 'k': 4}, {'i': 5, 'j': 12, 'k': 7},\n        {'i': 5, 'j': 8, 'k': 3}, {'i': 6, 'j': 15, 'k': 10}, {'i': 6, 'j': 10, 'k': 6},\n        {'i': 6, 'j': 9, 'k': 6}, {'i': 6, 'j': 13, 'k': 2}, {'i': 7, 'j': 9, 'k': 5},\n        {'i': 7, 'j': 13, 'k': 5}, {'i': 7, 'j': 11, 'k': 3}, {'i': 7, 'j': 12, 'k': 2},\n        {'i': 8, 'j': 12, 'k': 6}, {'i': 8, 'j': 13, 'k': 4}, {'i': 8, 'j': 14, 'k': 3},\n        {'i': 9, 'j': 13, 'k': 3}, {'i': 9, 'j': 11, 'k': 8}, {'i': 9, 'j': 12, 'k': 2},\n        {'i': 9, 'j': 10, 'k': 10}, {'i': 9, 'j': 14, 'k': 2}, {'i': 10, 'j': 13, 'k': 6},\n        {'i': 10, 'j': 11, 'k': 7}, {'i': 11, 'j': 15, 'k': 10}, {'i': 11, 'j': 13, 'k': 6},\n        {'i': 11, 'j': 14, 'k': 4}, {'i': 12, 'j': 13, 'k': 2}, {'i': 12, 'j': 14, 'k': 6},\n        {'i': 12, 'j': 15, 'k': 5}, {'i': 13, 'j': 15, 'k': 9}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph with weights\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['i'], edge['j'], weight=edge['k'])\n\n# Define the start and end nodes\nstart_node = 12\nend_node = 2\n\n# Find the shortest path using A* algorithm\ntry:\n    shortest_path = nx.astar_path(G, start_node, end_node, weight='weight')\n    # Calculate the total weight of the shortest path\n    path_weight = sum(G[u][v]['weight'] for u, v in zip(shortest_path[:-1], shortest_path[1:]))\n    print(f\"Shortest path from {start_node} to {end_node}: {shortest_path} with total weight: {path_weight}\")\nexcept nx.NetworkXNoPath:\n    print(f\"No path exists between node {start_node} and node {end_node}.\")",
                "key_api": "networkx",
                "key_experience": "Utilizing the NetworkX library for graph manipulation and analysis, specifically using functions like shortest_path and astar_path for pathfinding, ensures efficient handling of graph structures. Additionally, proper exception handling ensures robustness in cases where paths may not exist."
            }
        ]
    },
    {
        "id": 16,
        "problem": "Determine if subgraph G' is present as an exact match within graph G.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience with Graph Isomorphism and Subgraph Matching Tasks\n\n#### **1. Key Practices:**\n- **Utilization of NetworkX Library:**\n  NetworkX is a powerful library in Python that provides comprehensive capabilities for handling complex graph-related tasks including creation, manipulation, analysis, and visualization.\n  \n- **Clear Code Structure and Reusability:**\n  The tasks emphasize defining directed graphs (`nx.DiGraph`), adding nodes and edges, and modularizing code via functions. This promotes code reusability and maintainability, which is critical for complex graph operations.\n\n- **Subgraph Isomorphism Checks:**\n  For checking the presence of subgraphs within larger graphs, the `DiGraphMatcher` class from the `networkx.algorithms.isomorphism` module is consistently utilized. This class handles the intricate process of matching nodes and edges efficiently.\n\n- **Comprehensive Graph Definitions:**\n  Before matching operations, it's essential to clearly define the nodes and edges of the main graph and subgraph. Clear data structures\u2014lists of nodes and edges\u2014were used to ensure correct graph representations.\n\n#### **2. Key Insights:**\n- **Graph Isomorphism Importance:**\n  Detecting if a subgraph is present within a larger graph is critical in various domains such as bioinformatics for analyzing molecular structures, social network analysis, and pattern recognition in large datasets.\n\n- **Directed Graphs Specifics:**\n  Directed graphs, where edges have a direction, require specific attention to ensure that the directionality is preserved during isomorphism checks. The diagonal distinction between source and destination nodes is essential.\n\n- **Subgraph vs. Graph Isomorphism:**\n  Understanding the difference between subgraph isomorphism (`subgraph_is_monomorphic`) and exact graph isomorphism (`is_isomorphic`) is crucial for the correct application of the isomorphism checks. The former is typically used in the tasks.\n\n- **API Utilization:**\n  NetworkX provides several useful APIs beyond isomorphism, like shortest path algorithms (`networkx.shortest_path`), network measure calculations (like clustering, connectivity metrics), which, while not directly highlighted in the tasks, are invaluable in broader graph analysis contexts.\n\n#### **3. Useful APIs:**\n- **DiGraph:**\n  - `nx.DiGraph()`: To create directed graphs.\n  - `add_nodes_from(iterable)`: To add multiple nodes.\n  - `add_edges_from(ebunch)`: To add multiple edges.\n\n- **Isomorphism Algorithms:**\n  - `networkx.algorithms.isomorphism.DiGraphMatcher`: For matching directed graphs and assessing subgraph isomorphism.\n  - `matcher.subgraph_is_monomorphic()`: To check if a subgraph is an exact match within the main graph.\n\n#### **4. Key Experiences and Best Practices:**\n- **Modular Code Design:**\n  Define functions and keep the code structured into logical blocks to facilitate readability and reuse.\n  \n- **Data Structure Clarity:**\n  Use well-defined lists of nodes and edges to clearly represent graph structures.\n\n- **Thorough Testing:**\n  Validate the graph isomorphism algorithms by testing on different graph and subgraph configurations to ensure correctness.\n\n- **Best Practices in Graph Representation:**\n  Always ensure accurate representation of graphs and subgraphs before performing isomorphism checks to avoid computational errors.\n\nIn summary, leveraging NetworkX effectively for graph and subgraph isomorphism tasks involves a clear understanding of graph theoretical concepts, precise representation of graphs, and methodical application of isomorphism algorithms to obtain accurate results.",
        "rag_data": {
            "Section ID": "DiGraphMatcher.subgraph_is_monomorphic",
            "Description": [
                "Returns True if a subgraph of G1 is monomorphic to G2."
            ],
            "Field List": {},
            "Rubrics": {}
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine if a smaller graph is present as an exact match within a larger graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph G and a subgraph G', you need to output Yes or No, indicating whether subgraph G' is present within the directed graph G. Q: The nodes of graph G are numbered from 0 to 12, and the edges are: (0->1) (0->6) (0->7) (0->3) (0->9) (1->8) (1->9) (1->3) (2->11) (4->9) (4->7) (5->11) (6->11) (6->9) (7->9) (8->9) (10->11). The nodes of subgraph G' are numbered from a to f, and the edges are: (a->d) (b->e) (c->f) (d->e) (e->f). Is subgraph G' present within graph G as a direct substructure?",
                "code": "import networkx as nx\n\n# Define the main graph G\nG = nx.DiGraph()\nnodes_G = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nedges_G = [(0, 1), (0, 6), (0, 7), (0, 3), (0, 9), \n            (1, 8), (1, 9), (1, 3), (2, 11), (4, 9), \n            (4, 7), (5, 11), (6, 11), (6, 9), (7, 9), \n            (8, 9), (10, 11)]\n\nG.add_nodes_from(nodes_G)\nG.add_edges_from(edges_G)\n\n# Define the subgraph G'\nG_prime = nx.DiGraph()\nnodes_G_prime = ['a', 'b', 'c', 'd', 'e', 'f']\nedges_G_prime = [('a', 'd'), ('b', 'e'), ('c', 'f'), \n                 ('d', 'e'), ('e', 'f')]\n\nG_prime.add_nodes_from(nodes_G_prime)\nG_prime.add_edges_from(edges_G_prime)\n\n# Check if G' is a subgraph of G\nmatcher = nx.algorithms.isomorphism.DiGraphMatcher(G, G_prime)\nis_subgraph = matcher.subgraph_is_monomorphic()\n\n# Output result\nif is_subgraph:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
                "key_api": "networkx.algorithms.isomorphism.DiGraphMatcher",
                "key_experience": "Utilize directed graph matchers for subgraph isomorphism checks and ensure to follow best practices by structuring the code clearly, defining reusable functions for graph creation and isomorphism checks."
            },
            {
                "question": "Determine if a smaller graph is present as an exact match within a larger graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph G and a subgraph G', you need to output Yes or No, indicating whether subgraph G' is present within the directed graph G. Q: The nodes of graph G are numbered from 0 to 14, and the edges are: (0->12) (0->7) (0->10) (0->6) (0->4) (0->3) (0->5) (0->9) (0->11) (0->8) (0->2) (1->11) (1->12) (1->8) (1->13) (1->6) (1->2) (1->14) (1->5) (1->10) (1->9) (2->8) (2->3) (2->9) (2->11) (2->5) (3->7) (3->4) (3->5) (3->9) (3->6) (4->12) (4->7) (4->10) (5->11) (5->6) (5->7) (5->12) (6->10) (6->7) (6->11) (7->8) (7->9) (7->12) (7->13) (7->11) (8->10) (8->13) (8->12) (9->11) (9->10) (9->12) (9->14) (11->14) (11->12) (11->13). The nodes of subgraph G' are numbered from a to j, and the edges are: (a->j) (b->e) (b->i) (b->f) (c->g) (d->f) (e->j) (e->f) (e->i) (f->h) (f->i) (g->h). Is subgraph G' present within graph G as a direct substructure?",
                "code": "import networkx as nx\n\n# Define the main directed graph G\nG = nx.DiGraph()\n\n# Add nodes to G\nG.add_nodes_from(range(15))  # Nodes from 0 to 14\n\n# Define edges for G\nedges_G = [\n    (0, 12), (0, 7), (0, 10), (0, 6), (0, 4), (0, 3), (0, 5), (0, 9),\n    (0, 11), (0, 8), (0, 2), (1, 11), (1, 12), (1, 8), (1, 13), (1, 6),\n    (1, 2), (1, 14), (1, 5), (1, 10), (1, 9), (2, 8), (2, 3), (2, 9),\n    (2, 11), (2, 5), (3, 7), (3, 4), (3, 5), (3, 9), (3, 6), (4, 12),\n    (4, 7), (4, 10), (5, 11), (5, 6), (5, 7), (5, 12), (6, 10), (6, 7),\n    (6, 11), (7, 8), (7, 9), (7, 12), (7, 13), (7, 11), (8, 10), (8, 13),\n    (8, 12), (9, 11), (9, 10), (9, 12), (9, 14), (11, 14), (11, 12), (11, 13)\n]\n\n# Add edges to G\nG.add_edges_from(edges_G)\n\n# Define the subgraph G'\nG_prime = nx.DiGraph()\n\n# Add nodes to G'\nG_prime.add_nodes_from(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n\n# Define edges for G'\nedges_G_prime = [\n    ('a', 'j'), ('b', 'e'), ('b', 'i'), ('b', 'f'), ('c', 'g'),\n    ('d', 'f'), ('e', 'j'), ('e', 'f'), ('e', 'i'), ('f', 'h'),\n    ('f', 'i'), ('g', 'h')\n]\n\n# Add edges to G'\nG_prime.add_edges_from(edges_G_prime)\n\n# Check if G' is a subgraph of G\nfrom networkx.algorithms.isomorphism import DiGraphMatcher\n\nmatcher = DiGraphMatcher(G, G_prime)\nis_subgraph = matcher.subgraph_is_monomorphic()\n\n# Output result\nresult = \"Yes\" if is_subgraph else \"No\"\nprint(result)",
                "key_api": "DiGraphMatcher",
                "key_experience": "Utilized NetworkX for efficient graph representation and isomorphism checks, employing clear function definitions for modular and maintainable code."
            }
        ]
    },
    {
        "id": 17,
        "problem": "Determine if subgraph G' is present as an exact match within graph G.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience with Graph Isomorphism and Subgraph Matching Tasks\n\n#### **1. Key Practices:**\n- **Utilization of NetworkX Library:**\n  NetworkX is a powerful library in Python that provides comprehensive capabilities for handling complex graph-related tasks including creation, manipulation, analysis, and visualization.\n  \n- **Clear Code Structure and Reusability:**\n  The tasks emphasize defining directed graphs (`nx.DiGraph`), adding nodes and edges, and modularizing code via functions. This promotes code reusability and maintainability, which is critical for complex graph operations.\n\n- **Subgraph Isomorphism Checks:**\n  For checking the presence of subgraphs within larger graphs, the `DiGraphMatcher` class from the `networkx.algorithms.isomorphism` module is consistently utilized. This class handles the intricate process of matching nodes and edges efficiently.\n\n- **Comprehensive Graph Definitions:**\n  Before matching operations, it's essential to clearly define the nodes and edges of the main graph and subgraph. Clear data structures\u2014lists of nodes and edges\u2014were used to ensure correct graph representations.\n\n#### **2. Key Insights:**\n- **Graph Isomorphism Importance:**\n  Detecting if a subgraph is present within a larger graph is critical in various domains such as bioinformatics for analyzing molecular structures, social network analysis, and pattern recognition in large datasets.\n\n- **Directed Graphs Specifics:**\n  Directed graphs, where edges have a direction, require specific attention to ensure that the directionality is preserved during isomorphism checks. The diagonal distinction between source and destination nodes is essential.\n\n- **Subgraph vs. Graph Isomorphism:**\n  Understanding the difference between subgraph isomorphism (`subgraph_is_monomorphic`) and exact graph isomorphism (`is_isomorphic`) is crucial for the correct application of the isomorphism checks. The former is typically used in the tasks.\n\n- **API Utilization:**\n  NetworkX provides several useful APIs beyond isomorphism, like shortest path algorithms (`networkx.shortest_path`), network measure calculations (like clustering, connectivity metrics), which, while not directly highlighted in the tasks, are invaluable in broader graph analysis contexts.\n\n#### **3. Useful APIs:**\n- **DiGraph:**\n  - `nx.DiGraph()`: To create directed graphs.\n  - `add_nodes_from(iterable)`: To add multiple nodes.\n  - `add_edges_from(ebunch)`: To add multiple edges.\n\n- **Isomorphism Algorithms:**\n  - `networkx.algorithms.isomorphism.DiGraphMatcher`: For matching directed graphs and assessing subgraph isomorphism.\n  - `matcher.subgraph_is_monomorphic()`: To check if a subgraph is an exact match within the main graph.\n\n#### **4. Key Experiences and Best Practices:**\n- **Modular Code Design:**\n  Define functions and keep the code structured into logical blocks to facilitate readability and reuse.\n  \n- **Data Structure Clarity:**\n  Use well-defined lists of nodes and edges to clearly represent graph structures.\n\n- **Thorough Testing:**\n  Validate the graph isomorphism algorithms by testing on different graph and subgraph configurations to ensure correctness.\n\n- **Best Practices in Graph Representation:**\n  Always ensure accurate representation of graphs and subgraphs before performing isomorphism checks to avoid computational errors.\n\nIn summary, leveraging NetworkX effectively for graph and subgraph isomorphism tasks involves a clear understanding of graph theoretical concepts, precise representation of graphs, and methodical application of isomorphism algorithms to obtain accurate results.",
        "rag_data": {
            "Section ID": "DiGraphMatcher.subgraph_is_monomorphic",
            "Description": [
                "Returns True if a subgraph of G1 is monomorphic to G2."
            ],
            "Field List": {},
            "Rubrics": {}
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine if a smaller graph is present as an exact match within a larger graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph G and a subgraph G', you need to output Yes or No, indicating whether subgraph G' is present within the directed graph G. Q: The nodes of graph G are numbered from 0 to 12, and the edges are: (0->1) (0->6) (0->7) (0->3) (0->9) (1->8) (1->9) (1->3) (2->11) (4->9) (4->7) (5->11) (6->11) (6->9) (7->9) (8->9) (10->11). The nodes of subgraph G' are numbered from a to f, and the edges are: (a->d) (b->e) (c->f) (d->e) (e->f). Is subgraph G' present within graph G as a direct substructure?",
                "code": "import networkx as nx\n\n# Define the main graph G\nG = nx.DiGraph()\nnodes_G = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nedges_G = [(0, 1), (0, 6), (0, 7), (0, 3), (0, 9), \n            (1, 8), (1, 9), (1, 3), (2, 11), (4, 9), \n            (4, 7), (5, 11), (6, 11), (6, 9), (7, 9), \n            (8, 9), (10, 11)]\n\nG.add_nodes_from(nodes_G)\nG.add_edges_from(edges_G)\n\n# Define the subgraph G'\nG_prime = nx.DiGraph()\nnodes_G_prime = ['a', 'b', 'c', 'd', 'e', 'f']\nedges_G_prime = [('a', 'd'), ('b', 'e'), ('c', 'f'), \n                 ('d', 'e'), ('e', 'f')]\n\nG_prime.add_nodes_from(nodes_G_prime)\nG_prime.add_edges_from(edges_G_prime)\n\n# Check if G' is a subgraph of G\nmatcher = nx.algorithms.isomorphism.DiGraphMatcher(G, G_prime)\nis_subgraph = matcher.subgraph_is_monomorphic()\n\n# Output result\nif is_subgraph:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
                "key_api": "networkx.algorithms.isomorphism.DiGraphMatcher",
                "key_experience": "Utilize directed graph matchers for subgraph isomorphism checks and ensure to follow best practices by structuring the code clearly, defining reusable functions for graph creation and isomorphism checks."
            },
            {
                "question": "Determine if a smaller graph is present as an exact match within a larger graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph G and a subgraph G', you need to output Yes or No, indicating whether subgraph G' is present within the directed graph G. Q: The nodes of graph G are numbered from 0 to 14, and the edges are: (0->12) (0->7) (0->10) (0->6) (0->4) (0->3) (0->5) (0->9) (0->11) (0->8) (0->2) (1->11) (1->12) (1->8) (1->13) (1->6) (1->2) (1->14) (1->5) (1->10) (1->9) (2->8) (2->3) (2->9) (2->11) (2->5) (3->7) (3->4) (3->5) (3->9) (3->6) (4->12) (4->7) (4->10) (5->11) (5->6) (5->7) (5->12) (6->10) (6->7) (6->11) (7->8) (7->9) (7->12) (7->13) (7->11) (8->10) (8->13) (8->12) (9->11) (9->10) (9->12) (9->14) (11->14) (11->12) (11->13). The nodes of subgraph G' are numbered from a to j, and the edges are: (a->j) (b->e) (b->i) (b->f) (c->g) (d->f) (e->j) (e->f) (e->i) (f->h) (f->i) (g->h). Is subgraph G' present within graph G as a direct substructure?",
                "code": "import networkx as nx\n\n# Define the main directed graph G\nG = nx.DiGraph()\n\n# Add nodes to G\nG.add_nodes_from(range(15))  # Nodes from 0 to 14\n\n# Define edges for G\nedges_G = [\n    (0, 12), (0, 7), (0, 10), (0, 6), (0, 4), (0, 3), (0, 5), (0, 9),\n    (0, 11), (0, 8), (0, 2), (1, 11), (1, 12), (1, 8), (1, 13), (1, 6),\n    (1, 2), (1, 14), (1, 5), (1, 10), (1, 9), (2, 8), (2, 3), (2, 9),\n    (2, 11), (2, 5), (3, 7), (3, 4), (3, 5), (3, 9), (3, 6), (4, 12),\n    (4, 7), (4, 10), (5, 11), (5, 6), (5, 7), (5, 12), (6, 10), (6, 7),\n    (6, 11), (7, 8), (7, 9), (7, 12), (7, 13), (7, 11), (8, 10), (8, 13),\n    (8, 12), (9, 11), (9, 10), (9, 12), (9, 14), (11, 14), (11, 12), (11, 13)\n]\n\n# Add edges to G\nG.add_edges_from(edges_G)\n\n# Define the subgraph G'\nG_prime = nx.DiGraph()\n\n# Add nodes to G'\nG_prime.add_nodes_from(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n\n# Define edges for G'\nedges_G_prime = [\n    ('a', 'j'), ('b', 'e'), ('b', 'i'), ('b', 'f'), ('c', 'g'),\n    ('d', 'f'), ('e', 'j'), ('e', 'f'), ('e', 'i'), ('f', 'h'),\n    ('f', 'i'), ('g', 'h')\n]\n\n# Add edges to G'\nG_prime.add_edges_from(edges_G_prime)\n\n# Check if G' is a subgraph of G\nfrom networkx.algorithms.isomorphism import DiGraphMatcher\n\nmatcher = DiGraphMatcher(G, G_prime)\nis_subgraph = matcher.subgraph_is_monomorphic()\n\n# Output result\nresult = \"Yes\" if is_subgraph else \"No\"\nprint(result)",
                "key_api": "DiGraphMatcher",
                "key_experience": "Utilized NetworkX for efficient graph representation and isomorphism checks, employing clear function definitions for modular and maintainable code."
            }
        ]
    },
    {
        "id": 18,
        "problem": "Determine if subgraph G' is present as an exact match within graph G.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience with Graph Isomorphism and Subgraph Matching Tasks\n\n#### **1. Key Practices:**\n- **Utilization of NetworkX Library:**\n  NetworkX is a powerful library in Python that provides comprehensive capabilities for handling complex graph-related tasks including creation, manipulation, analysis, and visualization.\n  \n- **Clear Code Structure and Reusability:**\n  The tasks emphasize defining directed graphs (`nx.DiGraph`), adding nodes and edges, and modularizing code via functions. This promotes code reusability and maintainability, which is critical for complex graph operations.\n\n- **Subgraph Isomorphism Checks:**\n  For checking the presence of subgraphs within larger graphs, the `DiGraphMatcher` class from the `networkx.algorithms.isomorphism` module is consistently utilized. This class handles the intricate process of matching nodes and edges efficiently.\n\n- **Comprehensive Graph Definitions:**\n  Before matching operations, it's essential to clearly define the nodes and edges of the main graph and subgraph. Clear data structures\u2014lists of nodes and edges\u2014were used to ensure correct graph representations.\n\n#### **2. Key Insights:**\n- **Graph Isomorphism Importance:**\n  Detecting if a subgraph is present within a larger graph is critical in various domains such as bioinformatics for analyzing molecular structures, social network analysis, and pattern recognition in large datasets.\n\n- **Directed Graphs Specifics:**\n  Directed graphs, where edges have a direction, require specific attention to ensure that the directionality is preserved during isomorphism checks. The diagonal distinction between source and destination nodes is essential.\n\n- **Subgraph vs. Graph Isomorphism:**\n  Understanding the difference between subgraph isomorphism (`subgraph_is_monomorphic`) and exact graph isomorphism (`is_isomorphic`) is crucial for the correct application of the isomorphism checks. The former is typically used in the tasks.\n\n- **API Utilization:**\n  NetworkX provides several useful APIs beyond isomorphism, like shortest path algorithms (`networkx.shortest_path`), network measure calculations (like clustering, connectivity metrics), which, while not directly highlighted in the tasks, are invaluable in broader graph analysis contexts.\n\n#### **3. Useful APIs:**\n- **DiGraph:**\n  - `nx.DiGraph()`: To create directed graphs.\n  - `add_nodes_from(iterable)`: To add multiple nodes.\n  - `add_edges_from(ebunch)`: To add multiple edges.\n\n- **Isomorphism Algorithms:**\n  - `networkx.algorithms.isomorphism.DiGraphMatcher`: For matching directed graphs and assessing subgraph isomorphism.\n  - `matcher.subgraph_is_monomorphic()`: To check if a subgraph is an exact match within the main graph.\n\n#### **4. Key Experiences and Best Practices:**\n- **Modular Code Design:**\n  Define functions and keep the code structured into logical blocks to facilitate readability and reuse.\n  \n- **Data Structure Clarity:**\n  Use well-defined lists of nodes and edges to clearly represent graph structures.\n\n- **Thorough Testing:**\n  Validate the graph isomorphism algorithms by testing on different graph and subgraph configurations to ensure correctness.\n\n- **Best Practices in Graph Representation:**\n  Always ensure accurate representation of graphs and subgraphs before performing isomorphism checks to avoid computational errors.\n\nIn summary, leveraging NetworkX effectively for graph and subgraph isomorphism tasks involves a clear understanding of graph theoretical concepts, precise representation of graphs, and methodical application of isomorphism algorithms to obtain accurate results.",
        "rag_data": {
            "Section ID": "DiGraphMatcher.subgraph_is_monomorphic",
            "Description": [
                "Returns True if a subgraph of G1 is monomorphic to G2."
            ],
            "Field List": {},
            "Rubrics": {}
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine if a smaller graph is present as an exact match within a larger graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph G and a subgraph G', you need to output Yes or No, indicating whether subgraph G' is present within the directed graph G. Q: The nodes of graph G are numbered from 0 to 12, and the edges are: (0->1) (0->6) (0->7) (0->3) (0->9) (1->8) (1->9) (1->3) (2->11) (4->9) (4->7) (5->11) (6->11) (6->9) (7->9) (8->9) (10->11). The nodes of subgraph G' are numbered from a to f, and the edges are: (a->d) (b->e) (c->f) (d->e) (e->f). Is subgraph G' present within graph G as a direct substructure?",
                "code": "import networkx as nx\n\n# Define the main graph G\nG = nx.DiGraph()\nnodes_G = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nedges_G = [(0, 1), (0, 6), (0, 7), (0, 3), (0, 9), \n            (1, 8), (1, 9), (1, 3), (2, 11), (4, 9), \n            (4, 7), (5, 11), (6, 11), (6, 9), (7, 9), \n            (8, 9), (10, 11)]\n\nG.add_nodes_from(nodes_G)\nG.add_edges_from(edges_G)\n\n# Define the subgraph G'\nG_prime = nx.DiGraph()\nnodes_G_prime = ['a', 'b', 'c', 'd', 'e', 'f']\nedges_G_prime = [('a', 'd'), ('b', 'e'), ('c', 'f'), \n                 ('d', 'e'), ('e', 'f')]\n\nG_prime.add_nodes_from(nodes_G_prime)\nG_prime.add_edges_from(edges_G_prime)\n\n# Check if G' is a subgraph of G\nmatcher = nx.algorithms.isomorphism.DiGraphMatcher(G, G_prime)\nis_subgraph = matcher.subgraph_is_monomorphic()\n\n# Output result\nif is_subgraph:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
                "key_api": "networkx.algorithms.isomorphism.DiGraphMatcher",
                "key_experience": "Utilize directed graph matchers for subgraph isomorphism checks and ensure to follow best practices by structuring the code clearly, defining reusable functions for graph creation and isomorphism checks."
            },
            {
                "question": "Determine if a smaller graph is present as an exact match within a larger graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph G and a subgraph G', you need to output Yes or No, indicating whether subgraph G' is present within the directed graph G. Q: The nodes of graph G are numbered from 0 to 14, and the edges are: (0->12) (0->7) (0->10) (0->6) (0->4) (0->3) (0->5) (0->9) (0->11) (0->8) (0->2) (1->11) (1->12) (1->8) (1->13) (1->6) (1->2) (1->14) (1->5) (1->10) (1->9) (2->8) (2->3) (2->9) (2->11) (2->5) (3->7) (3->4) (3->5) (3->9) (3->6) (4->12) (4->7) (4->10) (5->11) (5->6) (5->7) (5->12) (6->10) (6->7) (6->11) (7->8) (7->9) (7->12) (7->13) (7->11) (8->10) (8->13) (8->12) (9->11) (9->10) (9->12) (9->14) (11->14) (11->12) (11->13). The nodes of subgraph G' are numbered from a to j, and the edges are: (a->j) (b->e) (b->i) (b->f) (c->g) (d->f) (e->j) (e->f) (e->i) (f->h) (f->i) (g->h). Is subgraph G' present within graph G as a direct substructure?",
                "code": "import networkx as nx\n\n# Define the main directed graph G\nG = nx.DiGraph()\n\n# Add nodes to G\nG.add_nodes_from(range(15))  # Nodes from 0 to 14\n\n# Define edges for G\nedges_G = [\n    (0, 12), (0, 7), (0, 10), (0, 6), (0, 4), (0, 3), (0, 5), (0, 9),\n    (0, 11), (0, 8), (0, 2), (1, 11), (1, 12), (1, 8), (1, 13), (1, 6),\n    (1, 2), (1, 14), (1, 5), (1, 10), (1, 9), (2, 8), (2, 3), (2, 9),\n    (2, 11), (2, 5), (3, 7), (3, 4), (3, 5), (3, 9), (3, 6), (4, 12),\n    (4, 7), (4, 10), (5, 11), (5, 6), (5, 7), (5, 12), (6, 10), (6, 7),\n    (6, 11), (7, 8), (7, 9), (7, 12), (7, 13), (7, 11), (8, 10), (8, 13),\n    (8, 12), (9, 11), (9, 10), (9, 12), (9, 14), (11, 14), (11, 12), (11, 13)\n]\n\n# Add edges to G\nG.add_edges_from(edges_G)\n\n# Define the subgraph G'\nG_prime = nx.DiGraph()\n\n# Add nodes to G'\nG_prime.add_nodes_from(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n\n# Define edges for G'\nedges_G_prime = [\n    ('a', 'j'), ('b', 'e'), ('b', 'i'), ('b', 'f'), ('c', 'g'),\n    ('d', 'f'), ('e', 'j'), ('e', 'f'), ('e', 'i'), ('f', 'h'),\n    ('f', 'i'), ('g', 'h')\n]\n\n# Add edges to G'\nG_prime.add_edges_from(edges_G_prime)\n\n# Check if G' is a subgraph of G\nfrom networkx.algorithms.isomorphism import DiGraphMatcher\n\nmatcher = DiGraphMatcher(G, G_prime)\nis_subgraph = matcher.subgraph_is_monomorphic()\n\n# Output result\nresult = \"Yes\" if is_subgraph else \"No\"\nprint(result)",
                "key_api": "DiGraphMatcher",
                "key_experience": "Utilized NetworkX for efficient graph representation and isomorphism checks, employing clear function definitions for modular and maintainable code."
            }
        ]
    },
    {
        "id": 19,
        "problem": "Find the maximum flow between node 3 and node 5 in the directed graph.",
        "graph_type": "directed",
        "experience": "### Summary of Key Experiences and Practices in Solving Maximum Flow Problems in Directed Graphs\n\n#### Common Practices:\n1. **Consistent Use of NetworkX**:\n   - The `networkx` library was consistently used across tasks for graph representation and flow calculations.\n   - The `preflow_push` algorithm from NetworkX\u2019s flow algorithm suite was used for maximum flow calculations.\n\n2. **Structured Data Representation**:\n   - Node and edge lists were clearly defined and presented in structured formats (e.g., dictionaries for edges).\n   - This approach ensured data integrity and facilitated easy construction of the graph.\n\n3. **Clear Graph Construction**:\n   - Nodes and edges were explicitly added to construct a `DiGraph` object.\n   - Edges were defined with capacities to represent weights properly, crucial for flow calculation tasks.\n\n4. **Consistent Workflow**:\n   - Each task followed a consistent workflow: data definition, graph construction, algorithm application, and result extraction.\n   - Clear definition of source and sink nodes was critical for accurate flow computation.\n\n5. **Code Readability and Maintainability**:\n   - Variables and methods were clearly named, making the code easy to understand and maintain.\n   - Comments and formatted output messages enhanced readability, notably explaining what each section of the code does.\n\n#### Key Insights:\n1. **Efficient Maximum Flow Calculation**:\n   - NetworkX's higher-level algorithms like `preflow_push` provided efficient solutions for computing the maximum flow between nodes in large graphs.\n   - These algorithms are optimized, providing reliable performance even for graphs with many nodes and edges.\n\n2. **Importance of Edge Capacities**:\n   - Assigning correct 'capacity' attributes to graph edges is crucial.\n   - The capacity parameter dictates the maximum allowable flow on each edge, directly impacting the overall flow calculation.\n\n3. **Adaptability to Different Graph Sizes**:\n   - The methods used were scalable, handling graphs of varying sizes and complexities (from small graphs with few nodes to larger ones with many nodes).\n\n4. **Error Handling and Validation**:\n   - While not explicitly detailed in the examples, ensuring proper error handling and validation of input data is vital for robustness.\n   - This includes verifying node existence, valid edge definitions, and correct capacities.\n\n#### Useful APIs:\n1. **NetworkX Library (`networkx`)**:\n   - **Graph Construction**:\n     - `nx.DiGraph()`: Creates a new directed graph.\n     - `G.add_edge(u, v, capacity=w)`: Adds a directed edge from node `u` to node `v` with a specified capacity `w`.\n\n   - **Flow Algorithms**:\n     - `preflow_push(G, source, sink)`: Computes the maximum flow between the defined `source` and `sink` nodes in graph `G` using the preflow-push algorithm.\n     - Residual network properties and results can be examined via the returned graph object.\n\n2. **Python Standard Libraries**:\n   - **Data Parsing and Formatting**:\n     - Use of standard data structures (e.g., lists, dictionaries) for input representation.\n     - Standard print statements for outputting results in a clear format.\n\n### Conclusion:\nBy consistently using NetworkX for graph representation and preflow-push for maximum flow calculations, reliable and efficient solutions were developed. Ensuring structured and clear data representation, along with maintaining code readability and error handling, were key to the success of solving these complex maximum flow problems in directed graphs.",
        "rag_data": {
            "Section ID": "preflow_push",
            "Description": [
                "Find a maximum single-commodity flow using the highest-label\npreflow-push algorithm.",
                "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
                "This algorithm has a running time of \\(O(n^2 \\sqrt{m})\\) for \\(n\\) nodes and \\(m\\) edges."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                    "s : node": "Source node for the flow.",
                    "t : node": "Sink node for the flow.",
                    "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                    "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                    "global_relabel_freq : integer, float": "Relative frequency of applying the global relabeling heuristic to speed\nup the algorithm. If it is None, the heuristic is disabled. Default\nvalue: 1.",
                    "value_only : bool": "If False, compute a maximum flow; otherwise, compute a maximum preflow\nwhich is enough for computing the maximum flow value. Default value:\nFalse."
                },
                "Returns:": {
                    "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
                },
                "Raises:": {
                    "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                    "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                }
            },
            "Rubrics": {
                "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each node u in R , R.nodes[u]['excess'] represents the difference between flow into u and flow out of u . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
                "Examples": "fromnetworkx.algorithms.flowimportpreflow_push\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=preflow_push(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value==R.graph[\"flow_value\"]\n# True\n# preflow_push also stores the maximum flow value\n# in the excess attribute of the sink node t\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True\n# For some problems, you might only want to compute a\n# maximum preflow.\nR=preflow_push(G,\"x\",\"y\",value_only=True)\nflow_value==R.graph[\"flow_value\"]\n# True\nflow_value==R.nodes[\"y\"][\"excess\"]\n# True"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 5, and the edges are: (0->2,4) (1->5,2) (1->4,7) (3->4,3) (4->5,6). What is the maximum flow from node 3 to node 5?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import preflow_push\n\n# Define the graph structure based on the input\nnodes = [0, 1, 2, 3, 4, 5]\nedges = [\n    {'from': 0, 'to': 2, 'weight': 4},\n    {'from': 1, 'to': 5, 'weight': 2},\n    {'from': 1, 'to': 4, 'weight': 7},\n    {'from': 3, 'to': 4, 'weight': 3},\n    {'from': 4, 'to': 5, 'weight': 6}\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph with capacities\nfor edge in edges:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and sink\nsource = 3\nsink = 5\n\n# Compute the maximum flow using the preflow-push algorithm\nR = preflow_push(G, source, sink)\n\n# Retrieve the maximum flow value\nmax_flow_value = R.graph['flow_value']\n\n# Output the maximum flow value\nprint(max_flow_value)",
                "key_api": "networkx.algorithms.flow.preflow_push",
                "key_experience": "Using higher-level flow algorithms in NetworkX, such as preflow-push, allows for efficient calculation of maximum flow in directed graphs. Ensure that graph edges are assigned 'capacity' attributes to define flow limits. It is important to utilize clear variable names, structured data formats, and proper error handling for increased readability and maintainability."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 7, and the edges are: (0->7,9) (0->4,5) (1->5,2) (1->3,7) (1->6,1) (2->4,2) (2->5,4) (3->4,5) (3->7,3) (5->7,7) (5->6,1). What is the maximum flow from node 1 to node 7?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import preflow_push\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7],\n    'Edges': [\n        {'from': 0, 'to': 7, 'weight': 9},\n        {'from': 0, 'to': 4, 'weight': 5},\n        {'from': 1, 'to': 5, 'weight': 2},\n        {'from': 1, 'to': 3, 'weight': 7},\n        {'from': 1, 'to': 6, 'weight': 1},\n        {'from': 2, 'to': 4, 'weight': 2},\n        {'from': 2, 'to': 5, 'weight': 4},\n        {'from': 3, 'to': 4, 'weight': 5},\n        {'from': 3, 'to': 7, 'weight': 3},\n        {'from': 5, 'to': 7, 'weight': 7},\n        {'from': 5, 'to': 6, 'weight': 1}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Compute the maximum flow using the preflow-push algorithm\nsource = 1\nsink = 7\nR = preflow_push(G, source, sink)\n\n# Retrieve the maximum flow value\nmax_flow_value = R.graph['flow_value']\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source} to node {sink} is: {max_flow_value}\")",
                "key_api": "NetworkX library with methods like preflow_push, maximum_flow, and edmonds_karp for computing maximum flow in directed graphs.",
                "key_experience": "Utilization of structured and well-documented code. Ensured correct graph construction and flow computation. Clear definition of source and sink nodes for maximum flow algorithms, along with handling of edge capacities effectively. Employed diverse maximum flow algorithms based on problem requirements, demonstrating adaptability."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 38, and the edges are: (0->24,8) (0->13,9) (0->11,2) (0->10,9) (0->23,2) (0->5,6) (1->32,1) (1->12,1) (1->2,4) (2->6,8) (2->9,9) (2->28,10) (2->32,2) (2->37,10) (2->11,9) (2->17,3) (3->27,10) (3->8,1) (3->4,3) (3->26,8) (3->34,4) (4->22,10) (4->29,3) (4->38,6) (4->14,7) (4->32,8) (5->24,7) (5->37,5) (5->35,1) (6->32,6) (6->38,7) (7->25,4) (7->15,9) (7->19,1) (7->27,3) (8->31,9) (8->25,9) (8->10,10) (8->12,7) (8->30,7) (9->18,1) (9->30,6) (11->25,5) (11->19,5) (11->13,2) (11->29,9) (12->24,3) (12->16,6) (12->38,6) (13->30,9) (13->26,3) (13->28,4) (14->20,5) (14->29,3) (15->33,7) (15->32,10) (16->19,4) (16->34,9) (16->32,5) (17->30,10) (18->36,10) (18->25,6) (18->32,4) (19->22,7) (20->23,2) (20->25,1) (20->35,8) (21->31,4) (21->23,1) (21->26,9) (24->27,4) (24->34,10) (25->26,2) (26->36,10) (27->29,7) (28->29,7) (28->33,8) (29->35,1) (29->38,8) (30->35,2) (30->38,4) (31->33,2) (33->37,1) (33->34,9) (35->37,10) (35->36,8). What is the maximum flow from node 5 to node 27?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import preflow_push\n\n# Define the graph\nG = nx.DiGraph()\n\n# Add edges along with their weights (capacity)\nedges = [\n    (0, 24, 8), (0, 13, 9), (0, 11, 2), (0, 10, 9), (0, 23, 2), (0, 5, 6),\n    (1, 32, 1), (1, 12, 1), (1, 2, 4), (2, 6, 8), (2, 9, 9), (2, 28, 10),\n    (2, 32, 2), (2, 37, 10), (2, 11, 9), (2, 17, 3), (3, 27, 10), (3, 8, 1),\n    (3, 4, 3), (3, 26, 8), (3, 34, 4), (4, 22, 10), (4, 29, 3), (4, 38, 6),\n    (4, 14, 7), (4, 32, 8), (5, 24, 7), (5, 37, 5), (5, 35, 1), (6, 32, 6),\n    (6, 38, 7), (7, 25, 4), (7, 15, 9), (7, 19, 1), (7, 27, 3), (8, 31, 9),\n    (8, 25, 9), (8, 10, 10), (8, 12, 7), (8, 30, 7), (9, 18, 1), (9, 30, 6),\n    (11, 25, 5), (11, 19, 5), (11, 13, 2), (11, 29, 9), (12, 24, 3), (12, 16, 6),\n    (12, 38, 6), (13, 30, 9), (13, 26, 3), (13, 28, 4), (14, 20, 5), (14, 29, 3),\n    (15, 33, 7), (15, 32, 10), (16, 19, 4), (16, 34, 9), (16, 32, 5), (17, 30, 10),\n    (18, 36, 10), (18, 25, 6), (18, 32, 4), (19, 22, 7), (20, 23, 2), (20, 25, 1),\n    (20, 35, 8), (21, 31, 4), (21, 23, 1), (21, 26, 9), (24, 27, 4), (24, 34, 10),\n    (25, 26, 2), (26, 36, 10), (27, 29, 7), (28, 29, 7), (28, 33, 8), (29, 35, 1),\n    (29, 38, 8), (30, 35, 2), (30, 38, 4), (31, 33, 2), (33, 37, 1), (33, 34, 9),\n    (35, 37, 10), (35, 36, 8)\n]\n\n# Add edges to the graph\nfor from_node, to_node, weight in edges:\n    G.add_edge(from_node, to_node, capacity=weight)\n\n# Define source and target nodes\nsource_node = 5\ntarget_node = 27\n\n# Compute maximum flow using the preflow-push algorithm\nresidual_network = preflow_push(G, source_node, target_node)\n\n# Retrieve the maximum flow value\nmax_flow_value = residual_network.graph['flow_value']\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source_node} to node {target_node} is: {max_flow_value}\")",
                "key_api": "networkx",
                "key_experience": "Utilized the preflow-push algorithm, appropriately leveraging NetworkX's built-in methods for flow calculation. Clearly defined graph structures and maintained clear variable names for nodes and edges, which enhances code readability and maintainability."
            }
        ]
    },
    {
        "id": 20,
        "problem": "Find the maximum flow between node 0 and node 7 in a directed graph.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience\n\n#### Important Practices\n\n1. **Utilization of Libraries**:\n   - All tasks extensively employed the NetworkX library, which offers a wealth of graph-related algorithms and data structures ensuring efficiency and simplicity in implementation.\n\n2. **Clear Graph Definition**:\n   - The practice of defining graphs explicitly with nodes and edge capacities was consistent across tasks. This approach ensures that the graph's structure is clear and easily interpretable.\n\n3. **Descriptive Variable Names**:\n   - Consistent use of descriptive variable names (e.g., `source_node`, `target_node`, `capacity`) enhanced code readability and maintainability.\n\n4. **Edge Properties**:\n   - Proper setting of edge capacities in the directed graph was crucial for correct and efficient maximum flow computation.\n\n#### Key Insights\n\n1. **Edmonds-Karp Algorithm**:\n   - The Edmonds-Karp algorithm, accessible through `networkx.maximum_flow`, was identified as a reliable and efficient method for computing maximum flow in directed graphs. Its application across all tasks indicates its robustness and efficiency.\n\n2. **Efficiency through Pre-built Functions**:\n   - Leveraging pre-built functions from established libraries like NetworkX minimizes the risk of errors and optimizes performance. These functions are time-tested and offer well-documented features that are beneficial in complex graph computations.\n\n3. **Structured Problem Solving**:\n   - A structured approach to problem-solving was evident: defining the problem (nodes, edges, capacities), creating the graph, applying the algorithm, and then interpreting the result. This methodical approach ensures clarity and effectiveness.\n\n4. **Flexibility and Scalability**:\n   - The solution approach used was flexible enough to handle varying complexities of graphs, from small to large node counts and intricate edge configurations.\n\n#### Useful APIs\n\n1. **NetworkX Library (nx)**\n   - **Graph Creation**: `G = nx.DiGraph()`\n     - Creates a directed graph which is foundational for tasks involving directed edge flows.\n   - **Adding Edges**: `G.add_edge(source, target, capacity=weight)`\n     - Adds edges with capacities to the graph, crucial for setting up flow problems.\n   - **Maximum Flow Calculation**: `max_flow_value, flow_dict = nx.maximum_flow(G, source_node, target_node)`\n     - Computes the maximum flow in the graph using the Edmonds-Karp algorithm, providing both the maximum flow value and the flow distribution.\n\n### Conclusion\n\nThe tasks demonstrated proficient use of the NetworkX library for solving maximum flow problems in directed graphs. Key practices such as structured graph definition, use of descriptive variable names, and leveraging efficient graph algorithms were integral to the success of these tasks. The Edmonds-Karp algorithm, as implemented in NetworkX, proved to be an invaluable tool for these types of problems, providing reliable and efficient results.",
        "rag_data": {
            "Section ID": "edmonds_karp",
            "Description": [
                "Find a maximum single-commodity flow using the Edmonds-Karp algorithm.",
                "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
                "This algorithm has a running time of \\(O(n m^2)\\) for \\(n\\) nodes and \\(m\\) edges."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                    "s : node": "Source node for the flow.",
                    "t : node": "Sink node for the flow.",
                    "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                    "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                    "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                    "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
                },
                "Returns:": {
                    "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
                },
                "Raises:": {
                    "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                    "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                }
            },
            "Rubrics": {
                "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
                "Examples": "fromnetworkx.algorithms.flowimportedmonds_karp\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=edmonds_karp(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 6, and the edges are: (0->1,4) (0->4,10) (0->6,6) (1->3,6) (2->5,1) (2->6,10) (3->4,6) (4->5,6). What is the maximum flow from node 0 to node 5?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import edmonds_karp\n\n# Define the graph based on the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6],\n    'Edges': [\n        {'from': 0, 'to': 1, 'weight': 4},\n        {'from': 0, 'to': 4, 'weight': 10},\n        {'from': 0, 'to': 6, 'weight': 6},\n        {'from': 1, 'to': 3, 'weight': 6},\n        {'from': 2, 'to': 5, 'weight': 1},\n        {'from': 2, 'to': 6, 'weight': 10},\n        {'from': 3, 'to': 4, 'weight': 6},\n        {'from': 4, 'to': 5, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Calculate the maximum flow from node 0 to node 5\nmax_flow_value, flow_dict = nx.maximum_flow(G, 0, 5)\n\n# Output the maximum flow value\nprint(max_flow_value)",
                "key_api": "networkx.maximum_flow",
                "key_experience": "Utilized the NetworkX library to create a directed graph and compute the maximum flow. Followed best practices such as defining a clear graph structure, using descriptive variable names, and ensuring the capacity attribute is correctly set. Employed the appropriate algorithm (Edmonds-Karp) for maximum flow computation to ensure efficiency."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 9, and the edges are: (0->1,3) (0->4,5) (0->5,1) (0->6,2) (1->9,2) (1->4,1) (1->6,2) (1->8,4) (2->3,6) (4->7,2) (4->8,5) (4->5,4) (5->8,5) (6->8,4) (6->7,9) (6->9,6) (7->8,6). What is the maximum flow from node 0 to node 7?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import edmonds_karp\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n    'Edges': [\n        {'from': 0, 'to': 1, 'weight': 3},\n        {'from': 0, 'to': 4, 'weight': 5},\n        {'from': 0, 'to': 5, 'weight': 1},\n        {'from': 0, 'to': 6, 'weight': 2},\n        {'from': 1, 'to': 9, 'weight': 2},\n        {'from': 1, 'to': 4, 'weight': 1},\n        {'from': 1, 'to': 6, 'weight': 2},\n        {'from': 1, 'to': 8, 'weight': 4},\n        {'from': 2, 'to': 3, 'weight': 6},\n        {'from': 4, 'to': 7, 'weight': 2},\n        {'from': 4, 'to': 8, 'weight': 5},\n        {'from': 4, 'to': 5, 'weight': 4},\n        {'from': 5, 'to': 8, 'weight': 5},\n        {'from': 6, 'to': 8, 'weight': 4},\n        {'from': 6, 'to': 7, 'weight': 9},\n        {'from': 6, 'to': 9, 'weight': 6},\n        {'from': 7, 'to': 8, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 0\ntarget_node = 7\n\n# Compute the maximum flow using the Edmonds-Karp algorithm\nmax_flow_value, flow_dict = nx.maximum_flow(G, _s=source_node, _t=target_node)\n\n# Output the maximum flow value\nprint(max_flow_value)",
                "key_api": "networkx.maximum_flow",
                "key_experience": "Leveraged NetworkX, specifically the Edmonds-Karp algorithm, for efficiently calculating maximum flow in a directed graph. Added edge capacities during graph construction and provided clear definitions for source and target nodes."
            }
        ]
    },
    {
        "id": 21,
        "problem": "Find the maximum flow between node 0 and node 7 in a directed graph.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience from Multiple Coding Tasks:\n\n#### **Key Experiences and Practices:**\n\n1. **Defining Graph Structures:**\n   - For each task, defining the graph structure clearly and correctly is crucial. This includes specifying nodes and edges along with their capacities.\n   - Use dictionaries or lists effectively to represent nodes and edges which aids in organizing and managing data.\n\n2. **Utilizing NetworkX Library:**\n   - NetworkX is heavily relied upon for handling directed graphs and computing maximum flows. It simplifies these tasks with its built-in functionalities.\n   - `nx.DiGraph()` is used to create directed graphs, while `nx.maximum_flow()` calculates the maximum flow between specified nodes.\n\n3. **Step-by-Step Workflow:**\n   - Create the directed graph using `nx.DiGraph()`.\n   - Add edges to the graph using `.add_edge()` method, making sure to include the `capacity` attribute which represents the weight or capacity of each edge.\n   - Compute the maximum flow between defined source and target nodes using `nx.maximum_flow()`.\n\n4. **Clear Node and Edge Definitions:**\n   - Carefully define all nodes and edges in the graph to avoid errors during flow calculations.\n   - Use clear and meaningful variable names to enhance code readability and maintainability.\n\n5. **Output and Flow Distribution:**\n   - Always output the maximum flow value for clarity. In some tasks, also print the flow distribution across edges to gain insights into how the flow is allocated through the graph.\n\n6. **Handling Large Graphs:**\n   - For larger graphs with many nodes and edges, ensure memory and computational efficiency. The practices of defining edge capacities and using efficient algorithms in NetworkX help manage larger datasets.\n\n7. **Verification and Edge Cases:**\n   - Verify the graph's structure for correctness before performing maximum flow calculations.\n   - Handle potential errors related to graph connectivity and capacity gracefully to avoid unexpected results.\n\n#### **Key Insights:**\n\n1. **Efficiency and Ease of Use:**\n   - NetworkX provides efficient algorithms and an easy-to-use interface for dealing with complex graph problems such as maximum flow.\n   \n2. **Importance of Proper Setup:**\n   - A critical aspect is to set up the graph correctly \u2014 any mistakes in node or edge definition can lead to incorrect flow calculations or runtime errors.\n\n3. **Graph Theory Applications:**\n   - These tasks highlight practical applications of graph theory in solving real-world problems involving flow networks, showcasing the importance of graph algorithms.\n\n#### **Useful APIs:**\n\n1. **NetworkX Library:**\n   - **`nx.DiGraph()`:** Constructs a directed graph.\n   - **`nx.add_edge()`:** Adds edges between nodes in the graph with optional attributes such as capacity.\n   - **`nx.maximum_flow()`:** Computes the maximum flow between the specified source and sink nodes in the graph, returning the flow value and detailed flow dictionary.\n\n### Conclusion\n\nThe experience reinforced the significance of well-structured graph definitions, the utility of the NetworkX library for flow computations, and the importance of output clarity. Following these best practices ensures the accuracy and efficiency of maximum flow calculations in directed graphs.",
        "rag_data": {
            "Section ID": "maximum_flow",
            "Description": [
                "Find a maximum single-commodity flow."
            ],
            "Field List": {
                "Parameters:": {
                    "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                    "_s : node": "Source node for the flow.",
                    "_t : node": "Sink node for the flow.",
                    "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                    "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                    "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
                },
                "Returns:": {
                    "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source.",
                    "flow_dict : dict": "A dictionary containing the value of the flow that went through\neach edge."
                },
                "Raises:": {
                    "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                    "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                }
            },
            "Rubrics": {
                "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
                "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 6, and the edges are: (0->1,4) (0->4,10) (0->6,6) (1->3,6) (2->5,1) (2->6,10) (3->4,6) (4->5,6). What is the maximum flow from node 0 to node 5?",
                "code": "import networkx as nx\n\n# Define the graph based on the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6],\n    'Edges': [\n        {'from': 0, 'to': 1, 'weight': 4},\n        {'from': 0, 'to': 4, 'weight': 10},\n        {'from': 0, 'to': 6, 'weight': 6},\n        {'from': 1, 'to': 3, 'weight': 6},\n        {'from': 2, 'to': 5, 'weight': 1},\n        {'from': 2, 'to': 6, 'weight': 10},\n        {'from': 3, 'to': 4, 'weight': 6},\n        {'from': 4, 'to': 5, 'weight': 6}\n    ],\n    'Source': 0,\n    'Sink': 5\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Calculate the maximum flow from source to sink\nflow_value, flow_dict = nx.maximum_flow(G, _s=input_data['Source'], _t=input_data['Sink'])\n\n# Output the maximum flow value\nprint(\"Maximum flow from node {} to node {} is: {}\".format(input_data['Source'], input_data['Sink'], flow_value))",
                "key_api": "networkx.maximum_flow",
                "key_experience": "Ensure to define a directed graph properly and add edges with their respective capacities. Always verify that the nodes and edges are correctly set up before calculating the maximum flow. Additionally, it's good practice to handle edge cases where the graph might not support the desired operations."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 9, and the edges are: (0->1,3) (0->4,5) (0->5,1) (0->6,2) (1->9,2) (1->4,1) (1->6,2) (1->8,4) (2->3,6) (4->7,2) (4->8,5) (4->5,4) (5->8,5) (6->8,4) (6->7,9) (6->9,6) (7->8,6). What is the maximum flow from node 0 to node 7?",
                "code": "import networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n    'Edges': [\n        {'from': 0, 'to': 1, 'weight': 3},\n        {'from': 0, 'to': 4, 'weight': 5},\n        {'from': 0, 'to': 5, 'weight': 1},\n        {'from': 0, 'to': 6, 'weight': 2},\n        {'from': 1, 'to': 9, 'weight': 2},\n        {'from': 1, 'to': 4, 'weight': 1},\n        {'from': 1, 'to': 6, 'weight': 2},\n        {'from': 1, 'to': 8, 'weight': 4},\n        {'from': 2, 'to': 3, 'weight': 6},\n        {'from': 4, 'to': 7, 'weight': 2},\n        {'from': 4, 'to': 8, 'weight': 5},\n        {'from': 4, 'to': 5, 'weight': 4},\n        {'from': 5, 'to': 8, 'weight': 5},\n        {'from': 6, 'to': 8, 'weight': 4},\n        {'from': 6, 'to': 7, 'weight': 9},\n        {'from': 6, 'to': 9, 'weight': 6},\n        {'from': 7, 'to': 8, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 0\ntarget_node = 7\n\n# Calculate the maximum flow\nflow_value, flow_dict = nx.maximum_flow(G, _s=source_node, _t=target_node)\n\n# Output the maximum flow value\nprint(\"Maximum flow value from node {} to node {}: {}\".format(source_node, target_node, flow_value))",
                "key_api": "networkx.maximum_flow",
                "key_experience": "Utilizing the NetworkX library facilitates handling directed graphs and computing the maximum flow efficiently. Key practices include defining the graph structure clearly, using capacity attributes for edges, and outputting results that are informative for further analysis."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 40, and the edges are: (0->39,10) (0->10,1) (0->12,8) (0->40,4) (0->29,2) (0->6,10) (0->3,4) (1->29,5) (1->37,5) (2->32,8) (2->29,3) (3->39,5) (3->19,1) (4->38,1) (4->6,9) (5->17,10) (5->38,7) (6->39,3) (6->15,2) (6->37,6) (8->39,3) (8->34,8) (8->31,1) (8->15,6) (8->38,2) (9->17,6) (9->39,4) (9->36,2) (10->34,9) (10->40,9) (10->24,6) (10->25,2) (10->12,10) (11->17,10) (11->38,6) (12->19,10) (12->20,8) (12->26,1) (13->37,4) (14->31,3) (14->21,3) (14->29,10) (14->28,7) (14->25,7) (15->24,9) (15->39,7) (16->28,7) (17->36,6) (17->39,3) (18->28,4) (18->31,2) (19->30,1) (19->39,4) (19->20,1) (19->31,7) (20->28,10) (20->34,2) (21->35,9) (22->25,9) (22->34,9) (23->30,3) (24->38,10) (25->37,2) (25->26,1) (26->30,10) (27->35,10) (28->29,8) (28->33,2) (29->37,7) (29->36,2) (30->39,2) (31->38,9) (34->38,3) (35->38,4) (39->40,2). What is the maximum flow from node 0 to node 26?",
                "code": "import networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Define the edges with their weights (capacity)\nedges = [\n    (0, 39, 10), (0, 10, 1), (0, 12, 8), (0, 40, 4), (0, 29, 2), (0, 6, 10),\n    (0, 3, 4), (1, 29, 5), (1, 37, 5), (2, 32, 8), (2, 29, 3), (3, 39, 5),\n    (3, 19, 1), (4, 38, 1), (4, 6, 9), (5, 17, 10), (5, 38, 7), (6, 39, 3),\n    (6, 15, 2), (6, 37, 6), (8, 39, 3), (8, 34, 8), (8, 31, 1), (8, 15, 6),\n    (8, 38, 2), (9, 17, 6), (9, 39, 4), (9, 36, 2), (10, 34, 9), (10, 40, 9),\n    (10, 24, 6), (10, 25, 2), (10, 12, 10), (11, 17, 10), (11, 38, 6), (12, 19, 10),\n    (12, 20, 8), (12, 26, 1), (13, 37, 4), (14, 31, 3), (14, 21, 3), (14, 29, 10),\n    (14, 28, 7), (14, 25, 7), (15, 24, 9), (15, 39, 7), (16, 28, 7), (17, 36, 6),\n    (17, 39, 3), (18, 28, 4), (18, 31, 2), (19, 30, 1), (19, 39, 4), (19, 20, 1),\n    (19, 31, 7), (20, 28, 10), (20, 34, 2), (21, 35, 9), (22, 25, 9), (22, 34, 9),\n    (23, 30, 3), (24, 38, 10), (25, 37, 2), (25, 26, 1), (26, 30, 10), (27, 35, 10),\n    (28, 29, 8), (28, 33, 2), (29, 37, 7), (29, 36, 2), (30, 39, 2), (31, 38, 9),\n    (34, 38, 3), (35, 38, 4), (39, 40, 2)\n]\n\n# Add edges to the graph\nfor from_node, to_node, weight in edges:\n    G.add_edge(from_node, to_node, capacity=weight)\n\n# Define source and target nodes\nsource_node = 0\ntarget_node = 26\n\n# Calculate maximum flow\nflow_value, flow_dict = nx.maximum_flow(G, _s=source_node, _t=target_node)\n\n# Output the results\nprint(f\"Maximum flow from node {source_node} to node {target_node}: {flow_value}\")\nprint(\"Flow distribution across edges:\")\nfor u in flow_dict:\n    for v in flow_dict[u]:\n        if flow_dict[u][v] > 0:\n            print(f\"Flow from {u} to {v}: {flow_dict[u][v]}\")",
                "key_api": "networkx.maximum_flow",
                "key_experience": "Utilized NetworkX to efficiently calculate maximum flow in a directed graph, ensuring clear edge capacity definitions and proper flow calculations. The use of dictionaries for flow distribution helped in easy flow tracking across edges."
            }
        ]
    },
    {
        "id": 22,
        "problem": "Find the maximum flow between node 15 and node 40 in the directed graph.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience in Solving Maximum Flow Problems in Directed Graphs\n\n#### Key Practices:\n1. **Graph Representation**:\n   - Use clear and structured input for defining the graph nodes and edges, including capacities.\n   - Consistently use a directed graph (`DiGraph`) for representing flow networks.\n\n2. **Edge Capacity Definition**:\n   - Ensure edges are defined with explicit capacity attributes to enable accurate flow calculations.\n   - Maintain concise and organized data structures (dictionaries or lists) to hold graph data, facilitating easy manipulation and addition of edges.\n\n3. **Algorithm Utilization**:\n   - Utilize established algorithms such as Boykov-Kolmogorov (`boykov_kolmogorov`) and other maximum flow algorithms available in NetworkX to compute maximum flows efficiently.\n   - Ensure correctness by using algorithms proven for computational performance and accuracy.\n\n4. **Source and Target Definition**:\n   - Clearly define source and target nodes before performing flow calculations to avoid any ambiguity and ensure accuracy in results.\n\n5. **Output Results Clearly**:\n   - Print the results in a clear and understandable format, stating the maximum flow value and the source and target nodes.\n\n#### Key Insights:\n1. **Efficiency and Accuracy**:\n   - Using efficient algorithms like Boykov-Kolmogorov directly impacts computational efficiency and result accuracy, especially in larger graphs.\n   - Keeping graph structures organized helps in the quick and error-free addition and analysis of graph components.\n\n2. **Flexibility in Data Handling**:\n   - Structuring edge data as a list of dictionaries or tuples allows for flexibility in handling different graph specifications and capacities.\n\n3. **API Usage**:\n   - Leveraging NetworkX's flow algorithms ensures robust handling of complex graph flow problems without the need for manual implementation of intricate algorithms.\n\n#### Useful APIs:\n1. **NetworkX**:\n   - `networkx.DiGraph()`: For creating directed graphs.\n   - `networkx.algorithms.flow.boykov_kolmogorov`: For computing maximum flow using the Boykov-Kolmogorov algorithm.\n   - `networkx.maximum_flow_value()`: For computing the maximum flow value using default algorithms of NetworkX, often useful for quick computations.\n\nBy adhering to these key practices and insights, one can efficiently solve maximum flow problems in directed graphs while leveraging the powerful functionalities provided by NetworkX APIs.",
        "rag_data": {
            "Section ID": "boykov_kolmogorov",
            "Description": [
                "Find a maximum single-commodity flow using Boykov-Kolmogorov algorithm.",
                "This function returns the residual network resulting after computing\nthe maximum flow. See below for details about the conventions\nNetworkX uses for defining residual networks.",
                "This algorithm has worse case complexity \\(O(n^2 m |C|)\\) for \\(n\\) nodes, \\(m\\) edges, and \\(|C|\\) the cost of the minimum cut [1] . This implementation\nuses the marking heuristic defined in [2] which improves its running\ntime in many practical problems."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                    "s : node": "Source node for the flow.",
                    "t : node": "Sink node for the flow.",
                    "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                    "residual : NetworkX graph": "Residual network on which the algorithm is to be executed. If None, a\nnew residual network is created. Default value: None.",
                    "value_only : bool": "If True compute only the value of the maximum flow. This parameter\nwill be ignored by this algorithm because it is not applicable.",
                    "cutoff : integer, float": "If specified, the algorithm will terminate when the flow value reaches\nor exceeds the cutoff. In this case, it may be unable to immediately\ndetermine a minimum cut. Default value: None."
                },
                "Returns:": {
                    "R : NetworkX DiGraph": "Residual network after computing the maximum flow."
                },
                "Raises:": {
                    "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                    "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                }
            },
            "Rubrics": {
                "Notes": "The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . If cutoff is not\nspecified, reachability to t using only edges (u,v) such\nthat R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut.",
                "References": "[1]Boykov, Y., & Kolmogorov, V. (2004). An experimental comparison\nof min-cut/max-flow algorithms for energy minimization in vision.\nPattern Analysis and Machine Intelligence, IEEE Transactions on,\n26(9), 1124-1137.https://doi.org/10.1109/TPAMI.2004.60  [2]Vladimir Kolmogorov. Graph-based Algorithms for Multi-camera\nReconstruction Problem. PhD thesis, Cornell University, CS Department,\n2003. pp. 109-114.https://web.archive.org/web/20170809091249/https://pub.ist.ac.at/~vnk/papers/thesis.pdf",
                "Examples": "fromnetworkx.algorithms.flowimportboykov_kolmogorov\nThe functions that implement flow algorithms and output a residual\nnetwork, such as this one, are not imported to the base NetworkX\nnamespace, so you have to explicitly import them from the flow package.\nG=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nR=boykov_kolmogorov(G,\"x\",\"y\")\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nflow_value==R.graph[\"flow_value\"]\n# True\nA nice feature of the Boykov-Kolmogorov algorithm is that a partition\nof the nodes that defines a minimum cut can be easily computed based\non the search trees used during the algorithm. These trees are stored\nin the graph attributetreesof the residual network.\nsource_tree,target_tree=R.graph[\"trees\"]\npartition=(set(source_tree),set(G)-set(source_tree))\nOr equivalently:\npartition=(set(G)-set(target_tree),set(target_tree))"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0->1,9) (0->2,3) (2->6,8) (2->4,1) (2->3,7) (2->14,3) (3->4,7) (3->7,4) (5->14,1) (5->10,7) (6->11,7) (7->13,4) (8->9,2) (8->15,3) (9->10,5) (14->15,6). What is the maximum flow from node 0 to node 11?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import boykov_kolmogorov\n\n# Define the graph structure\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15],\n    'Edges': [\n        {'from': 0, 'to': 1, 'weight': 9},\n        {'from': 0, 'to': 2, 'weight': 3},\n        {'from': 2, 'to': 6, 'weight': 8},\n        {'from': 2, 'to': 4, 'weight': 1},\n        {'from': 2, 'to': 3, 'weight': 7},\n        {'from': 2, 'to': 14, 'weight': 3},\n        {'from': 3, 'to': 4, 'weight': 7},\n        {'from': 3, 'to': 7, 'weight': 4},\n        {'from': 5, 'to': 14, 'weight': 1},\n        {'from': 5, 'to': 10, 'weight': 7},\n        {'from': 6, 'to': 11, 'weight': 7},\n        {'from': 7, 'to': 13, 'weight': 4},\n        {'from': 8, 'to': 9, 'weight': 2},\n        {'from': 8, 'to': 15, 'weight': 3},\n        {'from': 9, 'to': 10, 'weight': 5},\n        {'from': 14, 'to': 15, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 0\ntarget_node = 11\n\n# Compute the maximum flow using Boykov-Kolmogorov algorithm\nR = boykov_kolmogorov(G, source_node, target_node)\n\n# Get the maximum flow value\nmax_flow_value = R.graph['flow_value']\n\n# Output the maximum flow value\nprint(max_flow_value)",
                "key_api": "NetworkX (specifically the boykov_kolmogorov algorithm for maximum flow)",
                "key_experience": "1. Use directed graphs with clearly defined edges and capacities. 2. Keep data structures (like graph data) organized for easy manipulation. 3. Compute maximum flow using established algorithms to ensure performance and accuracy. 4. Output results clearly for easy interpretation."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 37, and the edges are: (0->4,7) (1->29,2) (1->5,10) (1->7,1) (1->6,9) (1->28,5) (1->36,9) (1->11,2) (2->9,1) (2->10,5) (2->3,8) (3->12,1) (3->21,3) (4->14,3) (4->8,7) (4->28,7) (4->11,7) (4->24,10) (5->13,6) (5->36,3) (5->18,8) (5->24,7) (5->19,10) (6->33,10) (7->26,10) (7->14,9) (7->31,3) (8->9,3) (8->15,6) (8->28,6) (8->10,6) (8->16,5) (8->19,2) (9->16,2) (9->15,2) (9->32,1) (9->17,10) (9->24,7) (10->37,7) (10->18,5) (10->25,9) (10->35,5) (10->34,4) (11->22,3) (11->35,1) (12->22,4) (12->34,9) (12->32,1) (12->16,4) (12->33,7) (13->22,10) (13->35,5) (14->26,9) (14->29,10) (14->22,10) (14->33,6) (15->35,9) (16->35,1) (16->17,6) (17->29,5) (17->36,9) (17->24,2) (19->27,8) (19->20,3) (20->29,8) (20->36,10) (20->32,5) (20->22,6) (20->37,4) (20->27,8) (22->35,3) (23->33,3) (24->36,1) (24->28,9) (25->28,5) (26->33,5) (27->31,4) (28->33,2). What is the maximum flow from node 2 to node 28?",
                "code": "import networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges along with their weights (capacity)\nedges = [\n    (0, 4, 7), (1, 29, 2), (1, 5, 10), (1, 7, 1), (1, 6, 9), (1, 28, 5),\n    (1, 36, 9), (1, 11, 2), (2, 9, 1), (2, 10, 5), (2, 3, 8), (3, 12, 1),\n    (3, 21, 3), (4, 14, 3), (4, 8, 7), (4, 28, 7), (4, 11, 7), (4, 24, 10),\n    (5, 13, 6), (5, 36, 3), (5, 18, 8), (5, 24, 7), (5, 19, 10), (6, 33, 10),\n    (7, 26, 10), (7, 14, 9), (7, 31, 3), (8, 9, 3), (8, 15, 6), (8, 28, 6),\n    (8, 10, 6), (8, 16, 5), (8, 19, 2), (9, 16, 2), (9, 15, 2), (9, 32, 1),\n    (9, 17, 10), (9, 24, 7), (10, 37, 7), (10, 18, 5), (10, 25, 9), (10, 35, 5),\n    (10, 34, 4), (11, 22, 3), (11, 35, 1), (12, 22, 4), (12, 34, 9), (12, 32, 1),\n    (12, 16, 4), (12, 33, 7), (13, 22, 10), (13, 35, 5), (14, 26, 9), (14, 29, 10),\n    (14, 22, 10), (14, 33, 6), (15, 35, 9), (16, 35, 1), (16, 17, 6), (17, 29, 5),\n    (17, 36, 9), (17, 24, 2), (19, 27, 8), (19, 20, 3), (20, 29, 8), (20, 36, 10),\n    (20, 32, 5), (20, 22, 6), (20, 37, 4), (20, 27, 8), (22, 35, 3), (23, 33, 3),\n    (24, 36, 1), (24, 28, 9), (25, 28, 5), (26, 33, 5), (27, 31, 4), (28, 33, 2)\n]\n\n# Add edges to the graph\nfor from_node, to_node, weight in edges:\n    G.add_edge(from_node, to_node, capacity=weight)\n\n# Define source and target nodes\nsource_node = 2\ntarget_node = 28\n\n# Calculate maximum flow using Boykov-Kolmogorov algorithm\nflow_value = nx.maximum_flow_value(G, source_node, target_node)\n\n# Output the maximum flow value\nprint(\"Maximum flow value from node {} to node {}: {}\".format(source_node, target_node, flow_value))",
                "key_api": "networkx.maximum_flow_value",
                "key_experience": "Using NetworkX efficiently defines directed graphs and computes maximum flow for specified nodes while ensuring clarity through well-structured code."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 33, and the edges are: (0->9,7) (1->17,3) (1->19,6) (1->5,6) (1->29,9) (1->30,2) (1->4,8) (2->32,7) (2->16,7) (2->14,9) (2->31,5) (2->27,10) (2->29,3) (2->10,1) (3->6,8) (4->20,8) (4->28,10) (4->32,3) (5->16,9) (5->30,5) (6->9,8) (6->19,6) (6->23,2) (6->20,10) (7->13,3) (7->14,3) (7->33,9) (7->25,4) (7->9,9) (7->16,7) (8->33,1) (8->14,9) (9->21,10) (9->30,6) (9->24,6) (10->12,3) (10->16,8) (11->26,2) (11->29,7) (11->22,1) (12->32,4) (12->29,7) (13->16,1) (13->23,2) (13->21,5) (13->24,8) (13->29,3) (14->25,9) (14->18,1) (14->29,7) (14->27,8) (15->33,4) (16->20,3) (16->24,3) (16->26,5) (16->21,3) (17->19,9) (17->28,6) (17->20,10) (18->28,3) (18->24,3) (19->25,6) (19->24,9) (19->32,7) (20->21,9) (20->27,7) (20->24,7) (21->30,3) (21->31,5) (21->26,6) (21->25,4) (22->32,4) (22->33,4) (23->31,10) (23->27,9) (23->32,8) (24->31,5) (24->27,1) (26->28,8) (27->33,1) (27->30,3) (28->31,10) (29->30,6). What is the maximum flow from node 7 to node 23?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import boykov_kolmogorov\n\n# Define the graph structure\ngraph_data = {\n    'Nodes': range(34),  # Nodes from 0 to 33\n    'Edges': [\n        {'from': 0, 'to': 9, 'weight': 7}, {'from': 1, 'to': 17, 'weight': 3},\n        {'from': 1, 'to': 19, 'weight': 6}, {'from': 1, 'to': 5, 'weight': 6},\n        {'from': 1, 'to': 29, 'weight': 9}, {'from': 1, 'to': 30, 'weight': 2},\n        {'from': 1, 'to': 4, 'weight': 8}, {'from': 2, 'to': 32, 'weight': 7},\n        {'from': 2, 'to': 16, 'weight': 7}, {'from': 2, 'to': 14, 'weight': 9},\n        {'from': 2, 'to': 31, 'weight': 5}, {'from': 2, 'to': 27, 'weight': 10},\n        {'from': 2, 'to': 29, 'weight': 3}, {'from': 2, 'to': 10, 'weight': 1},\n        {'from': 3, 'to': 6, 'weight': 8}, {'from': 4, 'to': 20, 'weight': 8},\n        {'from': 4, 'to': 28, 'weight': 10}, {'from': 4, 'to': 32, 'weight': 3},\n        {'from': 5, 'to': 16, 'weight': 9}, {'from': 5, 'to': 30, 'weight': 5},\n        {'from': 6, 'to': 9, 'weight': 8}, {'from': 6, 'to': 19, 'weight': 6},\n        {'from': 6, 'to': 23, 'weight': 2}, {'from': 6, 'to': 20, 'weight': 10},\n        {'from': 7, 'to': 13, 'weight': 3}, {'from': 7, 'to': 14, 'weight': 3},\n        {'from': 7, 'to': 33, 'weight': 9}, {'from': 7, 'to': 25, 'weight': 4},\n        {'from': 7, 'to': 9, 'weight': 9}, {'from': 7, 'to': 16, 'weight': 7},\n        {'from': 8, 'to': 33, 'weight': 1}, {'from': 8, 'to': 14, 'weight': 9},\n        {'from': 9, 'to': 21, 'weight': 10}, {'from': 9, 'to': 30, 'weight': 6},\n        {'from': 9, 'to': 24, 'weight': 6}, {'from': 10, 'to': 12, 'weight': 3},\n        {'from': 10, 'to': 16, 'weight': 8}, {'from': 11, 'to': 26, 'weight': 2},\n        {'from': 11, 'to': 29, 'weight': 7}, {'from': 11, 'to': 22, 'weight': 1},\n        {'from': 12, 'to': 32, 'weight': 4}, {'from': 12, 'to': 29, 'weight': 7},\n        {'from': 13, 'to': 16, 'weight': 1}, {'from': 13, 'to': 23, 'weight': 2},\n        {'from': 13, 'to': 21, 'weight': 5}, {'from': 13, 'to': 24, 'weight': 8},\n        {'from': 13, 'to': 29, 'weight': 3}, {'from': 14, 'to': 25, 'weight': 9},\n        {'from': 14, 'to': 18, 'weight': 1}, {'from': 14, 'to': 29, 'weight': 7},\n        {'from': 14, 'to': 27, 'weight': 8}, {'from': 15, 'to': 33, 'weight': 4},\n        {'from': 16, 'to': 20, 'weight': 3}, {'from': 16, 'to': 24, 'weight': 3},\n        {'from': 16, 'to': 26, 'weight': 5}, {'from': 16, 'to': 21, 'weight': 3},\n        {'from': 17, 'to': 19, 'weight': 9}, {'from': 17, 'to': 28, 'weight': 6},\n        {'from': 17, 'to': 20, 'weight': 10}, {'from': 18, 'to': 28, 'weight': 3},\n        {'from': 18, 'to': 24, 'weight': 3}, {'from': 19, 'to': 25, 'weight': 6},\n        {'from': 19, 'to': 24, 'weight': 9}, {'from': 19, 'to': 32, 'weight': 7},\n        {'from': 20, 'to': 21, 'weight': 9}, {'from': 20, 'to': 27, 'weight': 7},\n        {'from': 20, 'to': 24, 'weight': 7}, {'from': 21, 'to': 30, 'weight': 3},\n        {'from': 21, 'to': 31, 'weight': 5}, {'from': 21, 'to': 26, 'weight': 6},\n        {'from': 21, 'to': 25, 'weight': 4}, {'from': 22, 'to': 32, 'weight': 4},\n        {'from': 22, 'to': 33, 'weight': 4}, {'from': 23, 'to': 31, 'weight': 10},\n        {'from': 23, 'to': 27, 'weight': 9}, {'from': 23, 'to': 32, 'weight': 8},\n        {'from': 24, 'to': 31, 'weight': 5}, {'from': 24, 'to': 27, 'weight': 1},\n        {'from': 26, 'to': 28, 'weight': 8}, {'from': 27, 'to': 33, 'weight': 1},\n        {'from': 27, 'to': 30, 'weight': 3}, {'from': 28, 'to': 31, 'weight': 10},\n        {'from': 29, 'to': 30, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 7\ntarget_node = 23\n\n# Compute the maximum flow using the Boykov-Kolmogorov algorithm\nresidual_network = boykov_kolmogorov(G, source_node, target_node)\n\n# Get the flow value\nflow_value = residual_network.graph['flow_value']\n\n# Print the maximum flow value\nprint(f\"The maximum flow from node {source_node} to node {target_node} is: {flow_value}\")",
                "key_api": "networkx.algorithms.flow.boykov_kolmogorov",
                "key_experience": "Ensure to properly define the graph's structure with edges having 'capacity' attributes. Use directed graphs for flow analysis and clearly define source and target nodes to compute maximum flow effectively."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 49, and the edges are: (0->26,9) (0->44,4) (0->32,10) (0->14,1) (1->27,1) (1->33,7) (1->23,1) (1->24,2) (1->12,7) (1->11,1) (1->21,10) (1->5,5) (2->46,7) (2->31,10) (2->10,1) (2->14,8) (2->24,5) (2->25,9) (2->22,7) (2->32,3) (3->37,9) (3->35,8) (4->10,8) (4->31,1) (4->49,5) (5->41,7) (5->24,5) (5->25,1) (5->45,10) (6->43,10) (6->31,10) (6->29,2) (6->8,2) (6->18,10) (7->14,7) (7->12,9) (7->27,1) (7->43,5) (8->22,4) (9->11,8) (9->33,2) (9->47,3) (10->31,3) (11->23,10) (11->47,4) (11->14,5) (12->23,1) (12->36,3) (12->16,6) (13->31,6) (13->34,6) (13->43,2) (14->43,4) (14->39,1) (14->33,3) (15->25,7) (15->24,3) (15->18,10) (15->37,4) (16->40,7) (16->20,6) (16->43,9) (17->26,2) (17->33,3) (17->42,9) (17->45,10) (18->39,4) (18->31,7) (19->47,1) (19->46,4) (20->24,2) (20->45,5) (21->37,7) (21->24,9) (22->48,8) (22->26,7) (22->31,4) (22->43,5) (22->41,7) (23->45,4) (23->29,7) (23->43,4) (24->48,10) (24->36,1) (25->30,4) (25->33,1) (25->42,1) (26->28,8) (28->43,9) (29->40,8) (31->46,1) (34->46,8) (35->41,6) (37->43,9) (37->47,10) (39->40,10) (40->49,3) (40->41,9) (41->48,10) (42->44,2) (45->49,10). What is the maximum flow from node 15 to node 40?",
                "code": "import networkx as nx\nfrom networkx.algorithms.flow import boykov_kolmogorov\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges along with their weights (capacity)\nedges = [\n    {'from': 0, 'to': 26, 'weight': 9}, {'from': 0, 'to': 44, 'weight': 4},\n    {'from': 0, 'to': 32, 'weight': 10}, {'from': 0, 'to': 14, 'weight': 1},\n    {'from': 1, 'to': 27, 'weight': 1}, {'from': 1, 'to': 33, 'weight': 7},\n    {'from': 1, 'to': 23, 'weight': 1}, {'from': 1, 'to': 24, 'weight': 2},\n    {'from': 1, 'to': 12, 'weight': 7}, {'from': 1, 'to': 11, 'weight': 1},\n    {'from': 1, 'to': 21, 'weight': 10}, {'from': 1, 'to': 5, 'weight': 5},\n    {'from': 2, 'to': 46, 'weight': 7}, {'from': 2, 'to': 31, 'weight': 10},\n    {'from': 2, 'to': 10, 'weight': 1}, {'from': 2, 'to': 14, 'weight': 8},\n    {'from': 2, 'to': 24, 'weight': 5}, {'from': 2, 'to': 25, 'weight': 9},\n    {'from': 2, 'to': 22, 'weight': 7}, {'from': 2, 'to': 32, 'weight': 3},\n    {'from': 3, 'to': 37, 'weight': 9}, {'from': 3, 'to': 35, 'weight': 8},\n    {'from': 4, 'to': 10, 'weight': 8}, {'from': 4, 'to': 31, 'weight': 1},\n    {'from': 4, 'to': 49, 'weight': 5}, {'from': 5, 'to': 41, 'weight': 7},\n    {'from': 5, 'to': 24, 'weight': 5}, {'from': 5, 'to': 25, 'weight': 1},\n    {'from': 5, 'to': 45, 'weight': 10}, {'from': 6, 'to': 43, 'weight': 10},\n    {'from': 6, 'to': 31, 'weight': 10}, {'from': 6, 'to': 29, 'weight': 2},\n    {'from': 6, 'to': 8, 'weight': 2}, {'from': 6, 'to': 18, 'weight': 10},\n    {'from': 7, 'to': 14, 'weight': 7}, {'from': 7, 'to': 12, 'weight': 9},\n    {'from': 7, 'to': 27, 'weight': 1}, {'from': 7, 'to': 43, 'weight': 5},\n    {'from': 8, 'to': 22, 'weight': 4}, {'from': 9, 'to': 11, 'weight': 8},\n    {'from': 9, 'to': 33, 'weight': 2}, {'from': 9, 'to': 47, 'weight': 3},\n    {'from': 10, 'to': 31, 'weight': 3}, {'from': 11, 'to': 23, 'weight': 10},\n    {'from': 11, 'to': 47, 'weight': 4}, {'from': 11, 'to': 14, 'weight': 5},\n    {'from': 12, 'to': 23, 'weight': 1}, {'from': 12, 'to': 36, 'weight': 3},\n    {'from': 12, 'to': 16, 'weight': 6}, {'from': 13, 'to': 31, 'weight': 6},\n    {'from': 13, 'to': 34, 'weight': 6}, {'from': 13, 'to': 43, 'weight': 2},\n    {'from': 14, 'to': 43, 'weight': 4}, {'from': 14, 'to': 39, 'weight': 1},\n    {'from': 14, 'to': 33, 'weight': 3}, {'from': 15, 'to': 25, 'weight': 7},\n    {'from': 15, 'to': 24, 'weight': 3}, {'from': 15, 'to': 18, 'weight': 10},\n    {'from': 15, 'to': 37, 'weight': 4}, {'from': 16, 'to': 40, 'weight': 7},\n    {'from': 16, 'to': 20, 'weight': 6}, {'from': 16, 'to': 43, 'weight': 9},\n    {'from': 17, 'to': 26, 'weight': 2}, {'from': 17, 'to': 33, 'weight': 3},\n    {'from': 17, 'to': 42, 'weight': 9}, {'from': 17, 'to': 45, 'weight': 10},\n    {'from': 18, 'to': 39, 'weight': 4}, {'from': 18, 'to': 31, 'weight': 7},\n    {'from': 19, 'to': 47, 'weight': 1}, {'from': 19, 'to': 46, 'weight': 4},\n    {'from': 20, 'to': 24, 'weight': 2}, {'from': 20, 'to': 45, 'weight': 5},\n    {'from': 21, 'to': 37, 'weight': 7}, {'from': 21, 'to': 24, 'weight': 9},\n    {'from': 22, 'to': 48, 'weight': 8}, {'from': 22, 'to': 26, 'weight': 7},\n    {'from': 22, 'to': 31, 'weight': 4}, {'from': 22, 'to': 43, 'weight': 5},\n    {'from': 22, 'to': 41, 'weight': 7}, {'from': 23, 'to': 45, 'weight': 4},\n    {'from': 23, 'to': 29, 'weight': 7}, {'from': 23, 'to': 43, 'weight': 4},\n    {'from': 24, 'to': 48, 'weight': 10}, {'from': 24, 'to': 36, 'weight': 1},\n    {'from': 25, 'to': 30, 'weight': 4}, {'from': 25, 'to': 33, 'weight': 1},\n    {'from': 25, 'to': 42, 'weight': 1}, {'from': 26, 'to': 28, 'weight': 8},\n    {'from': 28, 'to': 43, 'weight': 9}, {'from': 29, 'to': 40, 'weight': 8},\n    {'from': 31, 'to': 46, 'weight': 1}, {'from': 34, 'to': 46, 'weight': 8},\n    {'from': 35, 'to': 41, 'weight': 6}, {'from': 37, 'to': 43, 'weight': 9},\n    {'from': 37, 'to': 47, 'weight': 10}, {'from': 39, 'to': 40, 'weight': 10},\n    {'from': 40, 'to': 49, 'weight': 3}, {'from': 40, 'to': 41, 'weight': 9},\n    {'from': 41, 'to': 48, 'weight': 10}, {'from': 42, 'to': 44, 'weight': 2},\n    {'from': 45, 'to': 49, 'weight': 10}\n]\n\n# Adding edges to the graph\nfor edge in edges:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 15\ntarget_node = 40\n\n# Calculate maximum flow using Boykov-Kolmogorov algorithm\nmax_flow_value = nx.maximum_flow_value(G, source_node, target_node)\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source_node} to node {target_node} is: {max_flow_value}\")",
                "key_api": "networkx.maximum_flow_value",
                "key_experience": "Utilize clear edge additions with capacity indicators during graph construction; ensure to define clear source and target nodes for flow calculations."
            }
        ]
    },
    {
        "id": 23,
        "problem": "Find the maximum flow between node 15 and node 40 in the directed graph.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience\n\nIn several coding tasks focused on calculating the maximum flow between two nodes in directed graphs, several important practices, key insights, and useful APIs were identified. Here's a consolidated summary:\n\n#### **Important Practices:**\n1. **Utilizing Efficient Libraries:**\n   - **NetworkX**: The NetworkX library proved to be instrumental for graph-related operations. Leveraging built-in functions like `DiGraph()`, `add_edge()`, and `maximum_flow_value()` ensures efficient implementation of maximum flow algorithms.\n\n2. **Data Structure Representation:**\n   - **Directed Graphs**: Properly using directed graphs (`DiGraph`) to model the problem is crucial. This involves correctly setting up nodes and edges with appropriate capacities and ensuring the graph reflects the structure described in the problem statement.\n\n3. **Edge Capacity Assignment:**\n   - **Explicit Capacity Setting**: Each edge's capacity must be explicitly set to its weight. This is fundamental because the maximum flow computation relies on these capacities.\n\n4. **Comprehensive Testing:**\n   - **Testing for Robustness**: It is vital to perform various tests to ensure the code handles different edge cases effectively. This could include testing with various node and edge configurations and boundary conditions.\n\n5. **Code Readability:**\n   - **Clear Variable Naming and Comments**: Clear and descriptive variable names (e.g., `source_node`, `target_node`, `G`) along with informative comments make the code easier to understand and maintain.\n\n6. **Structured Input Representation:**\n   - **Consistent Data Format**: Having a consistent data structure for nodes and edges facilitates easier manipulation and integration with graph libraries. For instance, using dictionaries for edge definitions and lists for nodes ensures ease and clarity in processing.\n\n#### **Key Insights:**\n1. **Graph Manipulation Efficiency:**\n   - NetworkX provides a straightforward way to model graphs and perform complex operations efficiently. This includes computing maximum flow values with a minimal amount of custom code.\n\n2. **Problem Solving with NetworkX:**\n   - The library's `maximum_flow_value` method is particularly useful, simplifying what would otherwise be a complex implementation if done manually. This underscores the power of leveraging well-maintained libraries.\n\n3. **Scalable Solutions:**\n   - These approaches are scalable to large graphs with numerous nodes and edges, as demonstrated in tasks involving nodes up to numbering in the fifties. Efficient graph algorithms make these solutions practical for real-world applications.\n\n4. **Clarity and Maintainability:**\n   - Implementing best practices in naming conventions and comments ensures that the codebase remains clear and maintainable, which is indispensable in collaborative environments or future revisits to the code.\n\n#### **Useful APIs:**\n1. **NetworkX Library:**\n   - **`nx.DiGraph()`**: Creates a directed graph object.\n   - **`G.add_edge(from_node, to_node, capacity=weight)`**: Adds a directed edge with a specified capacity(weight) between two nodes.\n   - **`nx.maximum_flow_value(G, source, target)`**: Computes the maximum flow value from source to target in the graph.\n\n### Conclusion\nThe primary takeaway is the significant utility of the NetworkX library for solving graph-based problems, particularly maximum flow computations. Utilizing directed graphs, careful capacity assignments, and clear, maintainable code practices are essential to efficiently and effectively solve these types of problems.",
        "rag_data": {
            "Section ID": "maximum_flow_value",
            "Description": [
                "Find the value of maximum single-commodity flow."
            ],
            "Field List": {
                "Parameters:": {
                    "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                    "_s : node": "Source node for the flow.",
                    "_t : node": "Sink node for the flow.",
                    "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                    "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                    "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
                },
                "Returns:": {
                    "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source."
                },
                "Raises:": {
                    "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                    "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                }
            },
            "Rubrics": {
                "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
                "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow_value computes only the value of the\nmaximum flow:\nflow_value=nx.maximum_flow_value(G,\"x\",\"y\")\nflow_value\n# 3.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow_value(G,\"x\",\"y\",flow_func=shortest_augmenting_path)\n# True"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 6, and the edges are: (0->3,8) (1->5,8) (1->4,7) (2->6,6) (2->4,5) (3->4,9) (3->5,5) (5->6,8). What is the maximum flow from node 0 to node 5?",
                "code": "import networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6],\n    'Edges': [\n        {'from': 0, 'to': 3, 'weight': 8},\n        {'from': 1, 'to': 5, 'weight': 8},\n        {'from': 1, 'to': 4, 'weight': 7},\n        {'from': 2, 'to': 6, 'weight': 6},\n        {'from': 2, 'to': 4, 'weight': 5},\n        {'from': 3, 'to': 4, 'weight': 9},\n        {'from': 3, 'to': 5, 'weight': 5},\n        {'from': 5, 'to': 6, 'weight': 8}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and sink nodes\nsource = 0\nsink = 5\n\n# Calculate the maximum flow from source to sink\nmax_flow_value = nx.maximum_flow_value(G, source, sink)\n\n# Output the maximum flow value\nprint(\"Maximum flow from node {} to node {}: {}\".format(source, sink, max_flow_value))",
                "key_api": "networkx.maximum_flow_value",
                "key_experience": "Utilize efficient data structures like directed graphs and ensure that edge capacities are properly assigned. Implementing comprehensive testing ensures that the code is robust and handles edge cases efficiently."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 15, and the edges are: (0->1,9) (0->2,3) (2->6,8) (2->4,1) (2->3,7) (2->14,3) (3->4,7) (3->7,4) (5->14,1) (5->10,7) (6->11,7) (7->13,4) (8->9,2) (8->15,3) (9->10,5) (14->15,6). What is the maximum flow from node 0 to node 11?",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 15],\n    'Edges': [\n        {'from': 0, 'to': 1, 'weight': 9},\n        {'from': 0, 'to': 2, 'weight': 3},\n        {'from': 2, 'to': 6, 'weight': 8},\n        {'from': 2, 'to': 4, 'weight': 1},\n        {'from': 2, 'to': 3, 'weight': 7},\n        {'from': 2, 'to': 14, 'weight': 3},\n        {'from': 3, 'to': 4, 'weight': 7},\n        {'from': 3, 'to': 7, 'weight': 4},\n        {'from': 5, 'to': 14, 'weight': 1},\n        {'from': 5, 'to': 10, 'weight': 7},\n        {'from': 6, 'to': 11, 'weight': 7},\n        {'from': 7, 'to': 13, 'weight': 4},\n        {'from': 8, 'to': 9, 'weight': 2},\n        {'from': 8, 'to': 15, 'weight': 3},\n        {'from': 9, 'to': 10, 'weight': 5},\n        {'from': 14, 'to': 15, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph with capacities\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 0\ntarget_node = 11\n\n# Calculate the maximum flow value\nmax_flow_value = nx.maximum_flow_value(G, _s=source_node, _t=target_node)\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source_node} to node {target_node} is: {max_flow_value}\")",
                "key_api": "networkx",
                "key_experience": "Using the NetworkX library for efficient graph manipulation, employing the 'DiGraph' class for directed graphs, and utilizing the 'maximum_flow_value()' method to compute the maximum flow between nodes."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 49, and the edges are: (0->26,9) (0->44,4) (0->32,10) (0->14,1) (1->27,1) (1->33,7) (1->23,1) (1->24,2) (1->12,7) (1->11,1) (1->21,10) (1->5,5) (2->46,7) (2->31,10) (2->10,1) (2->14,8) (2->24,5) (2->25,9) (2->22,7) (2->32,3) (3->37,9) (3->35,8) (4->10,8) (4->31,1) (4->49,5) (5->41,7) (5->24,5) (5->25,1) (5->45,10) (6->43,10) (6->31,10) (6->29,2) (6->8,2) (6->18,10) (7->14,7) (7->12,9) (7->27,1) (7->43,5) (8->22,4) (9->11,8) (9->33,2) (9->47,3) (10->31,3) (11->23,10) (11->47,4) (11->14,5) (12->23,1) (12->36,3) (12->16,6) (13->31,6) (13->34,6) (13->43,2) (14->43,4) (14->39,1) (14->33,3) (15->25,7) (15->24,3) (15->18,10) (15->37,4) (16->40,7) (16->20,6) (16->43,9) (17->26,2) (17->33,3) (17->42,9) (17->45,10) (18->39,4) (18->31,7) (19->47,1) (19->46,4) (20->24,2) (20->45,5) (21->37,7) (21->24,9) (22->48,8) (22->26,7) (22->31,4) (22->43,5) (22->41,7) (23->45,4) (23->29,7) (23->43,4) (24->48,10) (24->36,1) (25->30,4) (25->33,1) (25->42,1) (26->28,8) (28->43,9) (29->40,8) (31->46,1) (34->46,8) (35->41,6) (37->43,9) (37->47,10) (39->40,10) (40->49,3) (40->41,9) (41->48,10) (42->44,2) (45->49,10). What is the maximum flow from node 15 to node 40?",
                "code": "import networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges along with their capacities\nedges = [\n    (0, 26, 9), (0, 44, 4), (0, 32, 10), (0, 14, 1),\n    (1, 27, 1), (1, 33, 7), (1, 23, 1), (1, 24, 2),\n    (1, 12, 7), (1, 11, 1), (1, 21, 10), (1, 5, 5),\n    (2, 46, 7), (2, 31, 10), (2, 10, 1), (2, 14, 8),\n    (2, 24, 5), (2, 25, 9), (2, 22, 7), (2, 32, 3),\n    (3, 37, 9), (3, 35, 8), (4, 10, 8), (4, 31, 1),\n    (4, 49, 5), (5, 41, 7), (5, 24, 5), (5, 25, 1),\n    (5, 45, 10), (6, 43, 10), (6, 31, 10), (6, 29, 2),\n    (6, 8, 2), (6, 18, 10), (7, 14, 7), (7, 12, 9),\n    (7, 27, 1), (7, 43, 5), (8, 22, 4), (9, 11, 8),\n    (9, 33, 2), (9, 47, 3), (10, 31, 3), (11, 23, 10),\n    (11, 47, 4), (11, 14, 5), (12, 23, 1), (12, 36, 3),\n    (12, 16, 6), (13, 31, 6), (13, 34, 6), (13, 43, 2),\n    (14, 43, 4), (14, 39, 1), (14, 33, 3), (15, 25, 7),\n    (15, 24, 3), (15, 18, 10), (15, 37, 4), (16, 40, 7),\n    (16, 20, 6), (16, 43, 9), (17, 26, 2), (17, 33, 3),\n    (17, 42, 9), (17, 45, 10), (18, 39, 4), (18, 31, 7),\n    (19, 47, 1), (19, 46, 4), (20, 24, 2), (20, 45, 5),\n    (21, 37, 7), (21, 24, 9), (22, 48, 8), (22, 26, 7),\n    (22, 31, 4), (22, 43, 5), (22, 41, 7), (23, 45, 4),\n    (23, 29, 7), (23, 43, 4), (24, 48, 10), (24, 36, 1),\n    (25, 30, 4), (25, 33, 1), (25, 42, 1), (26, 28, 8),\n    (28, 43, 9), (29, 40, 8), (31, 46, 1), (34, 46, 8),\n    (35, 41, 6), (37, 43, 9), (37, 47, 10), (39, 40, 10),\n    (40, 49, 3), (40, 41, 9), (41, 48, 10), (42, 44, 2),\n    (45, 49, 10)\n]\n\n# Add edges to the graph with capacity\nfor from_node, to_node, weight in edges:\n    G.add_edge(from_node, to_node, capacity=weight)\n\n# Define source and target nodes\nsource_node = 15\ntarget_node = 40\n\n# Calculate the maximum flow value\nmax_flow_value, flow_dict = nx.maximum_flow(G, _s=source_node, _t=target_node)\n\n# Output the maximum flow value\nprint(\"Maximum flow value from node {} to node {}: {}\".format(source_node, target_node, max_flow_value))",
                "key_api": "networkx.maximum_flow",
                "key_experience": "Utilizing NetworkX for efficient graph analysis, particularly for maximum flow problems, by defining directed graphs, adding edges with capacity, and calculating the flow. Always ensure clear variable names and comments for better readability."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 37, and the edges are: (0->4,7) (1->29,2) (1->5,10) (1->7,1) (1->6,9) (1->28,5) (1->36,9) (1->11,2) (2->9,1) (2->10,5) (2->3,8) (3->12,1) (3->21,3) (4->14,3) (4->8,7) (4->28,7) (4->11,7) (4->24,10) (5->13,6) (5->36,3) (5->18,8) (5->24,7) (5->19,10) (6->33,10) (7->26,10) (7->14,9) (7->31,3) (8->9,3) (8->15,6) (8->28,6) (8->10,6) (8->16,5) (8->19,2) (9->16,2) (9->15,2) (9->32,1) (9->17,10) (9->24,7) (10->37,7) (10->18,5) (10->25,9) (10->35,5) (10->34,4) (11->22,3) (11->35,1) (12->22,4) (12->34,9) (12->32,1) (12->16,4) (12->33,7) (13->22,10) (13->35,5) (14->26,9) (14->29,10) (14->22,10) (14->33,6) (15->35,9) (16->35,1) (16->17,6) (17->29,5) (17->36,9) (17->24,2) (19->27,8) (19->20,3) (20->29,8) (20->36,10) (20->32,5) (20->22,6) (20->37,4) (20->27,8) (22->35,3) (23->33,3) (24->36,1) (24->28,9) (25->28,5) (26->33,5) (27->31,4) (28->33,2). What is the maximum flow from node 2 to node 28?",
                "code": "import networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges along with their weights as capacities\nedges = [\n    (0, 4, 7), (1, 29, 2), (1, 5, 10), (1, 7, 1), (1, 6, 9), \n    (1, 28, 5), (1, 36, 9), (1, 11, 2), (2, 9, 1), (2, 10, 5), \n    (2, 3, 8), (3, 12, 1), (3, 21, 3), (4, 14, 3), (4, 8, 7), \n    (4, 28, 7), (4, 11, 7), (4, 24, 10), (5, 13, 6), (5, 36, 3), \n    (5, 18, 8), (5, 24, 7), (5, 19, 10), (6, 33, 10), (7, 26, 10), \n    (7, 14, 9), (7, 31, 3), (8, 9, 3), (8, 15, 6), (8, 28, 6), \n    (8, 10, 6), (8, 16, 5), (8, 19, 2), (9, 16, 2), (9, 15, 2), \n    (9, 32, 1), (9, 17, 10), (9, 24, 7), (10, 37, 7), (10, 18, 5), \n    (10, 25, 9), (10, 35, 5), (10, 34, 4), (11, 22, 3), (11, 35, 1), \n    (12, 22, 4), (12, 34, 9), (12, 32, 1), (12, 16, 4), (12, 33, 7), \n    (13, 22, 10), (13, 35, 5), (14, 26, 9), (14, 29, 10), (14, 22, 10), \n    (14, 33, 6), (15, 35, 9), (16, 35, 1), (16, 17, 6), (17, 29, 5), \n    (17, 36, 9), (17, 24, 2), (19, 27, 8), (19, 20, 3), (20, 29, 8), \n    (20, 36, 10), (20, 32, 5), (20, 22, 6), (20, 37, 4), (20, 27, 8), \n    (22, 35, 3), (23, 33, 3), (24, 36, 1), (24, 28, 9), (25, 28, 5), \n    (26, 33, 5), (27, 31, 4), (28, 33, 2)\n]\n\n# Add edges to the graph\nfor from_node, to_node, weight in edges:\n    G.add_edge(from_node, to_node, capacity=weight)\n\n# Define source and target nodes\nsource = 2\ntarget = 28\n\n# Calculate the maximum flow value\nmax_flow_value = nx.maximum_flow_value(G, source, target)\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source} to node {target} is: {max_flow_value}\")",
                "key_api": "networkx",
                "key_experience": "Best practices include using well-structured graph data representation and clear variable naming for nodes and weights, utilizing NetworkX's built-in functions for maximum flow calculations, and providing clear output for results."
            },
            {
                "question": "Find the maximum flow between two nodes in a directed graph. In a directed graph, (i->j,k) means that node i and node j are connected with an directed edge from node i to node j with weight k. Given a graph and a pair of nodes, you need to output the maximum flow between the two nodes. Q: The nodes are numbered from 0 to 33, and the edges are: (0->9,7) (1->17,3) (1->19,6) (1->5,6) (1->29,9) (1->30,2) (1->4,8) (2->32,7) (2->16,7) (2->14,9) (2->31,5) (2->27,10) (2->29,3) (2->10,1) (3->6,8) (4->20,8) (4->28,10) (4->32,3) (5->16,9) (5->30,5) (6->9,8) (6->19,6) (6->23,2) (6->20,10) (7->13,3) (7->14,3) (7->33,9) (7->25,4) (7->9,9) (7->16,7) (8->33,1) (8->14,9) (9->21,10) (9->30,6) (9->24,6) (10->12,3) (10->16,8) (11->26,2) (11->29,7) (11->22,1) (12->32,4) (12->29,7) (13->16,1) (13->23,2) (13->21,5) (13->24,8) (13->29,3) (14->25,9) (14->18,1) (14->29,7) (14->27,8) (15->33,4) (16->20,3) (16->24,3) (16->26,5) (16->21,3) (17->19,9) (17->28,6) (17->20,10) (18->28,3) (18->24,3) (19->25,6) (19->24,9) (19->32,7) (20->21,9) (20->27,7) (20->24,7) (21->30,3) (21->31,5) (21->26,6) (21->25,4) (22->32,4) (22->33,4) (23->31,10) (23->27,9) (23->32,8) (24->31,5) (24->27,1) (26->28,8) (27->33,1) (27->30,3) (28->31,10) (29->30,6). What is the maximum flow from node 7 to node 23?",
                "code": "import networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': 34,\n    'Edges': [\n        {'from': 0, 'to': 9, 'weight': 7}, {'from': 1, 'to': 17, 'weight': 3},\n        {'from': 1, 'to': 19, 'weight': 6}, {'from': 1, 'to': 5, 'weight': 6},\n        {'from': 1, 'to': 29, 'weight': 9}, {'from': 1, 'to': 30, 'weight': 2},\n        {'from': 1, 'to': 4, 'weight': 8}, {'from': 2, 'to': 32, 'weight': 7},\n        {'from': 2, 'to': 16, 'weight': 7}, {'from': 2, 'to': 14, 'weight': 9},\n        {'from': 2, 'to': 31, 'weight': 5}, {'from': 2, 'to': 27, 'weight': 10},\n        {'from': 2, 'to': 29, 'weight': 3}, {'from': 2, 'to': 10, 'weight': 1},\n        {'from': 3, 'to': 6, 'weight': 8}, {'from': 4, 'to': 20, 'weight': 8},\n        {'from': 4, 'to': 28, 'weight': 10}, {'from': 4, 'to': 32, 'weight': 3},\n        {'from': 5, 'to': 16, 'weight': 9}, {'from': 5, 'to': 30, 'weight': 5},\n        {'from': 6, 'to': 9, 'weight': 8}, {'from': 6, 'to': 19, 'weight': 6},\n        {'from': 6, 'to': 23, 'weight': 2}, {'from': 6, 'to': 20, 'weight': 10},\n        {'from': 7, 'to': 13, 'weight': 3}, {'from': 7, 'to': 14, 'weight': 3},\n        {'from': 7, 'to': 33, 'weight': 9}, {'from': 7, 'to': 25, 'weight': 4},\n        {'from': 7, 'to': 9, 'weight': 9}, {'from': 7, 'to': 16, 'weight': 7},\n        {'from': 8, 'to': 33, 'weight': 1}, {'from': 8, 'to': 14, 'weight': 9},\n        {'from': 9, 'to': 21, 'weight': 10}, {'from': 9, 'to': 30, 'weight': 6},\n        {'from': 9, 'to': 24, 'weight': 6}, {'from': 10, 'to': 12, 'weight': 3},\n        {'from': 10, 'to': 16, 'weight': 8}, {'from': 11, 'to': 26, 'weight': 2},\n        {'from': 11, 'to': 29, 'weight': 7}, {'from': 11, 'to': 22, 'weight': 1},\n        {'from': 12, 'to': 32, 'weight': 4}, {'from': 12, 'to': 29, 'weight': 7},\n        {'from': 13, 'to': 16, 'weight': 1}, {'from': 13, 'to': 23, 'weight': 2},\n        {'from': 13, 'to': 21, 'weight': 5}, {'from': 13, 'to': 24, 'weight': 8},\n        {'from': 13, 'to': 29, 'weight': 3}, {'from': 14, 'to': 25, 'weight': 9},\n        {'from': 14, 'to': 18, 'weight': 1}, {'from': 14, 'to': 29, 'weight': 7},\n        {'from': 14, 'to': 27, 'weight': 8}, {'from': 15, 'to': 33, 'weight': 4},\n        {'from': 16, 'to': 20, 'weight': 3}, {'from': 16, 'to': 24, 'weight': 3},\n        {'from': 16, 'to': 26, 'weight': 5}, {'from': 16, 'to': 21, 'weight': 3},\n        {'from': 17, 'to': 19, 'weight': 9}, {'from': 17, 'to': 28, 'weight': 6},\n        {'from': 17, 'to': 20, 'weight': 10}, {'from': 18, 'to': 28, 'weight': 3},\n        {'from': 18, 'to': 24, 'weight': 3}, {'from': 19, 'to': 25, 'weight': 6},\n        {'from': 19, 'to': 24, 'weight': 9}, {'from': 19, 'to': 32, 'weight': 7},\n        {'from': 20, 'to': 21, 'weight': 9}, {'from': 20, 'to': 27, 'weight': 7},\n        {'from': 20, 'to': 24, 'weight': 7}, {'from': 21, 'to': 30, 'weight': 3},\n        {'from': 21, 'to': 31, 'weight': 5}, {'from': 21, 'to': 26, 'weight': 6},\n        {'from': 21, 'to': 25, 'weight': 4}, {'from': 22, 'to': 32, 'weight': 4},\n        {'from': 22, 'to': 33, 'weight': 4}, {'from': 23, 'to': 31, 'weight': 10},\n        {'from': 23, 'to': 27, 'weight': 9}, {'from': 23, 'to': 32, 'weight': 8},\n        {'from': 24, 'to': 31, 'weight': 5}, {'from': 24, 'to': 27, 'weight': 1},\n        {'from': 26, 'to': 28, 'weight': 8}, {'from': 27, 'to': 33, 'weight': 1},\n        {'from': 27, 'to': 30, 'weight': 3}, {'from': 28, 'to': 31, 'weight': 10},\n        {'from': 29, 'to': 30, 'weight': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['weight'])\n\n# Define source and target nodes\nsource_node = 7\ntarget_node = 23\n\n# Calculate the maximum flow value\nmax_flow_value = nx.maximum_flow_value(G, source=source_node, target=target_node)\n\n# Output the maximum flow value\nprint(\"Maximum flow value from node {} to node {}: {}\".format(source_node, target_node, max_flow_value))",
                "key_api": "networkx.maximum_flow_value",
                "key_experience": "Utilizing NetworkX, a powerful library that provides efficient implementations of graph algorithms, particularly for handling the maximum flow problem effectively, along with best practices of defining edge capacities and building directed graphs."
            }
        ]
    },
    {
        "id": 24,
        "problem": "Determine whether the given directed graph is bipartite.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience\n\n#### Most Important Practices:\n1. **Graph Conversion**: Always convert directed graphs to undirected graphs before checking for properties like bipartiteness. Bipartiteness is defined for undirected graphs, so this step is crucial for accurate analysis.\n2. **Efficient Graph Representation**: Utilize libraries like NetworkX for handling and analyzing graphs. Functions such as `nx.DiGraph()` are highly efficient for creating and managing directed graphs.\n3. **Clear Code Structure**: Maintain clear and structured code flow. This includes using descriptive variable names, proper indentation, and modular functions to enhance readability and maintainability.\n4. **Input Parsing**: Ensure that input data is parsed correctly. Use functions like `map()` for converting strings to integers and for any necessary data transformation.\n\n#### Key Insights:\n1. **NetworkX Utility**: The NetworkX library is immensely powerful and simplifies many complex tasks related to graph theory and analysis. The function `nx.is_bipartite` is particularly useful for determining if a graph is bipartite.\n2. **Graph Analysis**: Creating graphs using NetworkX's `DiGraph` and then converting to undirected graphs (`G.to_undirected()`) when necessary is an effective way to analyze properties like bipartiteness.\n3. **Handling Large Graphs**: The experience of working with small to large numbers of nodes (from as few as 6 up to 76) reinforces the importance of efficient algorithms and data structures for handling larger datasets without performance delays.\n\n#### Useful APIs and Methods:\n1. **`nx.DiGraph()`**:\n   - Used for creating directed graphs.\n   - Syntax: `G = nx.DiGraph()`\n\n2. **`G.add_nodes_from(nodes)`**:\n   - Efficiently adds multiple nodes to a graph.\n   - Syntax: `G.add_nodes_from([list_of_nodes])`\n\n3. **`G.add_edges_from(edges)`**:\n   - Adds multiple edges to the graph.\n   - Syntax: `G.add_edges_from([(u, v), (x, y), ...])`\n\n4. **`G.to_undirected()`**:\n   - Converts a directed graph to an undirected graph.\n   - Syntax: `G_undirected = G.to_undirected()`\n\n5. **`nx.is_bipartite(G)`**:\n   - Checks if a graph is bipartite.\n   - Syntax: `is_bipartite = nx.is_bipartite(G)`\n\n6. **Python's `map()` Function**:\n   - Useful for transforming input data, particularly for converting strings to integers.\n   - Syntax: `u, v = map(int, edge.strip('[]').split('->'))`\n\n#### Conclusion:\nWorking with directed graphs to check for bipartiteness involves critical steps of transforming the graph data and utilizing efficient algorithms provided by libraries like NetworkX. By adhering to structured programming practices and understanding when to convert graph types, developers can perform accurate and efficient graph analyses.",
        "rag_data": {
            "Section ID": "is_bipartite",
            "Description": [
                "Returns True if graph G is bipartite, False if not."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX graph": ""
                }
            },
            "Rubrics": {
                "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)\nprint(bipartite.is_bipartite(G))\n# True"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether or not a graph is bipartite. In a directed graph, (i->j) means that node i and node j are connected with an directed edge from node i to node j. Given a graph, you need to output Yes or No, indicating whether the graph is bipartite. Q: The nodes are numbered from 0 to 5, and the edges are: (2->4) (0->2) (1->5) (0->5) (4->5) (0->4) (2->5) (0->1) (3->5). Is this graph bipartite?",
                "code": "import networkx as nx\n\ndef is_bipartite_graph(nodes, edges):\n    # Create a directed graph\n    G = nx.DiGraph()\n    \n    # Add nodes to the graph\n    G.add_nodes_from(nodes)\n    \n    # Add edges to the graph\n    for edge in edges:\n        G.add_edge(edge['from'], edge['to'])\n    \n    # Check if the graph is bipartite\n    is_bipartite = nx.is_bipartite(G.to_undirected())  # Convert to undirected for bipartite check\n    return \"Yes\" if is_bipartite else \"No\"\n\n# Input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5],\n    'Edges': [\n        {'from': 2, 'to': 4},\n        {'from': 0, 'to': 2},\n        {'from': 1, 'to': 5},\n        {'from': 0, 'to': 5},\n        {'from': 4, 'to': 5},\n        {'from': 0, 'to': 4},\n        {'from': 2, 'to': 5},\n        {'from': 0, 'to': 1},\n        {'from': 3, 'to': 5}\n    ]\n}\n\n# Execute the function and print the result\nresult = is_bipartite_graph(input_data['Nodes'], input_data['Edges'])\nprint(result)",
                "key_api": "networkx",
                "key_experience": "Utilize functions like DiGraph() and is_bipartite() to create and analyze graphs efficiently. Convert directed graphs to undirected when checking for bipartiteness."
            },
            {
                "question": "Determine whether or not a graph is bipartite. In a directed graph, (i->j) means that node i and node j are connected with an directed edge from node i to node j. Given a graph, you need to output Yes or No, indicating whether the graph is bipartite. Q: The nodes are numbered from 0 to 63, and the edges are: (33->53) (7->45) (16->37) (13->39) (9->13) (1->36) (9->30) (16->27) (28->55) (27->45) (6->14) (38->61) (25->44) (14->20) (7->52) (18->44) (29->35) (10->40) (18->41) (32->57) (28->49) (42->49) (5->19) (15->32) (8->38) (23->35) (10->16) (22->24) (17->21) (4->58) (40->52) (47->59) (43->51) (29->38) (9->59) (4->52) (23->25) (50->63) (53->55) (38->58) (16->34) (49->54) (19->32) (16->20) (25->32) (27->54) (59->62) (22->32) (18->27) (56->59) (45->51) (36->59) (10->34) (47->50) (37->57) (28->42) (26->46) (3->14) (10->42) (12->61) (17->49) (37->50) (6->63) (21->55) (31->40) (1->45) (7->23) (33->41) (17->26) (41->48) (27->35) (48->54) (13->30) (0->3) (25->31) (6->50) (21->31) (24->41) (46->54) (10->31) (14->26) (27->28) (44->47) (60->61) (5->24) (29->42) (32->37) (0->43) (11->22) (59->60) (53->57) (31->48) (39->55) (9->21) (32->54) (8->32) (41->62) (35->60) (30->33) (23->36) (5->57) (30->60) (42->52) (5->45) (49->63) (16->41) (26->32) (25->39) (50->53) (7->19) (18->43) (21->36) (20->61) (34->62) (9->10) (36->39) (30->48) (14->19) (3->12) (24->34) (33->49) (35->40) (26->60) (28->48) (5->42) (32->34) (5->40) (3->36) (24->26) (17->54) (26->45) (28->45) (21->60) (17->46) (7->11) (5->14) (12->19) (50->57) (23->34) (10->52) (1->44) (30->39) (7->9) (19->55) (31->41) (12->41) (18->56) (8->23) (40->53) (8->63) (31->58) (32->47) (32->49) (0->56) (37->49) (27->58) (40->45) (12->36) (26->51) (10->41) (32->51) (2->58) (6->11) (59->61) (24->44) (4->47) (5->33) (7->46) (1->60) (19->49) (29->39) (5->43) (55->59) (5->15) (25->51) (28->34) (25->37) (52->58) (11->19) (47->57) (31->47) (46->58) (8->34) (6->15) (15->27) (32->40) (12->43) (9->61) (55->57) (14->32) (29->62) (5->52) (21->32) (8->33) (40->48) (4->42) (24->61) (24->38) (30->45) (4->22) (36->63) (33->51) (9->47) (3->52) (31->57) (12->26) (42->58) (23->42) (62->63) (0->46) (40->56) (48->52) (7->27) (20->29) (14->62) (21->49) (21->41) (25->40) (51->53) (13->18) (19->28) (15->37) (15->31) (36->50) (48->63) (20->50) (26->50) (0->26) (41->60) (16->23) (18->34) (9->56) (27->37) (3->24) (4->39) (7->59) (51->60) (36->56) (8->9) (23->55) (24->63) (12->57) (13->58) (37->62) (0->14) (20->54) (36->60) (13->36) (0->50) (35->51) (36->41) (13->45) (8->53) (16->48) (30->58) (24->40) (11->51) (1->12) (1->34) (45->47) (21->47) (0->63) (28->35) (24->32) (26->47) (20->48) (21->30) (54->63) (36->40) (36->45) (33->35) (49->50) (30->35) (13->22) (11->60) (31->46) (53->63) (9->23) (17->35) (33->38) (4->35) (27->46) (19->40) (43->52) (38->62) (10->30) (1->25) (9->12) (32->61) (10->35) (31->34) (43->60) (40->46) (28->43) (15->53) (19->36) (41->44) (28->37) (22->38) (8->59) (14->41) (29->32) (17->47) (6->16) (2->28) (16->50). Is this graph bipartite?",
                "code": "import networkx as nx\n\n# Input data\ninput_data = {\n    'Nodes': '0 to 63',\n    'Edges': [\n        '[33->53]', '[7->45]', '[16->37]', '[13->39]', '[9->13]', '[1->36]', \n        '[9->30]', '[16->27]', '[28->55]', '[27->45]', '[6->14]', '[38->61]', \n        '[25->44]', '[14->20]', '[7->52]', '[18->44]', '[29->35]', '[10->40]', \n        '[18->41]', '[32->57]', '[28->49]', '[42->49]', '[5->19]', '[15->32]', \n        '[8->38]', '[23->35]', '[10->16]', '[22->24]', '[17->21]', '[4->58]', \n        '[40->52]', '[47->59]', '[43->51]', '[29->38]', '[9->59]', '[4->52]', \n        '[23->25]', '[50->63]', '[53->55]', '[38->58]', '[16->34]', '[49->54]', \n        '[19->32]', '[16->20]', '[25->32]', '[27->54]', '[59->62]', '[22->32]', \n        '[18->27]', '[56->59]', '[45->51]', '[36->59]', '[10->34]', '[47->50]', \n        '[37->57]', '[28->42]', '[26->46]', '[3->14]', '[10->42]', '[12->61]', \n        '[17->49]', '[37->50]', '[6->63]', '[21->55]', '[31->40]', '[1->45]', \n        '[7->23]', '[33->41]', '[17->26]', '[41->48]', '[27->35]', '[48->54]', \n        '[13->30]', '[0->3]', '[25->31]', '[6->50]', '[21->31]', '[24->41]', \n        '[46->54]', '[10->31]', '[14->26]', '[27->28]', '[44->47]', '[60->61]', \n        '[5->24]', '[29->42]', '[32->37]', '[0->43]', '[11->22]', '[59->60]', \n        '[53->57]', '[31->48]', '[39->55]', '[9->21]', '[32->54]', '[8->32]', \n        '[41->62]', '[35->60]', '[30->33]', '[23->36]', '[5->57]', '[30->60]', \n        '[42->52]', '[5->45]', '[49->63]', '[16->41]', '[26->32]', '[25->39]', \n        '[50->53]', '[7->19]', '[18->43]', '[21->36]', '[20->61]', '[34->62]', \n        '[9->10]', '[36->39]', '[30->48]', '[14->19]', '[3->12]', '[24->34]', \n        '[33->49]', '[35->40]', '[26->60]', '[28->48]', '[5->42]', '[32->34]', \n        '[5->40]', '[3->36]', '[24->26]', '[17->54]', '[26->45]', '[28->45]', \n        '[21->60]', '[17->46]', '[7->11]', '[5->14]', '[12->19]', '[50->57]', \n        '[23->34]', '[10->52]', '[1->44]', '[30->39]', '[7->9]', '[19->55]', \n        '[31->41]', '[12->41]', '[18->56]', '[8->23]', '[40->53]', '[8->63]', \n        '[31->58]', '[32->47]', '[32->49]', '[0->56]', '[37->49]', '[27->58]', \n        '[40->45]', '[12->36]', '[26->51]', '[10->41]', '[32->51]', '[2->58]', \n        '[6->11]', '[59->61]', '[24->44]', '[4->47]', '[5->33]', '[7->46]', \n        '[1->60]', '[19->49]', '[5->43]', '[55->59]', '[5->15]', '[25->51]', \n        '[28->34]', '[25->37]', '[52->58]', '[11->19]', '[47->57]', '[31->47]', \n        '[46->58]', '[8->34]', '[6->15]', '[15->27]', '[32->40]', '[12->43]', \n        '[9->61]', '[55->57]', '[14->32]', '[29->62]', '[5->52]', '[21->32]', \n        '[8->33]', '[40->48]', '[4->42]', '[24->61]', '[24->38]', '[30->45]', \n        '[4->22]', '[36->63]', '[33->51]', '[9->47]', '[3->52]', '[31->57]', \n        '[12->26]', '[42->58]', '[23->42]', '[62->63]', '[0->46]', '[40->56]', \n        '[48->52]', '[7->27]', '[20->29]', '[14->62]', '[21->49]', '[21->41]', \n        '[25->40]', '[51->53]', '[13->18]', '[19->28]', '[15->37]', '[15->31]', \n        '[36->50]', '[48->63]', '[20->50]', '[26->50]', '[0->26]', '[41->60]', \n        '[16->23]', '[18->34]', '[9->56]', '[27->37]', '[3->24]', '[4->39]', \n        '[7->59]', '[51->60]', '[36->56]', '[8->9]', '[23->55]', '[24->63]', \n        '[12->57]', '[13->58]', '[37->62]', '[0->14]', '[20->54]', '[36->60]', \n        '[13->36]', '[0->50]', '[35->51]', '[36->41]', '[13->45]', '[8->53]', \n        '[16->48]', '[30->58]', '[24->40]', '[11->51]', '[1->12]', '[1->34]', \n        '[45->47]', '[21->47]', '[0->63]', '[28->35]', '[24->32]', '[26->47]', \n        '[20->48]', '[21->30]', '[54->63]', '[36->40]', '[36->45]', '[33->35]', \n        '[49->50]', '[30->35]', '[13->22]', '[11->60]', '[31->46]', '[53->63]', \n        '[9->23]', '[17->35]', '[33->38]', '[4->35]', '[27->46]', '[19->40]', \n        '[43->52]', '[38->62]', '[10->30]', '[1->25]', '[9->12]', '[32->61]', \n        '[10->35]', '[31->34]', '[43->60]', '[40->46]', '[28->43]', '[15->53]', \n        '[19->36]', '[41->44]', '[28->37]', '[22->38]', '[8->59]', '[14->41]', \n        '[29->32]', '[17->47]', '[6->16]', '[2->28]', '[16->50]'\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    # Extracting the nodes from the edge string\n    u, v = map(int, edge.strip('[]').split('->'))\n    G.add_edge(u, v)\n\n# Check if the graph is bipartite\nis_bipartite = nx.is_bipartite(G)\n\n# Output result\nprint(\"Yes\" if is_bipartite else \"No\")",
                "key_api": "networkx.is_bipartite",
                "key_experience": "1. Use libraries such as NetworkX for efficient graph manipulation. 2. Ensure inputs are correctly parsed; use `map` for string to integer conversion. 3. Maintain clear variable names and structured flow to enhance code readability."
            },
            {
                "question": "Determine whether or not a graph is bipartite. In a directed graph, (i->j) means that node i and node j are connected with an directed edge from node i to node j. Given a graph, you need to output Yes or No, indicating whether the graph is bipartite. Q: The nodes are numbered from 0 to 76, and the edges are: (18->62) (51->58) (3->9) (9->43) (8->54) (59->75) (10->53) (60->70) (39->50) (22->74) (1->12) (43->58) (31->58) (39->70) (70->74) (5->61) (3->17) (19->33) (37->69) (14->41) (28->56) (33->51) (21->51) (61->75) (6->62) (16->33) (25->71) (17->64) (6->18) (16->26) (46->73) (31->59) (1->2) (47->74) (7->75) (9->72) (43->67) (63->74) (29->69) (16->54) (55->76) (5->9) (8->57) (8->60) (35->49) (9->40) (1->72) (9->21) (68->71) (19->72) (28->52) (10->16) (47->59) (4->6) (20->39) (45->50) (28->48) (20->65) (46->75) (47->72) (57->67) (28->33) (37->72) (2->17) (6->61) (2->73) (32->37) (3->6) (50->75) (54->62) (51->76) (9->71) (8->36) (6->38) (45->76) (0->4) (36->56) (38->73) (38->62) (31->52) (12->69) (14->33) (4->23) (54->66) (6->34) (9->57) (14->39) (33->34) (4->56) (36->74) (1->23) (0->7) (20->66) (23->38) (25->34) (33->38) (56->69) (5->14) (11->35) (21->54) (5->48) (55->70) (10->14) (72->74) (3->14) (21->64) (7->34) (60->65) (4->18) (13->44) (14->69) (57->59) (55->64) (56->61) (14->55) (28->42) (27->65) (1->16) (15->74) (16->37) (61->73) (7->35) (2->6) (5->59) (41->57) (0->21) (20->71) (16->56) (20->59) (32->53) (28->61) (37->48) (11->21) (0->54) (24->42) (10->73) (4->63) (18->22) (66->70) (31->65) (16->62) (7->51) (30->48) (40->50) (10->65) (62->64) (0->66) (16->65) (12->27) (12->75) (15->20) (64->74) (16->27) (21->38) (3->16) (0->59) (36->41) (22->34) (14->48) (40->70) (6->19) (17->49) (29->73) (33->62) (18->25) (33->49) (36->71) (32->39) (2->22) (4->13) (22->48) (62->67) (20->72) (9->22) (4->62) (33->76) (12->70) (15->54) (59->72) (56->74) (32->72) (11->15) (0->11) (52->69) (45->49) (7->48) (35->62) (2->76) (60->64) (61->74) (64->72) (5->47) (39->40) (6->65) (30->42) (28->73) (27->48) (41->54) (36->47) (10->50) (15->51) (9->20) (37->58) (46->58) (32->46) (11->24) (13->27) (35->43) (14->44) (3->39) (23->65) (0->32) (4->66) (17->30) (32->34) (37->42) (10->63) (0->70) (3->70) (5->41) (0->50) (23->59) (2->36) (19->29) (67->73) (72->73) (15->26) (29->39) (9->60) (38->75) (14->34) (0->57) (8->53) (3->5) (22->55) (4->33) (15->39) (18->36) (8->43) (42->69) (36->66) (23->31) (34->66) (67->69) (55->67) (24->69) (55->59) (30->43) (5->39) (57->76) (14->18) (6->8) (22->31) (47->50) (22->69) (16->24) (16->18) (35->56) (3->45) (32->36) (6->51) (43->71) (5->58) (21->26) (2->30) (1->66) (1->7) (52->53) (57->74) (6->20) (8->44) (12->52) (13->74) (22->52) (46->56) (17->53) (21->76) (20->25) (0->62) (19->49) (9->31) (30->64) (9->49) (12->51) (64->71) (2->52) (6->50) (57->68) (56->75) (16->71) (34->58) (53->74) (47->62) (6->66) (24->72) (17->45) (22->71) (57->62) (51->72) (12->50) (18->69) (46->49) (23->66) (44->52) (3->28) (25->37) (6->71) (32->70) (18->20) (9->76) (7->70) (73->74) (30->60) (29->61) (3->20) (1->29) (24->25) (60->71) (4->8) (6->76) (1->10) (52->73) (50->72) (14->15) (18->58) (3->29) (9->63) (20->46) (36->60) (12->65) (11->59) (31->49) (7->12) (21->46) (50->62) (57->72) (11->25) (15->68) (17->55) (49->63) (18->65) (42->75) (58->60) (27->57) (22->36). Is this graph bipartite?",
                "code": "import networkx as nx\n\n# Input data\ninput_data = {\n    'Nodes': '0 to 76',\n    'Edges': [\n        '[18->62]', '[51->58]', '[3->9]', '[9->43]', '[8->54]', \n        '[59->75]', '[10->53]', '[60->70]', '[39->50]', '[22->74]', \n        '[1->12]', '[43->58]', '[31->58]', '[39->70]', '[70->74]', \n        '[5->61]', '[3->17]', '[19->33]', '[37->69]', '[14->41]', \n        '[28->56]', '[33->51]', '[21->51]', '[61->75]', '[6->62]', \n        '[16->33]', '[25->71]', '[17->64]', '[6->18]', '[16->26]', \n        '[46->73]', '[31->59]', '[1->2]', '[47->74]', '[7->75]', \n        '[9->72]', '[43->67]', '[63->74]', '[29->69]', '[16->54]', \n        '[55->76]', '[5->9]', '[8->57]', '[8->60]', '[35->49]', \n        '[9->40]', '[1->72]', '[9->21]', '[68->71]', '[19->72]', \n        '[28->52]', '[10->16]', '[47->59]', '[4->6]', '[20->39]', \n        '[45->50]', '[28->48]', '[20->65]', '[46->75]', '[47->72]', \n        '[57->67]', '[28->33]', '[37->72]', '[2->17]', '[6->61]', \n        '[2->73]', '[32->37]', '[3->6]', '[50->75]', '[54->62]', \n        '[51->76]', '[9->71]', '[8->36]', '[6->38]', '[45->76]', \n        '[0->4]', '[36->56]', '[38->73]', '[38->62]', '[31->52]', \n        '[12->69]', '[14->33]', '[4->23]', '[54->66]', '[6->34]', \n        '[9->57]', '[14->39]', '[33->34]', '[4->56]', '[36->74]', \n        '[1->23]', '[0->7]', '[20->66]', '[23->38]', '[25->34]', \n        '[33->38]', '[56->69]', '[5->14]', '[11->35]', '[21->54]', \n        '[5->48]', '[55->70]', '[10->14]', '[72->74]', '[3->14]', \n        '[21->64]', '[7->34]', '[60->65]', '[4->18]', '[13->44]', \n        '[14->69]', '[57->59]', '[55->64]', '[56->61]', '[14->55]', \n        '[28->42]', '[27->65]', '[1->16]', '[15->74]', '[16->37]', \n        '[61->73]', '[7->35]', '[2->6]', '[5->59]', '[41->57]', \n        '[0->21]', '[20->71]', '[16->56]', '[20->59]', '[32->53]', \n        '[28->61]', '[37->48]', '[11->21]', '[0->54]', '[24->42]', \n        '[10->73]', '[4->63]', '[18->22]', '[66->70]', '[31->65]', \n        '[16->62]', '[7->51]', '[30->48]', '[40->50]', '[10->65]', \n        '[62->64]', '[0->66]', '[16->65]', '[12->27]', '[12->75]', \n        '[15->20]', '[64->74]', '[16->27]', '[21->38]', '[3->16]', \n        '[0->59]', '[36->41]', '[22->34]', '[14->48]', '[40->70]', \n        '[6->19]', '[17->49]', '[29->73]', '[33->62]', '[18->25]', \n        '[33->49]', '[36->71]', '[32->39]', '[2->22]', '[4->13]', \n        '[22->48]', '[62->67]', '[20->72]', '[9->22]', '[4->62]', \n        '[33->76]', '[12->70]', '[15->54]', '[59->72]', '[56->74]', \n        '[32->72]', '[11->15]', '[0->11]', '[52->69]', '[45->49]', \n        '[7->48]', '[35->62]', '[2->76]', '[60->64]', '[61->74]', \n        '[64->72]', '[5->47]', '[39->40]', '[6->65]', '[30->42]', \n        '[28->73]', '[27->48]', '[41->54]', '[36->47]', '[10->50]', \n        '[15->51]', '[9->20]', '[37->58]', '[46->58]', '[32->46]', \n        '[11->24]', '[13->27]', '[35->43]', '[14->44]', '[3->39]', \n        '[23->65]', '[0->32]', '[4->66]', '[17->30]', '[32->34]', \n        '[37->42]', '[10->63]', '[0->70]', '[3->70]', '[5->41]', \n        '[0->50]', '[23->59]', '[2->36]', '[19->29]', '[67->73]', \n        '[72->73]', '[15->26]', '[29->39]', '[9->60]', '[38->75]', \n        '[14->34]', '[0->57]', '[8->53]', '[3->5]', '[22->55]', \n        '[4->33]', '[15->39]', '[18->36]', '[8->43]', '[42->69]', \n        '[36->66]', '[23->31]', '[34->66]', '[67->69]', '[55->67]', \n        '[24->69]', '[55->59]', '[30->43]', '[5->39]', '[57->76]', \n        '[14->18]', '[6->8]', '[22->31]', '[47->50]', '[22->69]', \n        '[16->24]', '[16->18]', '[35->56]', '[3->45]', '[32->36]', \n        '[6->51]', '[43->71]', '[5->58]', '[21->26]', '[2->30]', \n        '[1->66]', '[1->7]', '[52->53]', '[57->74]', '[6->20]', \n        '[8->44]', '[12->52]', '[13->74]', '[22->52]', '[46->56]', \n        '[17->53]', '[21->76]', '[20->25]', '[0->62]', '[19->49]', \n        '[9->31]', '[30->64]', '[9->49]', '[12->51]', '[64->71]', \n        '[2->52]', '[6->50]', '[57->68]', '[56->75]', '[16->71]', \n        '[34->58]', '[53->74]', '[47->62]', '[6->66]', '[24->72]', \n        '[17->45]', '[22->71]', '[57->62]', '[51->72]', '[12->50]', \n        '[18->69]', '[46->49]', '[23->66]', '[44->52]', '[3->28]', \n        '[25->37]', '[6->71]', '[32->70]', '[18->20]', '[9->76]', \n        '[7->70]', '[73->74]', '[30->60]', '[29->61]', '[3->20]', \n        '[1->29]', '[24->25]', '[60->71]', '[4->8]', '[6->76]', \n        '[1->10]', '[52->73]', '[50->72]', '[14->15]', '[18->58]', \n        '[3->29]', '[9->63]', '[20->46]', '[36->60]', '[12->65]', \n        '[11->59]', '[31->49]', '[7->12]', '[21->46]', '[50->62]', \n        '[57->72]', '[11->25]', '[15->68]', '[17->55]', '[49->63]', \n        '[18->65]', '[42->75]', '[58->60]', '[27->57]', '[22->36]'\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    # Parse the edge string to extract nodes\n    u, v = map(int, edge.strip('[]').split('->'))\n    G.add_edge(u, v)\n\n# Check if the graph is bipartite\nis_bipartite = nx.is_bipartite(G)\n\n# Output result\nprint(\"Yes\" if is_bipartite else \"No\")",
                "key_api": "networkx",
                "key_experience": "Utilizing built-in functions of libraries, such as `nx.is_bipartite()` for efficiently checking if a graph is bipartite, and `nx.DiGraph()` for creating directed graphs. Ensure to parse input data correctly and follow structured coding to improve readability and maintainability."
            }
        ]
    },
    {
        "id": 25,
        "problem": "Determine whether the given directed graph is bipartite.",
        "graph_type": "directed",
        "experience": "### Summary of Key Experiences, Practices, and Insights from Multiple Coding Tasks:\n\n#### **Key Practices:**\n\n1. **Graph Representation:**\n   - Consistently use the NetworkX library to model and manipulate graphs, owing to its extensive and efficient API for graph-related operations.\n   - Ensure the creation of directed graphs appropriately using `nx.DiGraph()`, then converting or checking bipartiteness using `nx.is_bipartite()`.\n\n2. **Data Structure & Input Handling:**\n   - Define input nodes and edges clearly to ensure accurate processing.\n   - Properly parse and extract nodes from edge strings using `map(int, edge.strip('[]').split('->'))`.\n\n3. **Input Validation:**\n   - Validate inputs to check for correct formats and structure before processing.\n   - Properly handle large datasets by ensuring edge and node counts are manageable within memory constraints.\n\n4. **Code Structure & Modularity:**\n   - Use functions to encapsulate graph operations for modularity and readability.\n   - Review and document functions logically to facilitate understanding and debugging.\n\n5. **Output Formatting:**\n   - Ensure a clear and user-friendly output format, such as returning \"Yes\" or \"No\" for bipartiteness checks.\n\n#### **Key Insights:**\n\n1. **Efficiency with NetworkX:**\n   - NetworkX library provides robust and extensive support for graph operations, making complex tasks like bipartite checking straightforward.\n   - Leveraging built-in methods such as `add_edge` and `is_bipartite` can greatly enhance development speed and code reliability.\n\n2. **Handling Directed Graphs:**\n   - When checking for bipartiteness in directed graphs, consider converting to undirected graphs or appropriately using NetworkX methods designed for such tasks.\n\n3. **Scalability:**\n   - Efficient handling of large-scale node and edge data is crucial. NetworkX's optimization allows performing operations on large graphs relatively quickly.\n\n4. **Documentation and Clarity:**\n   - Well-documented code, including input definitions and logical structure, remains critical for maintainability and collaboration.\n\n#### **Useful APIs and Methods:**\n\n1. **NetworkX Library:**\n   - `nx.DiGraph()`: Create a directed graph.\n   - `nx.is_bipartite(G)`: Check if a graph G is bipartite.\n   - `G.add_nodes_from(nodes)`: Add multiple nodes to a graph.\n   - `G.add_edge(u, v)`: Add an edge from node u to node v.\n\n2. **Python Standard Library:**\n   - `map(int, string.split(delimiter))`: Useful for extracting integers from strings.\n   - List comprehensions and dictionary operations for efficient data manipulation.\n\n### Conclusion:\nThe use of well-documented, widely-used libraries like NetworkX for graph operations significantly enhances implementation efficiency, readability, and robustness. Modular code structure and thorough input validation stand out as crucial practices especially in handling detailed tasks like determining graph bipartiteness.",
        "rag_data": {},
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine whether or not a graph is bipartite. In a directed graph, (i->j) means that node i and node j are connected with an directed edge from node i to node j. Given a graph, you need to output Yes or No, indicating whether the graph is bipartite. Q: The nodes are numbered from 0 to 5, and the edges are: (2->4) (0->2) (1->5) (0->5) (4->5) (0->4) (2->5) (0->1) (3->5). Is this graph bipartite?",
                "code": "import networkx as nx\n\ndef is_bipartite_graph(nodes, edges):\n    # Create a directed graph\n    G = nx.DiGraph()\n    \n    # Add nodes to the graph\n    G.add_nodes_from(nodes)\n    \n    # Add edges to the graph\n    for edge in edges:\n        G.add_edge(edge['from'], edge['to'])\n    \n    # Check if the graph is bipartite\n    is_bipartite = nx.is_bipartite(G)\n    \n    return \"Yes\" if is_bipartite else \"No\"\n\n# Input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5],\n    'Edges': [\n        {'from': 2, 'to': 4}, \n        {'from': 0, 'to': 2}, \n        {'from': 1, 'to': 5}, \n        {'from': 0, 'to': 5}, \n        {'from': 4, 'to': 5}, \n        {'from': 0, 'to': 4}, \n        {'from': 2, 'to': 5}, \n        {'from': 0, 'to': 1}, \n        {'from': 3, 'to': 5}\n    ]\n}\n\n# Determine if the graph is bipartite\nresult = is_bipartite_graph(input_data['Nodes'], input_data['Edges'])\nprint(result)",
                "key_api": "networkx.is_bipartite",
                "key_experience": "Utilize appropriate graph representations and algorithms; ensure the graph is converted to undirected when checking bipartiteness; validate input data structures before processing."
            },
            {
                "question": "Determine whether or not a graph is bipartite. In a directed graph, (i->j) means that node i and node j are connected with an directed edge from node i to node j. Given a graph, you need to output Yes or No, indicating whether the graph is bipartite. Q: The nodes are numbered from 0 to 60, and the edges are: (23->42) (3->27) (2->32) (43->52) (11->30) (4->17) (12->15) (16->59) (14->43) (23->56) (34->37) (4->25) (9->49) (35->53) (12->56) (6->41) (8->50) (17->39) (33->43) (8->60) (25->45) (23->40) (11->41) (44->55) (1->42) (2->28) (3->30) (30->41) (54->56) (1->46) (1->7) (19->56) (27->41) (21->53) (26->34) (26->28) (27->33) (40->43) (44->59) (15->35) (2->56) (11->31) (3->59) (20->34) (3->43) (17->30) (1->53) (22->58) (3->10) (20->46) (8->44) (35->60) (10->19) (18->49) (33->54) (6->59) (24->44) (11->33) (16->27) (18->55) (30->50) (30->46) (0->40) (2->57) (5->30) (4->16) (34->50) (29->51) (5->53) (4->33) (20->22) (33->50) (17->56) (19->52) (5->46) (11->20) (45->47) (51->59) (21->43) (1->39) (15->26) (19->40) (7->34) (20->24) (34->36) (28->53) (33->35) (15->29) (30->52) (45->55) (18->32) (35->52) (1->55) (28->30) (9->53) (23->54) (19->51) (7->15) (19->57) (52->54) (6->10) (6->39) (23->37) (11->60) (17->43) (43->54) (1->11) (28->55) (23->35) (3->11) (24->40) (13->20) (7->25) (16->57) (23->38) (31->36) (39->51) (3->38) (0->45) (7->26) (34->44) (14->41) (11->57) (17->36) (7->53) (5->17) (24->55) (20->48) (12->22) (8->46) (32->43) (24->57) (41->53) (26->59) (12->44) (26->47) (35->50) (20->60) (37->38) (4->43) (28->57) (11->32) (16->32) (4->37) (47->54) (6->13) (27->58) (20->38) (29->31) (28->35) (22->45) (8->25) (27->50) (27->55) (28->50) (2->31) (15->57) (30->48) (1->19) (4->27) (6->49) (32->34) (27->28) (31->44) (1->15) (14->24) (43->57) (48->55) (9->44) (52->59) (18->42) (21->58) (14->37) (7->38) (45->48) (2->33) (40->41) (57->60) (6->17) (20->43) (7->33) (41->51) (19->60) (11->58) (18->25) (8->52) (37->47) (5->52) (16->29) (33->49) (2->54) (7->16) (10->25) (34->55) (25->32) (40->48) (5->32) (3->39) (10->39) (3->44) (30->31) (4->7) (21->45) (21->32) (7->31) (5->51) (24->31) (33->42) (8->38) (14->28). Is this graph bipartite?",
                "code": "import networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': '0 to 60',\n    'Edges': [\n        '[23->42]', '[3->27]', '[2->32]', '[43->52]', '[11->30]', '[4->17]', \n        '[12->15]', '[16->59]', '[14->43]', '[23->56]', '[34->37]', '[4->25]', \n        '[9->49]', '[35->53]', '[12->56]', '[6->41]', '[8->50]', '[17->39]', \n        '[33->43]', '[8->60]', '[25->45]', '[23->40]', '[11->41]', '[44->55]', \n        '[1->42]', '[2->28]', '[3->30]', '[30->41]', '[54->56]', '[1->46]', \n        '[1->7]', '[19->56]', '[27->41]', '[21->53]', '[26->34]', '[26->28]', \n        '[27->33]', '[40->43]', '[44->59]', '[15->35]', '[2->56]', '[11->31]', \n        '[3->59]', '[20->34]', '[3->43]', '[17->30]', '[1->53]', '[22->58]', \n        '[3->10]', '[20->46]', '[8->44]', '[35->60]', '[10->19]', '[18->49]', \n        '[33->54]', '[6->59]', '[24->44]', '[11->33]', '[16->27]', '[18->55]', \n        '[30->50]', '[30->46]', '[0->40]', '[2->57]', '[5->30]', '[4->16]', \n        '[34->50]', '[29->51]', '[5->53]', '[4->33]', '[20->22]', '[33->50]', \n        '[17->56]', '[19->52]', '[5->46]', '[11->20]', '[45->47]', '[51->59]', \n        '[21->43]', '[1->39]', '[15->26]', '[19->40]', '[7->34]', '[20->24]', \n        '[34->36]', '[28->53]', '[33->35]', '[15->29]', '[30->52]', '[45->55]', \n        '[18->32]', '[35->52]', '[1->55]', '[28->30]', '[9->53]', '[23->54]', \n        '[19->51]', '[7->15]', '[19->57]', '[52->54]', '[6->10]', '[6->39]', \n        '[23->37]', '[11->60]', '[17->43]', '[43->54]', '[1->11]', '[28->55]', \n        '[23->35]', '[3->11]', '[24->40]', '[13->20]', '[7->25]', '[16->57]', \n        '[23->38]', '[31->36]', '[39->51]', '[3->38]', '[0->45]', '[7->26]', \n        '[34->44]', '[14->41]', '[11->57]', '[17->36]', '[7->53]', '[5->17]', \n        '[24->55]', '[20->48]', '[12->22]', '[8->46]', '[32->43]', '[24->57]', \n        '[41->53]', '[26->59]', '[12->44]', '[26->47]', '[35->50]', '[20->60]', \n        '[37->38]', '[4->43]', '[28->57]', '[11->32]', '[16->32]', '[4->37]', \n        '[47->54]', '[6->13]', '[27->58]', '[20->38]', '[29->31]', '[28->35]', \n        '[22->45]', '[8->25]', '[27->50]', '[27->55]', '[28->50]', '[2->31]', \n        '[15->57]', '[30->48]', '[1->19]', '[4->27]', '[6->49]', '[32->34]', \n        '[27->28]', '[31->44]', '[1->15]', '[14->24]', '[43->57]', '[48->55]', \n        '[9->44]', '[52->59]', '[18->42]', '[21->58]', '[14->37]', '[7->38]', \n        '[45->48]', '[2->33]', '[40->41]', '[57->60]', '[6->17]', '[20->43]', \n        '[7->33]', '[41->51]', '[19->60]', '[11->58]', '[18->25]', '[8->52]', \n        '[37->47]', '[5->52]', '[16->29]', '[33->49]', '[2->54]', '[7->16]', \n        '[10->25]', '[34->55]', '[25->32]', '[40->48]', '[5->32]', '[3->39]', \n        '[10->39]', '[3->44]', '[30->31]', '[4->7]', '[21->45]', '[21->32]', \n        '[7->31]', '[5->51]', '[24->31]', '[33->42]', '[8->38]', '[14->28]'\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    # Extracting the nodes from the edge string\n    u, v = map(int, edge.strip('[]').split('->'))\n    G.add_edge(u, v)\n\n# Check if the graph is bipartite\nis_bipartite = nx.is_bipartite(G)\n\n# Output the result\nprint(\"Yes\" if is_bipartite else \"No\")",
                "key_api": "networkx.is_bipartite",
                "key_experience": "Utilized NetworkX for efficient graph handling and bipartite checking; ensured clear structure by defining input data and functions; documented the code logically to facilitate understanding."
            }
        ]
    },
    {
        "id": 26,
        "problem": "Find one of the topology sorting paths of the given directed graph.",
        "graph_type": "directed",
        "experience": "### Summary of Overall Experience\n\n#### Important Practices:\n1. **Effective Use of Libraries**:\n   - Throughout all tasks, the NetworkX library was crucial for graph operations such as creating directed graphs and performing topological sorting.\n   - The library's `nx.DiGraph()` method simplifies creating a directed graph, and `nx.topological_sort(G)` efficiently performs topological sorting.\n\n2. **Error Handling**:\n   - Each task included a try-except block to handle cases where the graph is not a Directed Acyclic Graph (DAG). This was done using the `nx.NetworkXUnfeasible` exception to provide meaningful feedback when a topological sort is not possible.\n\n3. **Input Data Structuring and Normalization**:\n   - Input data was consistently structured into dictionaries with keys for nodes and edges.\n   - Edges were often provided in string format and required parsing to extract individual nodes. This was handled using string manipulation methods such as `strip` and `split`.\n\n4. **Code Readability and Maintainability**:\n   - Clear variable names and comments improved the readability of the code.\n   - Consistent formatting of input data and modular approach to adding nodes and edges contributed to maintaining clean and understandable code.\n\n#### Key Insights:\n1. **Topological Sorting**:\n   - Topological sorting is only possible on DAGs, making it essential to verify that the graph meets this criterion.\n   - Topological sorting is often used for scheduling tasks, resolving dependencies, and ordering problems where certain order constraints exist.\n\n2. **Graph Theory Applications**:\n   - Understanding of directed graphs and their properties was reinforced in practical application scenarios.\n   - NetworkX functions greatly simplified complex graph manipulations, highlighting the efficiency and utility of using specialized libraries for such tasks.\n\n3. **Graph Traversal**:\n   - Although not explicitly mentioned, knowledge of graph traversal techniques is implicit in understanding how topological sorts check and follow directed edges to determine order.\n\n#### Useful APIs:\n1. **NetworkX Library**:\n   - `nx.DiGraph()`: Create a directed graph.\n   - `nx.topological_sort(G)`: Perform topological sorting on the graph `G`.\n   - `nx.NetworkXUnfeasible`: Exception raised when a graph is not a DAG and cannot be topologically sorted.\n\n2. **String Manipulation**:\n   - `strip`, `split`: Used extensively for parsing input edge definitions provided as strings to extract individual node connections.\n   \n### Conclusion\nThis set of tasks emphasized the importance of using specialized libraries like NetworkX for handling graph-related problems efficiently. Key practices such as error handling, input data structuring, and code readability were crucial in achieving reliable and maintainable solutions. These experiences provided deep insights into practical applications of graph theory and topological sorting algorithms.",
        "rag_data": {
            "Section ID": "topological_sort",
            "Description": [
                "Returns a generator of nodes in topologically sorted order.",
                "A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles."
            ],
            "Field List": {
                "Parameters:": {
                    "G : NetworkX digraph": "A directed acyclic graph (DAG)"
                },
                "Yields:": {
                    "nodes": "Yields the nodes in topological sorted order."
                },
                "Raises:": {
                    "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                    "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                    "RuntimeError": "IfGis changed while the returned iterator is being processed."
                }
            },
            "Rubrics": {
                "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
                "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
                "Examples": "To get the reverse order of the topological sort:\nDG=nx.DiGraph([(1,2),(2,3)])\nlist(reversed(list(nx.topological_sort(DG))))\n# [3, 2, 1]\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwithnetworkx.line_graph()as follows:\nlist(nx.topological_sort(nx.line_graph(DG)))\n# [(1, 2), (2, 3)]"
            }
        },
        "accuracy": 1.0,
        "example": [
            {
                "question": "Find one of the topology sorting paths of the given graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph, you need to output one of the topology sorting paths of the graph. Q: The nodes are numbered from 0 to 4, and the edges are: (1->4) (3->0) (0->2) (3->2) (3->1) (4->0). Give one topology sorting path of this graph.",
                "code": "import networkx as nx\n\n# Input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4],\n    'Edges': [\n        {'from': 1, 'to': 4},\n        {'from': 3, 'to': 0},\n        {'from': 0, 'to': 2},\n        {'from': 3, 'to': 2},\n        {'from': 3, 'to': 1},\n        {'from': 4, 'to': 0}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes to the graph\nG.add_nodes_from(input_data['Nodes'])\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'])\n\n# Perform topological sort\ntry:\n    topological_order = list(nx.topological_sort(G))\n    print(\"One topological sorting path:\", topological_order)\nexcept nx.NetworkXUnfeasible:\n    print(\"The graph is not a directed acyclic graph (DAG), so topological sorting is not possible.\")",
                "key_api": "networkx",
                "key_experience": "Utilized the nx.topological_sort function to efficiently perform topological sorting on directed graphs, ensuring that appropriate error handling was implemented for acyclic checks."
            },
            {
                "question": "Find one of the topology sorting paths of the given graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph, you need to output one of the topology sorting paths of the graph. Q: The nodes are numbered from 0 to 22, and the edges are: (2->5) (12->0) (2->20) (15->3) (8->5) (0->10) (18->6) (20->0) (13->1) (21->18) (12->1) (2->14) (17->3) (7->18) (11->7) (3->6) (19->5) (19->18) (9->0) (20->19) (2->16) (5->1) (15->11) (12->4) (4->16) (13->7) (5->6) (8->16) (0->19) (5->21) (2->3) (11->19) (17->4) (14->5) (19->10) (2->11) (22->6) (9->22) (9->3) (16->13) (13->21) (1->7) (22->16) (11->3) (9->18) (3->18) (13->6) (12->16) (15->9) (22->13) (12->5) (22->5) (17->8) (1->18) (20->12) (21->1) (9->12) (17->21) (15->1) (17->14) (15->5) (11->16) (4->19) (22->7) (3->21) (11->13) (10->16) (13->18) (3->1) (9->16) (15->21) (17->11) (5->16) (3->0) (22->18) (8->6) (8->1) (5->10) (9->17) (8->18) (2->6) (14->18) (11->18) (16->6) (22->11) (11->21) (20->3) (9->19) (1->6) (15->17) (17->16) (4->8) (17->19) (17->2) (12->6) (14->8) (17->22) (8->0) (8->3) (12->8) (14->7) (7->6) (11->6) (9->21) (12->7) (0->13) (21->7) (16->1) (15->20) (20->1) (14->22) (12->21) (19->16) (15->0) (19->1) (9->7) (14->19) (2->1) (19->21) (11->20) (3->5) (19->7). Give one topology sorting path of this graph.",
                "code": "import networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': '0 to 22',\n    'Edges': [\n        '[2->5]', '[12->0]', '[2->20]', '[15->3]', '[8->5]', '[0->10]', \n        '[18->6]', '[20->0]', '[13->1]', '[21->18]', '[12->1]', '[2->14]', \n        '[17->3]', '[7->18]', '[11->7]', '[3->6]', '[19->5]', '[19->18]', \n        '[9->0]', '[20->19]', '[2->16]', '[5->1]', '[15->11]', '[12->4]', \n        '[4->16]', '[13->7]', '[5->6]', '[8->16]', '[0->19]', '[5->21]', \n        '[2->3]', '[11->19]', '[17->4]', '[14->5]', '[19->10]', '[2->11]', \n        '[22->6]', '[9->22]', '[9->3]', '[16->13]', '[13->21]', '[1->7]', \n        '[22->16]', '[11->3]', '[9->18]', '[3->18]', '[13->6]', '[12->16]', \n        '[15->9]', '[22->13]', '[12->5]', '[22->5]', '[17->8]', '[1->18]', \n        '[20->12]', '[21->1]', '[9->12]', '[17->21]', '[15->1]', '[17->14]', \n        '[15->5]', '[11->16]', '[4->19]', '[22->7]', '[3->21]', '[11->13]', \n        '[10->16]', '[13->18]', '[3->1]', '[9->16]', '[15->21]', '[17->11]', \n        '[5->16]', '[3->0]', '[22->18]', '[8->6]', '[8->1]', '[5->10]', \n        '[9->17]', '[8->18]', '[2->6]', '[14->18]', '[11->18]', '[16->6]', \n        '[22->11]', '[11->21]', '[20->3]', '[9->19]', '[1->6]', '[15->17]', \n        '[17->16]', '[4->8]', '[17->19]', '[17->2]', '[12->6]', '[14->8]', \n        '[17->22]', '[8->0]', '[8->3]', '[12->8]', '[14->7]', '[7->6]', \n        '[11->6]', '[9->21]', '[12->7]', '[0->13]', '[21->7]', '[16->1]', \n        '[15->20]', '[20->1]', '[14->22]', '[12->21]', '[19->16]', '[15->0]', \n        '[19->1]', '[9->7]', '[14->19]', '[2->1]', '[19->21]', '[11->20]', \n        '[3->5]', '[19->7]'\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    # Extracting the nodes from the string format '[u->v]'\n    u, v = map(int, edge.strip('[]').split('->'))\n    G.add_edge(u, v)\n\n# Perform topological sort\ntry:\n    topological_order = list(nx.topological_sort(G))\n    print(\"One topological sorting path of the graph:\", topological_order)\nexcept nx.NetworkXUnfeasible:\n    print(\"The graph is not a Directed Acyclic Graph (DAG); topological sorting is not possible.\")",
                "key_api": "networkx.topological_sort",
                "key_experience": "Utilizing NetworkX for graph operations, including creating directed graphs and performing topological sorts. Effective exception handling for non-DAG cases, enhancing code reliability. Clear structuring of input data and extraction of edges promotes code readability and maintainability."
            },
            {
                "question": "Find one of the topology sorting paths of the given graph. In a directed graph, (i->j) means that node i and node j are connected with a directed edge from node i to node j. Given a graph, you need to output one of the topology sorting paths of the graph. Q: The nodes are numbered from 0 to 19, and the edges are: (17->3) (17->16) (17->11) (17->8) (17->0) (17->5) (17->6) (17->19) (17->15) (17->7) (17->1) (17->4) (17->10) (17->14) (17->9) (3->9) (3->10) (3->11) (3->7) (3->2) (3->5) (3->14) (3->4) (3->12) (3->16) (3->8) (3->15) (3->19) (9->18) (9->5) (9->8) (9->0) (9->11) (9->2) (9->10) (9->19) (9->7) (9->14) (9->15) (9->13) (9->4) (9->16) (9->1) (9->12) (18->10) (18->12) (18->1) (18->19) (18->7) (18->5) (18->2) (18->11) (18->15) (18->6) (18->8) (10->13) (10->6) (10->4) (10->8) (10->15) (10->5) (10->19) (10->2) (10->11) (10->1) (10->14) (10->7) (10->0) (10->16) (13->7) (13->1) (13->19) (13->5) (13->2) (13->0) (13->8) (13->4) (13->14) (7->0) (7->5) (7->2) (7->11) (7->15) (7->12) (7->19) (7->8) (7->16) (7->4) (7->6) (0->11) (0->6) (0->12) (0->5) (0->16) (0->15) (0->4) (0->8) (0->1) (0->14) (0->19) (11->6) (11->5) (11->16) (11->14) (11->19) (11->12) (11->15) (11->2) (6->19) (6->15) (6->5) (6->4) (6->16) (6->8) (6->14) (6->1) (6->2) (6->12) (19->1) (19->4) (19->14) (19->15) (19->5) (19->16) (19->8) (1->16) (1->5) (1->2) (1->8) (1->14) (1->15) (1->12) (16->14) (16->8) (16->2) (16->5) (16->4) (16->12) (14->12) (14->8) (14->4) (14->2) (14->5) (12->15) (12->8) (12->4) (12->5) (15->8) (15->4) (15->2) (15->5) (8->4) (8->5) (8->2) (4->2) (2->5). Give one topology sorting path of this graph.",
                "code": "import networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': '0 to 19',\n    'Edges': [\n        '[17->3]', '[17->16]', '[17->11]', '[17->8]', '[17->0]', '[17->5]', \n        '[17->6]', '[17->19]', '[17->15]', '[17->7]', '[17->1]', '[17->4]', \n        '[17->10]', '[17->14]', '[17->9]', '[3->9]', '[3->10]', '[3->11]', \n        '[3->7]', '[3->2]', '[3->5]', '[3->14]', '[3->4]', '[3->12]', \n        '[3->16]', '[3->8]', '[3->15]', '[3->19]', '[9->18]', '[9->5]', \n        '[9->8]', '[9->0]', '[9->11]', '[9->2]', '[9->10]', '[9->19]', \n        '[9->7]', '[9->14]', '[9->15]', '[9->13]', '[9->4]', '[9->16]', \n        '[9->1]', '[9->12]', '[18->10]', '[18->12]', '[18->1]', '[18->19]', \n        '[18->7]', '[18->5]', '[18->2]', '[18->11]', '[18->15]', '[18->6]', \n        '[18->8]', '[10->13]', '[10->6]', '[10->4]', '[10->8]', '[10->15]', \n        '[10->5]', '[10->19]', '[10->2]', '[10->11]', '[10->1]', '[10->14]', \n        '[10->7]', '[10->0]', '[10->16]', '[13->7]', '[13->1]', '[13->19]', \n        '[13->5]', '[13->2]', '[13->0]', '[13->8]', '[13->4]', '[13->14]', \n        '[7->0]', '[7->5]', '[7->2]', '[7->11]', '[7->15]', '[7->12]', \n        '[7->19]', '[7->8]', '[7->16]', '[7->4]', '[7->6]', '[0->11]', \n        '[0->6]', '[0->12]', '[0->5]', '[0->16]', '[0->15]', '[0->4]', \n        '[0->8]', '[0->1]', '[0->14]', '[0->19]', '[11->6]', '[11->5]', \n        '[11->16]', '[11->14]', '[11->19]', '[11->12]', '[11->15]', \n        '[11->2]', '[6->19]', '[6->15]', '[6->5]', '[6->4]', '[6->16]', \n        '[6->8]', '[6->14]', '[6->1]', '[6->2]', '[6->12]', '[19->1]', \n        '[19->4]', '[19->14]', '[19->15]', '[19->5]', '[19->16]', \n        '[19->8]', '[1->16]', '[1->5]', '[1->2]', '[1->8]', '[1->14]', \n        '[1->15]', '[1->12]', '[16->14]', '[16->8]', '[16->2]', \n        '[16->5]', '[16->4]', '[16->12]', '[14->12]', '[14->8]', \n        '[14->4]', '[14->2]', '[14->5]', '[12->15]', '[12->8]', \n        '[12->4]', '[12->5]', '[15->8]', '[15->4]', '[15->2]', \n        '[15->5]', '[8->4]', '[8->5]', '[8->2]', '[4->2]', '[2->5]'\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    # Remove brackets and split by '->'\n    u, v = edge.strip('[]').split('->')\n    G.add_edge(int(u), int(v))\n\n# Perform topological sort\ntry:\n    topological_order = list(nx.topological_sort(G))\n    print(\"One topological sorting path:\", topological_order)\nexcept nx.NetworkXUnfeasible:\n    print(\"The graph is not a Directed Acyclic Graph (DAG), so topological sorting is not possible.\")",
                "key_api": "networkx (specifically nx.DiGraph and nx.topological_sort)",
                "key_experience": "1. Utilize networkx for graph representation and manipulation, which provides built-in methods to create directed graphs and perform topological sorting efficiently. 2. Handle exceptions properly to manage cases where a topological sort is not possible. 3. Parse and clean input data effectively to ensure the graph is set up correctly before operations."
            }
        ]
    },
    {
        "id": 27,
        "problem": "Determine when the three nodes [0, 19, 18] first close the triad.",
        "graph_type": "undirected dynamic",
        "experience": "The task was to determine when three specific nodes first form a closed triad in a graph given a series of time-stamped edges. The objective was clearly defined and the approach focused on iteratively adding edges to the graph while checking for the closure condition of the triad.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer when the three nodes in the dynamic graph first close the triad. Two nodes with a common neighbor is said to have a triadic closure, if they are linked since some time so that the three nodes have linked with each other to form a triad.\nGive the answer as an integer number at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 8, 0), (0, 17, 0), (1, 17, 0), (2, 23, 0), (3, 6, 0), (6, 11, 0), (7, 16, 0), (9, 12, 0), (9, 13, 0), (9, 21, 0), (11, 19, 0), (16, 17, 0), (0, 19, 1), (1, 19, 1), (1, 24, 1), (2, 12, 1), (2, 14, 1), (2, 22, 1), (3, 9, 1), (3, 13, 1), (3, 20, 1), (4, 11, 1), (4, 16, 1), (4, 23, 1), (6, 15, 1), (9, 11, 1), (9, 20, 1), (9, 23, 1), (11, 13, 1), (12, 20, 1), (13, 19, 1), (13, 22, 1), (14, 17, 1), (15, 18, 1), (15, 20, 1), (16, 24, 1), (20, 24, 1), (0, 7, 2), (0, 12, 2), (0, 13, 2), (0, 18, 2), (1, 2, 2), (1, 7, 2), (2, 15, 2), (6, 22, 2), (7, 19, 2), (7, 22, 2), (7, 24, 2), (8, 18, 2), (9, 14, 2), (10, 15, 2), (10, 17, 2), (12, 15, 2), (12, 17, 2), (20, 21, 2), (0, 9, 3), (1, 21, 3), (2, 16, 3), (3, 16, 3), (4, 13, 3), (4, 17, 3), (4, 20, 3), (5, 10, 3), (5, 16, 3), (6, 21, 3), (8, 11, 3), (8, 21, 3), (10, 14, 3), (11, 20, 3), (12, 19, 3), (13, 24, 3), (14, 24, 3), (16, 21, 3), (18, 19, 3), (18, 23, 3), (21, 24, 3), (0, 10, 4), (1, 12, 4), (2, 9, 4), (2, 10, 4), (3, 5, 4), (3, 11, 4), (3, 12, 4), (3, 14, 4), (3, 23, 4), (5, 14, 4), (5, 21, 4), (7, 9, 4), (7, 23, 4), (10, 12, 4), (10, 20, 4), (11, 22, 4), (12, 16, 4), (12, 24, 4), (13, 14, 4), (13, 20, 4), (14, 19, 4), (14, 22, 4), (15, 23, 4), (16, 18, 4), (16, 23, 4), (18, 24, 4)]. When did the three nodes [0, 19, 18] first close the triad?\n",
                "code": "\nimport networkx as nx\n\n# Input data representing edges with timestamps\ninput_data = [\n    [0, 8, 0], [0, 17, 0], [1, 17, 0], [2, 23, 0], [3, 6, 0], [6, 11, 0],\n    [7, 16, 0], [9, 12, 0], [9, 13, 0], [9, 21, 0], [11, 19, 0], [16, 17, 0],\n    [0, 19, 1], [1, 19, 1], [1, 24, 1], [2, 12, 1], [2, 14, 1], [2, 22, 1],\n    [3, 9, 1], [3, 13, 1], [3, 20, 1], [4, 11, 1], [4, 16, 1], [4, 23, 1],\n    [6, 15, 1], [9, 11, 1], [9, 20, 1], [9, 23, 1], [11, 13, 1], [12, 20, 1],\n    [13, 19, 1], [13, 22, 1], [14, 17, 1], [15, 18, 1], [15, 20, 1], [16, 24, 1],\n    [20, 24, 1], [0, 7, 2], [0, 12, 2], [0, 13, 2], [0, 18, 2], [1, 2, 2],\n    [1, 7, 2], [2, 15, 2], [6, 22, 2], [7, 19, 2], [7, 22, 2], [7, 24, 2],\n    [8, 18, 2], [9, 14, 2], [10, 15, 2], [10, 17, 2], [12, 15, 2], [12, 17, 2],\n    [20, 21, 2], [0, 9, 3], [1, 21, 3], [2, 16, 3], [3, 16, 3], [4, 13, 3],\n    [4, 17, 3], [4, 20, 3], [5, 10, 3], [5, 16, 3], [6, 21, 3], [8, 11, 3],\n    [8, 21, 3], [10, 14, 3], [11, 20, 3], [12, 19, 3], [13, 24, 3], [14, 24, 3],\n    [16, 21, 3], [18, 19, 3], [18, 23, 3], [21, 24, 3], [0, 10, 4], [1, 12, 4],\n    [2, 9, 4], [2, 10, 4], [3, 5, 4], [3, 11, 4], [3, 12, 4], [3, 14, 4],\n    [3, 23, 4], [5, 14, 4], [5, 21, 4], [7, 9, 4], [7, 23, 4], [10, 12, 4],\n    [10, 20, 4], [11, 22, 4], [12, 16, 4], [12, 24, 4], [13, 14, 4], [13, 20, 4],\n    [14, 19, 4], [14, 22, 4], [15, 23, 4], [16, 18, 4], [16, 23, 4], [18, 24, 4]\n]\n\n# Initialize an undirected graph\nG = nx.Graph()\n\n# Nodes to check for triad closure\ntriad_nodes = [0, 19, 18]\n\n# Iterate through the input data to add edges and check for triad closure\nfor edge in input_data:\n    u, v, timestamp = edge\n    G.add_edge(u, v)  # Add the edge to the graph\n\n    # Check if the triad is closed\n    if all(node in G for node in triad_nodes):\n        if G.has_edge(triad_nodes[0], triad_nodes[1]) and G.has_edge(triad_nodes[1], triad_nodes[2]) and G.has_edge(triad_nodes[0], triad_nodes[2]):\n            print(timestamp)  # Output the timestamp when the triad closes\n            break\n",
                "key_api": "networkx.Graph",
                "key_experience": "['Initialize an undirected graph for managing nodes and edges.', 'Iterate through the list of labelled edges and add each one to the graph while checking for triad closure.', 'Check for presence of the nodes using graph membership checks and verify the closure by checking all possible edges among the nodes of interest.']"
            }
        ]
    },
    {
        "id": 28,
        "problem": "Determine when the three nodes [2, 6, 15] first close the triad.",
        "graph_type": "undirected dynamic",
        "experience": "In a recent engagement involving GPT-4o-mini, the focus was to determine when three specific nodes [2, 6, 15] first close a triad using the NetworkX library. The task involved creating an undirected graph from given edges with timestamps and iterating through the edges to check if the specified nodes formed a closed triad. This required conditional checks to ensure all necessary edges were present at a certain timestamp. The solution returned the timestamp when the triad was first closed or -1 if it never happened.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer when the three nodes in the dynamic graph first close the triad. Two nodes with a common neighbor is said to have a triadic closure, if they are linked since some time so that the three nodes have linked with each other to form a triad.\nGive the answer as an integer number at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 8, 0), (0, 11, 0), (1, 23, 0), (2, 10, 0), (6, 8, 0), (6, 10, 0), (6, 15, 0), (6, 22, 0), (8, 9, 0), (8, 11, 0), (9, 23, 0), (10, 12, 0), (13, 19, 0), (14, 21, 0), (17, 21, 0), (18, 24, 0), (23, 24, 0), (0, 9, 1), (1, 9, 1), (1, 20, 1), (2, 11, 1), (2, 20, 1), (2, 24, 1), (3, 18, 1), (3, 21, 1), (5, 8, 1), (8, 18, 1), (11, 15, 1), (11, 16, 1), (13, 14, 1), (13, 21, 1), (18, 22, 1), (0, 20, 2), (1, 21, 2), (2, 15, 2), (4, 21, 2), (5, 13, 2), (5, 15, 2), (6, 24, 2), (8, 12, 2), (8, 13, 2), (9, 12, 2), (9, 14, 2), (12, 21, 2), (14, 17, 2), (16, 20, 2), (16, 21, 2), (17, 23, 2), (21, 22, 2), (0, 4, 3), (0, 14, 3), (1, 15, 3), (1, 16, 3), (1, 22, 3), (2, 22, 3), (3, 15, 3), (3, 24, 3), (4, 7, 3), (5, 23, 3), (8, 10, 3), (8, 16, 3), (8, 24, 3), (9, 16, 3), (9, 22, 3), (10, 18, 3), (15, 24, 3), (18, 21, 3), (20, 22, 3), (0, 13, 4), (1, 19, 4), (2, 6, 4), (3, 16, 4), (3, 22, 4), (4, 20, 4), (5, 18, 4), (6, 12, 4), (7, 14, 4), (8, 22, 4), (9, 18, 4), (10, 15, 4), (10, 16, 4), (11, 18, 4), (17, 20, 4), (21, 23, 4)]. When did the three nodes [2, 6, 15] first close the triad?\n",
                "code": "\nimport networkx as nx\n\ndef first_triad_closure(edges, nodes):\n    # Create an undirected graph\n    G = nx.Graph()\n    \n    # Iterate through the edges with their timestamps\n    for edge in edges:\n        u, v, timestamp = edge\n        \n        # Add the edge to the graph\n        G.add_edge(u, v)\n        \n        # Check if the specified nodes form a closed triad\n        if all(G.has_edge(n1, n2) for n1 in nodes for n2 in nodes if n1 != n2):\n            return timestamp  # Return the timestamp when the triad closes\n\n    return -1  # Return -1 if the triad never closes\n\n# Input edges\nedges = [\n    [0, 8, 0], [0, 11, 0], [1, 23, 0], [2, 10, 0], [6, 8, 0], [6, 10, 0], \n    [6, 15, 0], [6, 22, 0], [8, 9, 0], [8, 11, 0], [9, 23, 0], [10, 12, 0], \n    [13, 19, 0], [14, 21, 0], [17, 21, 0], [18, 24, 0], [23, 24, 0], \n    [0, 9, 1], [1, 9, 1], [1, 20, 1], [2, 11, 1], [2, 20, 1], [2, 24, 1], \n    [3, 18, 1], [3, 21, 1], [5, 8, 1], [8, 18, 1], [11, 15, 1], [11, 16, 1], \n    [13, 14, 1], [13, 21, 1], [18, 22, 1], [0, 20, 2], [1, 21, 2], \n    [2, 15, 2], [4, 21, 2], [5, 13, 2], [5, 15, 2], [6, 24, 2], [8, 12, 2], \n    [8, 13, 2], [9, 12, 2], [9, 14, 2], [12, 21, 2], [14, 17, 2], \n    [16, 20, 2], [16, 21, 2], [17, 23, 2], [21, 22, 2], [0, 4, 3], \n    [0, 14, 3], [1, 15, 3], [1, 16, 3], [1, 22, 3], [2, 22, 3], \n    [3, 15, 3], [3, 24, 3], [4, 7, 3], [5, 23, 3], [8, 10, 3], \n    [8, 16, 3], [8, 24, 3], [9, 16, 3], [9, 22, 3], [10, 18, 3], \n    [15, 24, 3], [18, 21, 3], [20, 22, 3], [0, 13, 4], [1, 19, 4], \n    [2, 6, 4], [3, 16, 4], [3, 22, 4], [4, 20, 4], [5, 18, 4], \n    [6, 12, 4], [7, 14, 4], [8, 22, 4], [9, 18, 4], [10, 15, 4], \n    [10, 16, 4], [11, 18, 4], [17, 20, 4], [21, 23, 4]\n]\n\n# Nodes to check for triad closure\nnodes_to_check = [2, 6, 15]\n\n# Get the result\nresult = first_triad_closure(edges, nodes_to_check)\nprint(result)\n",
                "key_api": "The key API used in the code was the NetworkX library, specifically `nx.Graph()` for creating a graph, `G.add_edge(u, v)` for adding edges to the graph, and `G.has_edge(n1, n2)` to check for the existence of edges between nodes.",
                "key_experience": "Best practices included proper iteration and conditional checks to determine the closure of a triad, using efficient graph-based operations to reduce computational complexity, and appropriately handling all edge cases such as returning -1 if the triad never closes."
            }
        ]
    },
    {
        "id": 29,
        "problem": "Identify nodes linked with node 19 after or at time 3 but not linked before time 3.",
        "graph_type": "undirected dynamic",
        "experience": "From the recent engagement, it was clear that the task involved working with graph data structures to identify nodes linked to a specific node based on temporal constraints. The solution required parsing input data to construct an undirected graph using NetworkX, followed by filtering neighbors based on the specified timestamps.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer what nodes are linked with one node only after some time in the dynamic graph.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(2, 12, 0), (2, 20, 0), (4, 21, 0), (6, 9, 0), (6, 11, 0), (6, 22, 0), (9, 19, 0), (9, 21, 0), (12, 24, 0), (13, 16, 0), (0, 13, 1), (0, 15, 1), (0, 22, 1), (0, 23, 1), (3, 23, 1), (4, 9, 1), (4, 18, 1), (5, 22, 1), (5, 24, 1), (6, 7, 1), (6, 13, 1), (6, 23, 1), (7, 17, 1), (9, 17, 1), (9, 22, 1), (9, 24, 1), (11, 22, 1), (12, 23, 1), (22, 23, 1), (0, 5, 2), (1, 13, 2), (1, 14, 2), (3, 21, 2), (4, 13, 2), (7, 9, 2), (7, 12, 2), (8, 9, 2), (11, 13, 2), (11, 15, 2), (12, 18, 2), (17, 21, 2), (18, 21, 2), (19, 24, 2), (20, 21, 2), (0, 6, 3), (0, 14, 3), (1, 8, 3), (2, 13, 3), (2, 21, 3), (4, 15, 3), (4, 24, 3), (5, 21, 3), (7, 14, 3), (7, 15, 3), (8, 10, 3), (8, 13, 3), (8, 24, 3), (10, 16, 3), (11, 18, 3), (14, 15, 3), (14, 18, 3), (14, 24, 3), (15, 18, 3), (16, 22, 3), (18, 24, 3), (0, 2, 4), (0, 3, 4), (1, 15, 4), (1, 22, 4), (2, 6, 4), (3, 19, 4), (4, 7, 4), (5, 17, 4), (6, 10, 4), (7, 20, 4), (7, 24, 4), (8, 15, 4), (8, 16, 4), (8, 21, 4), (10, 22, 4), (11, 12, 4), (11, 14, 4), (13, 14, 4), (14, 16, 4), (14, 23, 4), (15, 17, 4), (15, 19, 4), (16, 17, 4), (18, 23, 4)]. What nodes are linked with node 19 after or at time 3 but not linked before time 3?\n",
                "code": "\nimport networkx as nx\n\n# Input data: edges with their respective timestamps\ninput_data = [\n    [2, 12, 0], [2, 20, 0], [4, 21, 0], [6, 9, 0], [6, 11, 0], [6, 22, 0],\n    [9, 19, 0], [9, 21, 0], [12, 24, 0], [13, 16, 0], [0, 13, 1], [0, 15, 1],\n    [0, 22, 1], [0, 23, 1], [3, 23, 1], [4, 9, 1], [4, 18, 1], [5, 22, 1],\n    [5, 24, 1], [6, 7, 1], [6, 13, 1], [6, 23, 1], [7, 17, 1], [9, 17, 1],\n    [9, 22, 1], [9, 24, 1], [11, 22, 1], [12, 23, 1], [22, 23, 1], [0, 5, 2],\n    [1, 13, 2], [1, 14, 2], [3, 21, 2], [4, 13, 2], [7, 9, 2], [7, 12, 2],\n    [8, 9, 2], [11, 13, 2], [11, 15, 2], [12, 18, 2], [17, 21, 2], [18, 21, 2],\n    [19, 24, 2], [20, 21, 2], [0, 6, 3], [0, 14, 3], [1, 8, 3], [2, 13, 3],\n    [2, 21, 3], [4, 15, 3], [4, 24, 3], [5, 21, 3], [7, 14, 3], [7, 15, 3],\n    [8, 10, 3], [8, 13, 3], [8, 24, 3], [10, 16, 3], [11, 18, 3], [14, 15, 3],\n    [14, 18, 3], [14, 24, 3], [15, 18, 3], [16, 22, 3], [18, 24, 3], [0, 2, 4],\n    [0, 3, 4], [1, 15, 4], [1, 22, 4], [2, 6, 4], [3, 19, 4], [4, 7, 4],\n    [5, 17, 4], [6, 10, 4], [7, 20, 4], [7, 24, 4], [8, 15, 4], [8, 16, 4],\n    [8, 21, 4], [10, 22, 4], [11, 12, 4], [11, 14, 4], [13, 14, 4], [14, 16, 4],\n    [14, 23, 4], [15, 17, 4], [15, 19, 4], [16, 17, 4], [18, 23, 4]\n]\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph with their respective timestamps\nfor u, v, t in input_data:\n    G.add_edge(u, v, time=t)\n\n# Identify nodes linked with node 19 after or at time 3 but not linked before time 3\nlinked_after_time_3 = set()\nlinked_before_time_3 = set()\n\n# Get neighbors of node 19 after or at time 3\nfor neighbor in G.neighbors(19):\n    # Check if the edge exists at time 3 or later\n    if G.has_edge(19, neighbor):\n        edge_time = G[19][neighbor]['time']\n        if edge_time >= 3:\n            linked_after_time_3.add(neighbor)\n\n# Get neighbors of node 19 before time 3\nfor neighbor in G.neighbors(19):\n    if G.has_edge(19, neighbor):\n        edge_time = G[19][neighbor]['time']\n        if edge_time < 3:\n            linked_before_time_3.add(neighbor)\n\n# Filter out nodes that were linked before time 3\nresult = list(linked_after_time_3 - linked_before_time_3)\n\n# Output the result\nprint(result)\n",
                "key_api": "NetworkX was the key API used in the code. The methods `add_edge()`, `neighbors()`, and `has_edge()` were particularly important for constructing the graph and querying node relationships.",
                "key_experience": "1. Parsing Input: Careful parsing of input data to ensure all edges and timestamps are correctly added to the graph.\n2. Filtering Based on Conditions: Using conditional checks to filter neighbors based on timestamps.\n3. Set Operations: Utilizing sets to store and process neighbors linked before and after the specified time efficiently.\n4. Code Modularity: Breaking down the problem into smaller sub-tasks like creating the graph, finding neighbors at different times, and then filtering the required nodes."
            }
        ]
    },
    {
        "id": 30,
        "problem": "Identify nodes linked with node 15 after or at time 1 but not linked before time 1.",
        "graph_type": "undirected dynamic",
        "experience": "The task involves analyzing a graph created from the provided input data to find nodes linked to a specific node (node 15) under certain time constraints. The solution requires identifying nodes connected to node 15 at or after a specific time (time 1) and ensuring they were not linked before this time. The steps include parsing the input data, constructing the graph, and performing the necessary checks for the time conditions.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer what nodes are linked with one node only after some time in the dynamic graph.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 9, 0), (0, 20, 0), (1, 17, 0), (2, 7, 0), (3, 11, 0), (3, 13, 0), (3, 15, 0), (3, 24, 0), (4, 7, 0), (4, 15, 0), (4, 19, 0), (4, 22, 0), (4, 23, 0), (5, 10, 0), (5, 18, 0), (6, 19, 0), (10, 23, 0), (11, 19, 0), (11, 21, 0), (12, 15, 0), (12, 19, 0), (13, 18, 0), (13, 19, 0), (14, 23, 0), (15, 23, 0), (17, 18, 0), (0, 1, 1), (0, 3, 1), (0, 7, 1), (1, 20, 1), (2, 6, 1), (3, 5, 1), (3, 17, 1), (3, 21, 1), (3, 22, 1), (4, 14, 1), (5, 8, 1), (5, 22, 1), (6, 17, 1), (6, 22, 1), (7, 11, 1), (7, 17, 1), (7, 19, 1), (7, 24, 1), (8, 12, 1), (11, 17, 1), (11, 20, 1), (14, 19, 1), (14, 20, 1), (16, 18, 1), (16, 19, 1), (16, 20, 1), (18, 22, 1), (19, 21, 1), (3, 20, 2), (6, 21, 2), (7, 15, 2), (7, 22, 2), (8, 13, 2), (8, 18, 2), (8, 21, 2), (9, 10, 2), (9, 14, 2), (11, 12, 2), (14, 24, 2), (19, 20, 2), (19, 22, 2), (0, 13, 3), (0, 14, 3), (1, 2, 3), (1, 4, 3), (2, 23, 3), (4, 8, 3), (6, 11, 3), (6, 14, 3), (6, 16, 3), (9, 13, 3), (10, 15, 3), (11, 13, 3), (14, 16, 3), (16, 22, 3), (17, 24, 3), (19, 24, 3), (21, 24, 3), (0, 11, 4), (0, 23, 4), (1, 5, 4), (1, 15, 4), (1, 23, 4), (2, 10, 4), (2, 14, 4), (2, 18, 4), (3, 6, 4), (3, 23, 4), (5, 7, 4), (8, 10, 4), (8, 11, 4), (8, 14, 4), (9, 19, 4), (9, 24, 4), (10, 18, 4), (13, 20, 4), (14, 21, 4), (15, 19, 4), (15, 21, 4), (17, 23, 4)]. What nodes are linked with node 15 after or at time 1 but not linked before time 1?\n",
                "code": "\nimport networkx as nx\n\n# Input data\ninput_data = [\n    [0, 9, 0], [0, 20, 0], [1, 17, 0], [2, 7, 0], [3, 11, 0], [3, 13, 0],\n    [3, 15, 0], [3, 24, 0], [4, 7, 0], [4, 15, 0], [4, 19, 0], [4, 22, 0],\n    [4, 23, 0], [5, 10, 0], [5, 18, 0], [6, 19, 0], [10, 23, 0], [11, 19, 0],\n    [11, 21, 0], [12, 15, 0], [12, 19, 0], [13, 18, 0], [13, 19, 0], [14, 23, 0],\n    [15, 23, 0], [17, 18, 0], [0, 1, 1], [0, 3, 1], [0, 7, 1], [1, 20, 1],\n    [2, 6, 1], [3, 5, 1], [3, 17, 1], [3, 21, 1], [3, 22, 1], [4, 14, 1],\n    [5, 8, 1], [5, 22, 1], [6, 17, 1], [6, 22, 1], [7, 11, 1], [7, 17, 1],\n    [7, 19, 1], [7, 24, 1], [8, 12, 1], [11, 17, 1], [11, 20, 1], [14, 19, 1],\n    [14, 20, 1], [16, 18, 1], [16, 19, 1], [16, 20, 1], [18, 22, 1], [19, 21, 1],\n    [3, 20, 2], [6, 21, 2], [7, 15, 2], [7, 22, 2], [8, 13, 2], [8, 18, 2],\n    [8, 21, 2], [9, 10, 2], [9, 14, 2], [11, 12, 2], [14, 24, 2], [19, 20, 2],\n    [19, 22, 2], [0, 13, 3], [0, 14, 3], [1, 2, 3], [1, 4, 3], [2, 23, 3],\n    [4, 8, 3], [6, 11, 3], [6, 14, 3], [6, 16, 3], [9, 13, 3], [10, 15, 3],\n    [11, 13, 3], [14, 16, 3], [16, 22, 3], [17, 24, 3], [19, 24, 3], [21, 24, 3],\n    [0, 11, 4], [0, 23, 4], [1, 5, 4], [1, 15, 4], [1, 23, 4], [2, 10, 4],\n    [2, 14, 4], [2, 18, 4], [3, 6, 4], [3, 23, 4], [5, 7, 4], [8, 10, 4],\n    [8, 11, 4], [8, 14, 4], [9, 19, 4], [9, 24, 4], [10, 18, 4], [13, 20, 4],\n    [14, 21, 4], [15, 19, 4], [15, 21, 4], [17, 23, 4]\n]\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor u, v, t in input_data:\n    G.add_edge(u, v, time=t)\n\n# Find nodes linked with node 15 after or at time 1\nlinked_after_time_1 = set()\nfor neighbor in G.neighbors(15):\n    # Check if the edge exists at time 1 or later\n    if G[15][neighbor]['time'] >= 1:\n        linked_after_time_1.add(neighbor)\n\n# Find nodes linked with node 15 before time 1\nlinked_before_time_1 = set()\nfor neighbor in G.neighbors(15):\n    # Check if the edge exists before time 1\n    if G[15][neighbor]['time'] < 1:\n        linked_before_time_1.add(neighbor)\n\n# Identify nodes linked with node 15 after or at time 1 but not linked before time 1\nresult = list(linked_after_time_1 - linked_before_time_1)\n\n# Output the result\nprint(result)\n",
                "key_api": "networkx.Graph, networkx.Graph.add_edge, networkx.Graph.neighbors",
                "key_experience": "1. Parse the input data carefully to ensure correct edge creation in the graph. 2. Use appropriate data structures (sets) to store intermediary results for efficient lookup and deduction. 3. Properly check edge attributes to filter nodes based on the specified time conditions."
            }
        ]
    },
    {
        "id": 31,
        "problem": "What nodes are linked with node 19 at time 4?",
        "graph_type": "undirected dynamic",
        "experience": "The task involved using the NetworkX library to determine which nodes are linked to node 19 at a specific time (time 4) in a directed graph. The steps included creating a directed graph, filtering edges by the given time, adding those edges to the graph, and finally retrieving the neighbors of the node of interest.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer what nodes are linked with a given node at a given time in the dynamic graph.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 9, 0), (1, 23, 0), (3, 5, 0), (3, 8, 0), (3, 13, 0), (3, 22, 0), (8, 15, 0), (8, 16, 0), (9, 10, 0), (9, 13, 0), (10, 12, 0), (10, 21, 0), (11, 23, 0), (12, 18, 0), (12, 19, 0), (12, 23, 0), (13, 16, 0), (14, 20, 0), (15, 19, 0), (15, 22, 0), (17, 21, 0), (18, 24, 0), (20, 23, 0), (0, 21, 1), (1, 14, 1), (2, 4, 1), (2, 5, 1), (2, 19, 1), (2, 23, 1), (3, 9, 1), (5, 14, 1), (6, 7, 1), (6, 15, 1), (8, 18, 1), (9, 19, 1), (11, 24, 1), (12, 17, 1), (14, 18, 1), (15, 18, 1), (17, 19, 1), (0, 7, 2), (1, 2, 2), (1, 6, 2), (3, 15, 2), (3, 24, 2), (4, 7, 2), (6, 21, 2), (7, 18, 2), (9, 14, 2), (10, 14, 2), (19, 23, 2), (20, 21, 2), (2, 3, 3), (2, 14, 3), (2, 17, 3), (3, 7, 3), (3, 19, 3), (5, 6, 3), (6, 20, 3), (9, 22, 3), (11, 18, 3), (13, 15, 3), (13, 21, 3), (16, 22, 3), (17, 23, 3), (1, 10, 4), (1, 20, 4), (2, 6, 4), (2, 7, 4), (2, 8, 4), (2, 22, 4), (4, 18, 4), (4, 20, 4), (7, 16, 4), (8, 10, 4), (8, 11, 4), (11, 12, 4), (11, 13, 4), (14, 15, 4), (15, 23, 4), (16, 17, 4), (16, 18, 4), (18, 21, 4), (19, 24, 4)]. What nodes are linked with node 19 at time 4?\n",
                "code": "\nimport networkx as nx\n\n# Input edges with time as the last element in each sublist\nedges = [\n    [0, 9, 0], [1, 23, 0], [3, 5, 0], [3, 8, 0], [3, 13, 0], [3, 22, 0],\n    [8, 15, 0], [8, 16, 0], [9, 10, 0], [9, 13, 0], [10, 12, 0], [10, 21, 0],\n    [11, 23, 0], [12, 18, 0], [12, 19, 0], [12, 23, 0], [13, 16, 0], [14, 20, 0],\n    [15, 19, 0], [15, 22, 0], [17, 21, 0], [18, 24, 0], [20, 23, 0], [0, 21, 1],\n    [1, 14, 1], [2, 4, 1], [2, 5, 1], [2, 19, 1], [2, 23, 1], [3, 9, 1],\n    [5, 14, 1], [6, 7, 1], [6, 15, 1], [8, 18, 1], [9, 19, 1], [11, 24, 1],\n    [12, 17, 1], [14, 18, 1], [15, 18, 1], [17, 19, 1], [0, 7, 2], [1, 2, 2],\n    [1, 6, 2], [3, 15, 2], [3, 24, 2], [4, 7, 2], [6, 21, 2], [7, 18, 2],\n    [9, 14, 2], [10, 14, 2], [19, 23, 2], [20, 21, 2], [2, 3, 3], [2, 14, 3],\n    [2, 17, 3], [3, 7, 3], [3, 19, 3], [5, 6, 3], [6, 20, 3], [9, 22, 3],\n    [11, 18, 3], [13, 15, 3], [13, 21, 3], [16, 22, 3], [17, 23, 3], [1, 10, 4],\n    [1, 20, 4], [2, 6, 4], [2, 7, 4], [2, 8, 4], [2, 22, 4], [4, 18, 4],\n    [4, 20, 4], [7, 16, 4], [8, 10, 4], [8, 11, 4], [11, 12, 4], [11, 13, 4],\n    [14, 15, 4], [15, 23, 4], [16, 17, 4], [16, 18, 4], [18, 21, 4], [19, 24, 4]\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph, filtering by time\ntime_filter = 4\nfor u, v, t in edges:\n    if t == time_filter:\n        G.add_edge(u, v)\n\n# Get the neighbors of node 19\nneighbors_of_19 = list(G.neighbors(19))\n\n# Output the result\nprint(neighbors_of_19)\n",
                "key_api": "The key API used was the NetworkX library in Python, particularly the `nx.DiGraph()` to create a directed graph, and `G.add_edge(u, v)` to add edges to the graph. The `G.neighbors()` method was used to find the neighbors of a specific node.",
                "key_experience": "Some best practices included:\n1. Filtering the edges by the specific time before adding them to the graph to ensure only relevant edges were included.\n2. Iterating through the list of edges carefully to maintain the correct graph structure.\n3. Converting the neighbors to a list for easy handling and output.\n4. Using meaningful variable names and keeping the code clear and concise for better readability and maintenance."
            }
        ]
    },
    {
        "id": 32,
        "problem": "What nodes are linked with node 15 at time 2?",
        "graph_type": "undirected dynamic",
        "experience": "The task involved finding nodes linked with node 15 at time 2 using the NetworkX library in Python. The user was given a directed graph with edges annotated with time attributes. We created a directed graph (DiGraph) and added the edges with their corresponding time attribute. A function, 'find_neighbors_at_time', was defined to find the neighbors of a node at a specific time by iterating through the neighbors of the node and checking if the time attribute of the edge matches the specified time. Finally, the function was used to find nodes linked with node 15 at time 2.",
        "rag_data": [
            {
                "Section ID": "Graph.add_edge",
                "Description": [],
                "Field List": {
                    "Parameters:": {
                        "u_of_edge, v_of_edge : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects.",
                        "attr : keyword arguments, optional": "Edge data (or labels or objects) can be assigned using\nkeyword arguments."
                    }
                },
                "Rubrics": {
                    "Notes": "Adding an edge that already exists updates the edge data. Many NetworkX algorithms designed for weighted graphs use\nan edge attribute (by default weight ) to hold a numerical value.",
                    "Examples": "The following all add the edge e=(1, 2) to graph G:\nG=nx.Graph()# or DiGraph, MultiGraph, MultiDiGraph, etc\ne=(1,2)\nG.add_edge(1,2)# explicit two-node form\nG.add_edge(*e)# single edge as tuple of two nodes\nG.add_edges_from([(1,2)])# add edges from iterable container\nAssociate data to edges using keywords:\nG.add_edge(1,2,weight=3)\nG.add_edge(1,3,weight=7,capacity=15,length=342.7)\nFor non-string attribute keys, use subscript notation.\nG.add_edge(1,2)\nG[1][2].update({0:5})\nG.edges[1,2].update({0:5})"
                }
            },
            {
                "Section ID": "Graph.neighbors",
                "Description": [],
                "Field List": {
                    "Parameters:": {
                        "n : node": "A node in the graph"
                    },
                    "Returns:": {
                        "neighbors : iterator": "An iterator over all neighbors of node n"
                    },
                    "Raises:": {
                        "NetworkXError": "If the node n is not in the graph."
                    }
                },
                "Rubrics": {
                    "Notes": "Alternate ways to access the neighbors are G.adj[n] or G[n] :",
                    "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\n[nforninG.neighbors(0)]\n# [1]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer what nodes are linked with a given node at a given time in the dynamic graph.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(1, 6, 0), (2, 17, 0), (4, 21, 0), (6, 24, 0), (9, 17, 0), (9, 18, 0), (10, 19, 0), (12, 15, 0), (13, 22, 0), (18, 21, 0), (0, 5, 1), (1, 7, 1), (1, 9, 1), (1, 22, 1), (2, 8, 1), (2, 14, 1), (4, 9, 1), (4, 14, 1), (6, 13, 1), (8, 13, 1), (8, 24, 1), (9, 13, 1), (10, 23, 1), (11, 16, 1), (11, 20, 1), (11, 21, 1), (14, 15, 1), (14, 16, 1), (14, 22, 1), (16, 17, 1), (17, 19, 1), (18, 19, 1), (0, 4, 2), (0, 20, 2), (1, 2, 2), (2, 5, 2), (2, 19, 2), (3, 24, 2), (4, 6, 2), (4, 10, 2), (4, 24, 2), (5, 20, 2), (6, 14, 2), (6, 22, 2), (7, 10, 2), (7, 12, 2), (7, 13, 2), (8, 19, 2), (9, 22, 2), (11, 13, 2), (12, 19, 2), (14, 18, 2), (14, 20, 2), (15, 19, 2), (20, 21, 2), (20, 23, 2), (21, 22, 2), (0, 11, 3), (1, 12, 3), (3, 12, 3), (4, 11, 3), (5, 21, 3), (6, 8, 3), (7, 19, 3), (7, 21, 3), (8, 21, 3), (9, 11, 3), (9, 23, 3), (10, 17, 3), (11, 17, 3), (16, 18, 3), (16, 20, 3), (0, 17, 4), (2, 11, 4), (2, 13, 4), (3, 5, 4), (3, 7, 4), (4, 17, 4), (5, 23, 4), (5, 24, 4), (10, 11, 4), (10, 24, 4), (11, 15, 4), (12, 13, 4), (15, 16, 4), (15, 23, 4), (17, 21, 4), (19, 23, 4), (23, 24, 4)]. What nodes are linked with node 15 at time 2?\n",
                "code": "\nimport networkx as nx\n\n# Input data: edges with their respective time attributes\nedges = [\n    [1, 6, 0], [2, 17, 0], [4, 21, 0], [6, 24, 0], [9, 17, 0], \n    [9, 18, 0], [10, 19, 0], [12, 15, 0], [13, 22, 0], [18, 21, 0], \n    [0, 5, 1], [1, 7, 1], [1, 9, 1], [1, 22, 1], [2, 8, 1], \n    [2, 14, 1], [4, 9, 1], [4, 14, 1], [6, 13, 1], [8, 13, 1], \n    [8, 24, 1], [9, 13, 1], [10, 23, 1], [11, 16, 1], [11, 20, 1], \n    [11, 21, 1], [14, 15, 1], [14, 16, 1], [14, 22, 1], [16, 17, 1], \n    [17, 19, 1], [18, 19, 1], [0, 4, 2], [0, 20, 2], [1, 2, 2], \n    [2, 5, 2], [2, 19, 2], [3, 24, 2], [4, 6, 2], [4, 10, 2], \n    [4, 24, 2], [5, 20, 2], [6, 14, 2], [6, 22, 2], [7, 10, 2], \n    [7, 12, 2], [7, 13, 2], [8, 19, 2], [9, 22, 2], [11, 13, 2], \n    [12, 19, 2], [14, 18, 2], [14, 20, 2], [15, 19, 2], [20, 21, 2], \n    [20, 23, 2], [21, 22, 2], [0, 11, 3], [1, 12, 3], [3, 12, 3], \n    [4, 11, 3], [5, 21, 3], [6, 8, 3], [7, 19, 3], [7, 21, 3], \n    [8, 21, 3], [9, 11, 3], [9, 23, 3], [10, 17, 3], [11, 17, 3], \n    [16, 18, 3], [16, 20, 3], [0, 17, 4], [2, 11, 4], [2, 13, 4], \n    [3, 5, 4], [3, 7, 4], [4, 17, 4], [5, 23, 4], [5, 24, 4], \n    [10, 11, 4], [10, 24, 4], [11, 15, 4], [12, 13, 4], [15, 16, 4], \n    [15, 23, 4], [17, 21, 4], [19, 23, 4], [23, 24, 4]\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph with time as an attribute\nfor u, v, t in edges:\n    G.add_edge(u, v, time=t)\n\n# Function to find neighbors of a node at a specific time\ndef find_neighbors_at_time(graph, node, time):\n    return [n for n in graph.neighbors(node) if graph[node][n]['time'] == time]\n\n# Find nodes linked with node 15 at time 2\nlinked_nodes = find_neighbors_at_time(G, 15, 2)\n\n# Output the result\nprint(linked_nodes)\n",
                "key_api": "networkx.DiGraph, graph.add_edge, graph.neighbors",
                "key_experience": "1. Use of NetworkX for creating and manipulating graph structures. 2. Adding edges along with their time attribute to the graph. 3. Iterating over neighbors of a node and filtering based on edge attributes to solve the specific query."
            }
        ]
    },
    {
        "id": 33,
        "problem": "Determine if the nodes [13, 5, 9] form a closed triad.",
        "graph_type": "undirected dynamic",
        "experience": "In this task, the goal was to determine if the nodes [13, 5, 9] form a closed triad in a directed graph. The process involved defining the given edges and creating a directed graph (DiGraph) using NetworkX. Then, we defined the triad nodes to check and assessed if each pair of nodes in the triad are mutually connected by iterating through all combinations of nodes and checking if there is an edge between them.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer whether three nodes in the dynamic graph formed a closed triad. A closed triad is composed of three nodes which have linked with each other some time. \nGive the answer as yes or no at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(1, 6, 0), (2, 17, 0), (4, 21, 0), (6, 24, 0), (9, 17, 0), (9, 18, 0), (10, 19, 0), (12, 15, 0), (13, 22, 0), (18, 21, 0), (0, 5, 1), (1, 7, 1), (1, 9, 1), (1, 22, 1), (2, 8, 1), (2, 14, 1), (4, 9, 1), (4, 14, 1), (6, 13, 1), (8, 13, 1), (8, 24, 1), (9, 13, 1), (10, 23, 1), (11, 16, 1), (11, 20, 1), (11, 21, 1), (14, 15, 1), (14, 16, 1), (14, 22, 1), (16, 17, 1), (17, 19, 1), (18, 19, 1), (0, 4, 2), (0, 20, 2), (1, 2, 2), (2, 5, 2), (2, 19, 2), (3, 24, 2), (4, 6, 2), (4, 10, 2), (4, 24, 2), (5, 20, 2), (6, 14, 2), (6, 22, 2), (7, 10, 2), (7, 12, 2), (7, 13, 2), (8, 19, 2), (9, 22, 2), (11, 13, 2), (12, 19, 2), (14, 18, 2), (14, 20, 2), (15, 19, 2), (20, 21, 2), (20, 23, 2), (21, 22, 2), (0, 11, 3), (1, 12, 3), (3, 12, 3), (4, 11, 3), (5, 21, 3), (6, 8, 3), (7, 19, 3), (7, 21, 3), (8, 21, 3), (9, 11, 3), (9, 23, 3), (10, 17, 3), (11, 17, 3), (16, 18, 3), (16, 20, 3), (0, 17, 4), (2, 11, 4), (2, 13, 4), (3, 5, 4), (3, 7, 4), (4, 17, 4), (5, 23, 4), (5, 24, 4), (10, 11, 4), (10, 24, 4), (11, 15, 4), (12, 13, 4), (15, 16, 4), (15, 23, 4), (17, 21, 4), (19, 23, 4), (23, 24, 4)]. Did the three nodes [13, 5, 9] form a closed triad?\n",
                "code": "\nimport networkx as nx\n\n# Define the edges based on the provided input\nedges = [\n    (1, 6), (2, 17), (4, 21), (6, 24), (9, 17), (9, 18), (10, 19), (12, 15),\n    (13, 22), (18, 21), (0, 5), (1, 7), (1, 9), (1, 22), (2, 8), (2, 14),\n    (4, 9), (4, 14), (6, 13), (8, 13), (8, 24), (9, 13), (10, 23), (11, 16),\n    (11, 20), (11, 21), (14, 15), (14, 16), (14, 22), (16, 17), (17, 19),\n    (18, 19), (0, 4), (0, 20), (1, 2), (2, 5), (2, 19), (3, 24), (4, 6),\n    (4, 10), (4, 24), (5, 20), (6, 14), (6, 22), (7, 10), (7, 12), (7, 13),\n    (8, 19), (9, 22), (11, 13), (12, 19), (14, 18), (14, 20), (15, 19),\n    (20, 21), (20, 23), (21, 22), (0, 11), (1, 12), (3, 12), (4, 11),\n    (5, 21), (6, 8), (7, 19), (7, 21), (8, 21), (9, 11), (9, 23), (10, 17),\n    (11, 17), (16, 18), (16, 20), (0, 17), (2, 11), (2, 13), (3, 5), (3, 7),\n    (4, 17), (5, 23), (5, 24), (10, 11), (10, 24), (11, 15), (12, 13),\n    (15, 16), (15, 23), (17, 21), (19, 23), (23, 24)\n]\n\n# Create a directed graph\nG = nx.DiGraph()\nG.add_edges_from(edges)\n\n# Define the nodes to check for a closed triad\ntriad_nodes = [13, 5, 9]\n\n# Check if all pairs of the triad nodes are connected\nis_closed_triad = all(G.has_edge(triad_nodes[i], triad_nodes[j]) for i in range(len(triad_nodes)) for j in range(len(triad_nodes)) if i != j)\n\n# Output the result\nresult = \"yes\" if is_closed_triad else \"no\"\nprint(result)\n",
                "key_api": "networkx.DiGraph, networkx.DiGraph.add_edges_from, networkx.DiGraph.has_edge",
                "key_experience": "['Initialize a directed graph using NetworkX.', 'Add edges to the graph from a predefined list.', 'Define the nodes that need to be checked for forming a closed triad.', 'Utilize list comprehensions for efficient iteration and edge checking.', 'Ensure all possible node pairs within the triad are connected to confirm the closed triad.']"
            }
        ]
    },
    {
        "id": 34,
        "problem": "Determine if the three nodes [5, 2, 16] form a closed triad.",
        "graph_type": "undirected dynamic",
        "experience": "The task was to determine if three nodes in a graph form a closed triad using the NetworkX library in Python. We defined the graph's edges and created a directed graph. The approach included checking the existence of all directed edges between the three nodes.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer whether three nodes in the dynamic graph formed a closed triad. A closed triad is composed of three nodes which have linked with each other some time. \nGive the answer as yes or no at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 9, 0), (1, 23, 0), (3, 5, 0), (3, 8, 0), (3, 13, 0), (3, 22, 0), (8, 15, 0), (8, 16, 0), (9, 10, 0), (9, 13, 0), (10, 12, 0), (10, 21, 0), (11, 23, 0), (12, 18, 0), (12, 19, 0), (12, 23, 0), (13, 16, 0), (14, 20, 0), (15, 19, 0), (15, 22, 0), (17, 21, 0), (18, 24, 0), (20, 23, 0), (0, 21, 1), (1, 14, 1), (2, 4, 1), (2, 5, 1), (2, 19, 1), (2, 23, 1), (3, 9, 1), (5, 14, 1), (6, 7, 1), (6, 15, 1), (8, 18, 1), (9, 19, 1), (11, 24, 1), (12, 17, 1), (14, 18, 1), (15, 18, 1), (17, 19, 1), (0, 7, 2), (1, 2, 2), (1, 6, 2), (3, 15, 2), (3, 24, 2), (4, 7, 2), (6, 21, 2), (7, 18, 2), (9, 14, 2), (10, 14, 2), (19, 23, 2), (20, 21, 2), (2, 3, 3), (2, 14, 3), (2, 17, 3), (3, 7, 3), (3, 19, 3), (5, 6, 3), (6, 20, 3), (9, 22, 3), (11, 18, 3), (13, 15, 3), (13, 21, 3), (16, 22, 3), (17, 23, 3), (1, 10, 4), (1, 20, 4), (2, 6, 4), (2, 7, 4), (2, 8, 4), (2, 22, 4), (4, 18, 4), (4, 20, 4), (7, 16, 4), (8, 10, 4), (8, 11, 4), (11, 12, 4), (11, 13, 4), (14, 15, 4), (15, 23, 4), (16, 17, 4), (16, 18, 4), (18, 21, 4), (19, 24, 4)]. Did the three nodes [5, 2, 16] form a closed triad?\n",
                "code": "\nimport networkx as nx\n\n# Define the edges based on the provided input\nedges = [\n    [0, 9, 0], [1, 23, 0], [3, 5, 0], [3, 8, 0], [3, 13, 0], [3, 22, 0],\n    [8, 15, 0], [8, 16, 0], [9, 10, 0], [9, 13, 0], [10, 12, 0], [10, 21, 0],\n    [11, 23, 0], [12, 18, 0], [12, 19, 0], [12, 23, 0], [13, 16, 0], [14, 20, 0],\n    [15, 19, 0], [15, 22, 0], [17, 21, 0], [18, 24, 0], [20, 23, 0], [0, 21, 1],\n    [1, 14, 1], [2, 4, 1], [2, 5, 1], [2, 19, 1], [2, 23, 1], [3, 9, 1],\n    [5, 14, 1], [6, 7, 1], [6, 15, 1], [8, 18, 1], [9, 19, 1], [11, 24, 1],\n    [12, 17, 1], [14, 18, 1], [15, 18, 1], [17, 19, 1], [0, 7, 2], [1, 2, 2],\n    [1, 6, 2], [3, 15, 2], [3, 24, 2], [4, 7, 2], [6, 21, 2], [7, 18, 2],\n    [9, 14, 2], [10, 14, 2], [19, 23, 2], [20, 21, 2], [2, 3, 3], [2, 14, 3],\n    [2, 17, 3], [3, 7, 3], [3, 19, 3], [5, 6, 3], [6, 20, 3], [9, 22, 3],\n    [11, 18, 3], [13, 15, 3], [13, 21, 3], [16, 22, 3], [17, 23, 3], [1, 10, 4],\n    [1, 20, 4], [2, 6, 4], [2, 7, 4], [2, 8, 4], [2, 22, 4], [4, 18, 4],\n    [4, 20, 4], [7, 16, 4], [8, 10, 4], [8, 11, 4], [11, 12, 4], [11, 13, 4],\n    [14, 15, 4], [15, 23, 4], [16, 17, 4], [16, 18, 4], [18, 21, 4], [19, 24, 4]\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in edges:\n    G.add_edge(edge[0], edge[1])\n\n# Define the nodes to check for a closed triad\ntriad_nodes = [5, 2, 16]\n\n# Check if all edges between the three nodes exist\nclosed_triad = (\n    G.has_edge(triad_nodes[0], triad_nodes[1]) and\n    G.has_edge(triad_nodes[1], triad_nodes[0]) and\n    G.has_edge(triad_nodes[0], triad_nodes[2]) and\n    G.has_edge(triad_nodes[2], triad_nodes[0]) and\n    G.has_edge(triad_nodes[1], triad_nodes[2]) and\n    G.has_edge(triad_nodes[2], triad_nodes[1])\n)\n\n# Output result\nresult = \"yes\" if closed_triad else \"no\"\nprint(result)\n",
                "key_api": "networkx.DiGraph, networkx.DiGraph.add_edge, networkx.DiGraph.has_edge",
                "key_experience": "1. Define edges clearly to represent the graph structure. 2. Use loops to add edges to the graph efficiently. 3. Check for the existence of all required edges to determine if the nodes form a closed triad. 4. Use conditional checks to ascertain the presence of the closed triad and provide appropriate output."
            }
        ]
    },
    {
        "id": 35,
        "problem": "Determine if the path [16, 4, 13] is chronological in the dynamic graph.",
        "graph_type": "undirected dynamic",
        "experience": "The task involved determining if a given path [16, 4, 13] is chronological in a dynamic graph with timestamps. The process included defining the edges, setting up the graph using NetworkX, and then checking if the provided path exists in the order specified.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer whether a path is chronological in the dynamic graph. The time of the edges in a chronological path from source node to target node must not decrease, e.g., [2, 3, 5] is a chronological path in the dynamic graph [(2, 3, 0), (3, 5, 1)]\nGive the answer as yes or no at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(2, 12, 0), (2, 20, 0), (4, 21, 0), (6, 9, 0), (6, 11, 0), (6, 22, 0), (9, 19, 0), (9, 21, 0), (12, 24, 0), (13, 16, 0), (0, 13, 1), (0, 15, 1), (0, 22, 1), (0, 23, 1), (3, 23, 1), (4, 9, 1), (4, 18, 1), (5, 22, 1), (5, 24, 1), (6, 7, 1), (6, 13, 1), (6, 23, 1), (7, 17, 1), (9, 17, 1), (9, 22, 1), (9, 24, 1), (11, 22, 1), (12, 23, 1), (22, 23, 1), (0, 5, 2), (1, 13, 2), (1, 14, 2), (3, 21, 2), (4, 13, 2), (7, 9, 2), (7, 12, 2), (8, 9, 2), (11, 13, 2), (11, 15, 2), (12, 18, 2), (17, 21, 2), (18, 21, 2), (19, 24, 2), (20, 21, 2), (0, 6, 3), (0, 14, 3), (1, 8, 3), (2, 13, 3), (2, 21, 3), (4, 15, 3), (4, 24, 3), (5, 21, 3), (7, 14, 3), (7, 15, 3), (8, 10, 3), (8, 13, 3), (8, 24, 3), (10, 16, 3), (11, 18, 3), (14, 15, 3), (14, 18, 3), (14, 24, 3), (15, 18, 3), (16, 22, 3), (18, 24, 3), (0, 2, 4), (0, 3, 4), (1, 15, 4), (1, 22, 4), (2, 6, 4), (3, 19, 4), (4, 7, 4), (5, 17, 4), (6, 10, 4), (7, 20, 4), (7, 24, 4), (8, 15, 4), (8, 16, 4), (8, 21, 4), (10, 22, 4), (11, 12, 4), (11, 14, 4), (13, 14, 4), (14, 16, 4), (14, 23, 4), (15, 17, 4), (15, 19, 4), (16, 17, 4), (18, 23, 4)]. Is the path [16, 4, 13] a chronological path?\n",
                "code": "\nimport networkx as nx\n\n# Define the edges of the graph\nedges = [\n    [2, 12, 0], [2, 20, 0], [4, 21, 0], [6, 9, 0], [6, 11, 0], [6, 22, 0],\n    [9, 19, 0], [9, 21, 0], [12, 24, 0], [13, 16, 0], [0, 13, 1], [0, 15, 1],\n    [0, 22, 1], [0, 23, 1], [3, 23, 1], [4, 9, 1], [4, 18, 1], [5, 22, 1],\n    [5, 24, 1], [6, 7, 1], [6, 13, 1], [6, 23, 1], [7, 17, 1], [9, 17, 1],\n    [9, 22, 1], [9, 24, 1], [11, 22, 1], [12, 23, 1], [22, 23, 1], [0, 5, 2],\n    [1, 13, 2], [1, 14, 2], [3, 21, 2], [4, 13, 2], [7, 9, 2], [7, 12, 2],\n    [8, 9, 2], [11, 13, 2], [11, 15, 2], [12, 18, 2], [17, 21, 2], [18, 21, 2],\n    [19, 24, 2], [20, 21, 2], [0, 6, 3], [0, 14, 3], [1, 8, 3], [2, 13, 3],\n    [2, 21, 3], [4, 15, 3], [4, 24, 3], [5, 21, 3], [7, 14, 3], [7, 15, 3],\n    [8, 10, 3], [8, 13, 3], [8, 24, 3], [10, 16, 3], [11, 18, 3], [14, 15, 3],\n    [14, 18, 3], [14, 24, 3], [15, 18, 3], [16, 22, 3], [18, 24, 3], [0, 2, 4],\n    [0, 3, 4], [1, 15, 4], [1, 22, 4], [2, 6, 4], [3, 19, 4], [4, 7, 4],\n    [5, 17, 4], [6, 10, 4], [7, 20, 4], [7, 24, 4], [8, 15, 4], [8, 16, 4],\n    [8, 21, 4], [10, 22, 4], [11, 12, 4], [11, 14, 4], [13, 14, 4], [14, 16, 4],\n    [14, 23, 4], [15, 17, 4], [15, 19, 4], [16, 17, 4], [18, 23, 4]\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in edges:\n    G.add_edge(edge[0], edge[1], weight=edge[2])\n\n# Define the path to check\npath = [16, 4, 13]\n\n# Check if the path is chronological\nis_chronological = all(G.has_edge(path[i], path[i + 1]) for i in range(len(path) - 1))\n\n# Output the result\nprint(\"yes\" if is_chronological else \"no\")\n",
                "key_api": "The key API used in the code was NetworkX, specifically the nx.DiGraph class and methods such as G.add_edge() to add edges to the graph and G.has_edge() to check the existence of edges.",
                "key_experience": "1. Properly defining the graph structure and edges with timestamps.\n2. Utilizing NetworkX efficiently to handle the directed graph and its operations.\n3. Implementing a concise check for path continuity by iterating over the path elements.\n4. Formatting the code clearly and adding comments for readability and maintenance."
            }
        ]
    },
    {
        "id": 36,
        "problem": "Determine if the path [23, 20, 10] is chronological in the dynamic graph.",
        "graph_type": "undirected dynamic",
        "experience": "In a recent engagement with GPT-4o-mini, the task was to determine if a given path is chronological in a dynamically constructed graph using NetworkX. The user initially provided a full graph definition and a path, and GPT-4o-mini was guided to develop a function to verify the path. This experience highlighted the importance of correctly parsing and manipulating graph data structures as well as implementing path-checking logic.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer whether a path is chronological in the dynamic graph. The time of the edges in a chronological path from source node to target node must not decrease, e.g., [2, 3, 5] is a chronological path in the dynamic graph [(2, 3, 0), (3, 5, 1)]\nGive the answer as yes or no at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 2, 0), (0, 18, 0), (1, 10, 0), (1, 24, 0), (2, 11, 0), (4, 12, 0), (4, 15, 0), (4, 22, 0), (5, 7, 0), (5, 21, 0), (5, 23, 0), (6, 22, 0), (6, 24, 0), (7, 9, 0), (7, 19, 0), (8, 10, 0), (9, 13, 0), (9, 15, 0), (9, 17, 0), (9, 23, 0), (10, 19, 0), (11, 15, 0), (12, 23, 0), (13, 19, 0), (14, 17, 0), (15, 19, 0), (19, 23, 0), (0, 3, 1), (1, 4, 1), (1, 8, 1), (4, 5, 1), (4, 8, 1), (6, 15, 1), (7, 10, 1), (7, 12, 1), (7, 14, 1), (8, 19, 1), (9, 12, 1), (12, 16, 1), (12, 21, 1), (13, 15, 1), (13, 16, 1), (15, 16, 1), (17, 20, 1), (22, 24, 1), (0, 8, 2), (0, 21, 2), (1, 17, 2), (2, 3, 2), (2, 13, 2), (2, 20, 2), (6, 10, 2), (6, 13, 2), (8, 14, 2), (8, 23, 2), (12, 20, 2), (13, 17, 2), (0, 5, 3), (1, 6, 3), (1, 19, 3), (2, 22, 3), (3, 12, 3), (3, 13, 3), (3, 22, 3), (4, 9, 3), (5, 17, 3), (6, 11, 3), (7, 11, 3), (7, 13, 3), (7, 21, 3), (8, 11, 3), (8, 18, 3), (9, 16, 3), (10, 22, 3), (11, 24, 3), (12, 22, 3), (14, 23, 3), (20, 23, 3), (20, 24, 3), (0, 20, 4), (1, 9, 4), (2, 6, 4), (2, 18, 4), (2, 19, 4), (2, 21, 4), (3, 23, 4), (4, 7, 4), (4, 11, 4), (5, 18, 4), (5, 19, 4), (5, 20, 4), (6, 7, 4), (8, 13, 4), (8, 20, 4), (10, 15, 4), (10, 23, 4), (11, 22, 4), (13, 21, 4), (16, 23, 4)]. Is the path [23, 20, 10] a chronological path?\n",
                "code": "\nimport networkx as nx\n\n# Define the edges of the graph\nedges = [\n    [0, 2, 0], [0, 18, 0], [1, 10, 0], [1, 24, 0], [2, 11, 0], [4, 12, 0],\n    [4, 15, 0], [4, 22, 0], [5, 7, 0], [5, 21, 0], [5, 23, 0], [6, 22, 0],\n    [6, 24, 0], [7, 9, 0], [7, 19, 0], [8, 10, 0], [9, 13, 0], [9, 15, 0],\n    [9, 17, 0], [9, 23, 0], [10, 19, 0], [11, 15, 0], [12, 23, 0], [13, 19, 0],\n    [14, 17, 0], [15, 19, 0], [19, 23, 0], [0, 3, 1], [1, 4, 1], [1, 8, 1],\n    [4, 5, 1], [4, 8, 1], [6, 15, 1], [7, 10, 1], [7, 12, 1], [7, 14, 1],\n    [8, 19, 1], [9, 12, 1], [12, 16, 1], [12, 21, 1], [13, 15, 1], [13, 16, 1],\n    [15, 16, 1], [17, 20, 1], [22, 24, 1], [0, 8, 2], [0, 21, 2], [1, 17, 2],\n    [2, 3, 2], [2, 13, 2], [2, 20, 2], [6, 10, 2], [6, 13, 2], [8, 14, 2],\n    [8, 23, 2], [12, 20, 2], [13, 17, 2], [0, 5, 3], [1, 6, 3], [1, 19, 3],\n    [2, 22, 3], [3, 12, 3], [3, 13, 3], [3, 22, 3], [4, 9, 3], [5, 17, 3],\n    [6, 11, 3], [7, 11, 3], [7, 13, 3], [7, 21, 3], [8, 11, 3], [8, 18, 3],\n    [9, 16, 3], [10, 22, 3], [11, 24, 3], [12, 22, 3], [14, 23, 3], [20, 23, 3],\n    [20, 24, 3], [0, 20, 4], [1, 9, 4], [2, 6, 4], [2, 18, 4], [2, 19, 4],\n    [2, 21, 4], [3, 23, 4], [4, 7, 4], [4, 11, 4], [5, 18, 4], [5, 19, 4],\n    [5, 20, 4], [6, 7, 4], [8, 13, 4], [8, 20, 4], [10, 15, 4], [10, 23, 4],\n    [11, 22, 4], [13, 21, 4], [16, 23, 4]\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in edges:\n    G.add_edge(edge[0], edge[1])\n\n# Define the path to check\npath = [23, 20, 10]\n\n# Check if the path is chronological\ndef is_chronological_path(graph, path):\n    for i in range(len(path) - 1):\n        if not graph.has_edge(path[i], path[i + 1]):\n            return \"no\"\n    return \"yes\"\n\n# Output the result\nresult = is_chronological_path(G, path)\nprint(result)\n",
                "key_api": "networkx.DiGraph.add_edge(), networkx.DiGraph.has_edge()",
                "key_experience": "1. Accurately defining the structure and edges of the graph. 2. Iterating over the given path and checking for edge existence between consecutive nodes. 3. Returning a clear 'yes' or 'no' based on the presence of edges to ensure the path is chronological. 4. Using the DiGraph class from NetworkX for directed graph operations."
            }
        ]
    },
    {
        "id": 37,
        "problem": "Determine when node 21 and node 22 are first connected in the dynamic graph.",
        "graph_type": "undirected dynamic",
        "experience": "In this recent engagement, the task was to determine the first time nodes 21 and 22 are connected in a dynamic graph with evolving edges. We started by setting up the problem using NetworkX, a Python library for studying graphs and networks. The user provided a list of edges with associated timestamps. The process involved creating a directed graph and iteratively adding edges while checking if a path exists between nodes 21 and 22.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer when two nodes are first connected in the dynamic graph. Two nodes are connected if there exists a path between them.\nGive the answer as an integer number at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 21, 0), (1, 19, 0), (3, 8, 0), (4, 6, 0), (4, 23, 0), (5, 17, 0), (6, 23, 0), (6, 24, 0), (9, 12, 0), (10, 16, 0), (11, 24, 0), (13, 16, 0), (13, 20, 0), (13, 21, 0), (15, 20, 0), (16, 20, 0), (21, 22, 0), (1, 10, 1), (1, 20, 1), (3, 16, 1), (3, 18, 1), (3, 22, 1), (4, 17, 1), (5, 18, 1), (7, 22, 1), (8, 16, 1), (8, 18, 1), (11, 14, 1), (12, 20, 1), (16, 17, 1), (17, 23, 1), (17, 24, 1), (21, 24, 1), (22, 24, 1), (0, 18, 2), (0, 20, 2), (1, 5, 2), (1, 9, 2), (1, 23, 2), (2, 14, 2), (3, 5, 2), (3, 9, 2), (3, 15, 2), (3, 24, 2), (4, 8, 2), (4, 9, 2), (4, 10, 2), (6, 9, 2), (7, 15, 2), (8, 24, 2), (9, 11, 2), (9, 14, 2), (13, 18, 2), (14, 15, 2), (14, 24, 2), (15, 18, 2), (15, 24, 2), (19, 21, 2), (0, 11, 3), (1, 7, 3), (1, 17, 3), (2, 5, 3), (2, 17, 3), (3, 14, 3), (4, 19, 3), (6, 16, 3), (7, 13, 3), (7, 17, 3), (9, 13, 3), (10, 17, 3), (10, 19, 3), (10, 21, 3), (15, 19, 3), (15, 22, 3), (18, 20, 3), (23, 24, 3), (1, 12, 4), (2, 7, 4), (4, 18, 4), (4, 24, 4), (5, 8, 4), (6, 12, 4), (6, 18, 4), (7, 10, 4), (7, 24, 4), (9, 24, 4), (11, 20, 4), (12, 13, 4), (12, 18, 4), (12, 19, 4), (12, 22, 4), (12, 23, 4), (12, 24, 4), (14, 20, 4)]. When are node 21 and node 22 first connected?\n",
                "code": "\nimport networkx as nx\n\n# Input edges with their respective timestamps\nedges_with_time = [\n    [0, 21, 0], [1, 19, 0], [3, 8, 0], [4, 6, 0], [4, 23, 0], [5, 17, 0],\n    [6, 23, 0], [6, 24, 0], [9, 12, 0], [10, 16, 0], [11, 24, 0], [13, 16, 0],\n    [13, 20, 0], [13, 21, 0], [15, 20, 0], [16, 20, 0], [21, 22, 0], [1, 10, 1],\n    [1, 20, 1], [3, 16, 1], [3, 18, 1], [3, 22, 1], [4, 17, 1], [5, 18, 1],\n    [7, 22, 1], [8, 16, 1], [8, 18, 1], [11, 14, 1], [12, 20, 1], [16, 17, 1],\n    [17, 23, 1], [17, 24, 1], [21, 24, 1], [22, 24, 1], [0, 18, 2], [0, 20, 2],\n    [1, 5, 2], [1, 9, 2], [1, 23, 2], [2, 14, 2], [3, 5, 2], [3, 9, 2],\n    [3, 15, 2], [3, 24, 2], [4, 8, 2], [4, 9, 2], [4, 10, 2], [6, 9, 2],\n    [7, 15, 2], [8, 24, 2], [9, 11, 2], [9, 14, 2], [13, 18, 2], [14, 15, 2],\n    [14, 24, 2], [15, 18, 2], [15, 24, 2], [19, 21, 2], [0, 11, 3], [1, 7, 3],\n    [1, 17, 3], [2, 5, 3], [2, 17, 3], [3, 14, 3], [4, 19, 3], [6, 16, 3],\n    [7, 13, 3], [7, 17, 3], [9, 13, 3], [10, 17, 3], [10, 19, 3], [10, 21, 3],\n    [15, 19, 3], [15, 22, 3], [18, 20, 3], [23, 24, 3], [1, 12, 4], [2, 7, 4],\n    [4, 18, 4], [4, 24, 4], [5, 8, 4], [6, 12, 4], [6, 18, 4], [7, 10, 4],\n    [7, 24, 4], [9, 24, 4], [11, 20, 4], [12, 13, 4], [12, 18, 4], [12, 19, 4],\n    [12, 22, 4], [12, 23, 4], [12, 24, 4], [14, 20, 4]\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Initialize the time when nodes 21 and 22 are first connected\nfirst_connected_time = -1\n\n# Iterate through the edges and their timestamps\nfor u, v, time in edges_with_time:\n    # Add the directed edge to the graph\n    G.add_edge(u, v)\n\n    # Check if nodes 21 and 22 are connected\n    if nx.has_path(G, 21, 22):\n        first_connected_time = time\n        break  # Exit the loop once we find the first connection\n\n# Output the result\nprint(first_connected_time)\n",
                "key_api": "networkx (Graph creation, adding edges, checking connectivity with has_path)",
                "key_experience": "['Initialization of variables to store the timestamp when the nodes are first connected', 'Iteratively processing input data (edges with timestamps) to update the graph', 'Early stopping the loop once the desired condition (path existence) is met', \"Efficient checking of path existence using NetworkX's has_path method\"]"
            }
        ]
    },
    {
        "id": 38,
        "problem": "Determine when nodes 11 and 16 are first connected in the dynamic graph.",
        "graph_type": "undirected dynamic",
        "experience": "To determine when nodes 11 and 16 are first connected in a dynamic graph, we used NetworkX, a Python library for creating and manipulating complex networks. The user provided a list of edges with timestamps, and the task required us to iterate through these edges, update the graph, and check for a connection between the specific nodes. If a connection is found, we record the time and exit the loop.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer when two nodes are first connected in the dynamic graph. Two nodes are connected if there exists a path between them.\nGive the answer as an integer number at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(1, 11, 0), (2, 9, 0), (6, 22, 0), (7, 16, 0), (10, 13, 0), (10, 23, 0), (11, 22, 0), (12, 19, 0), (13, 19, 0), (13, 22, 0), (14, 19, 0), (16, 24, 0), (0, 4, 1), (1, 4, 1), (1, 6, 1), (1, 15, 1), (1, 21, 1), (2, 3, 1), (4, 22, 1), (5, 9, 1), (5, 14, 1), (8, 15, 1), (8, 19, 1), (9, 19, 1), (11, 16, 1), (12, 13, 1), (15, 17, 1), (15, 19, 1), (17, 24, 1), (0, 21, 2), (1, 12, 2), (1, 23, 2), (2, 17, 2), (3, 21, 2), (4, 23, 2), (5, 17, 2), (6, 15, 2), (7, 17, 2), (8, 11, 2), (9, 18, 2), (11, 13, 2), (11, 24, 2), (12, 24, 2), (13, 15, 2), (15, 16, 2), (18, 24, 2), (0, 8, 3), (0, 10, 3), (1, 19, 3), (2, 18, 3), (2, 21, 3), (3, 4, 3), (3, 5, 3), (3, 10, 3), (3, 18, 3), (3, 19, 3), (3, 24, 3), (4, 10, 3), (4, 13, 3), (5, 7, 3), (5, 21, 3), (7, 13, 3), (7, 14, 3), (7, 24, 3), (8, 9, 3), (9, 12, 3), (9, 22, 3), (10, 16, 3), (11, 21, 3), (11, 23, 3), (12, 21, 3), (17, 21, 3), (18, 21, 3), (0, 16, 4), (0, 19, 4), (1, 9, 4), (1, 16, 4), (3, 11, 4), (3, 14, 4), (3, 15, 4), (3, 23, 4), (4, 7, 4), (4, 17, 4), (5, 10, 4), (5, 19, 4), (6, 10, 4), (8, 14, 4), (9, 13, 4), (9, 20, 4), (10, 17, 4), (12, 14, 4), (14, 16, 4), (14, 20, 4), (14, 23, 4), (15, 21, 4), (15, 23, 4), (16, 18, 4), (19, 21, 4), (22, 23, 4)]. When are node 11 and node 16 first connected?\n",
                "code": "\nimport networkx as nx\n\n# Input edges\nedges = [\n    [1, 11, 0], [2, 9, 0], [6, 22, 0], [7, 16, 0], [10, 13, 0],\n    [10, 23, 0], [11, 22, 0], [12, 19, 0], [13, 19, 0], [13, 22, 0],\n    [14, 19, 0], [16, 24, 0], [0, 4, 1], [1, 4, 1], [1, 6, 1],\n    [1, 15, 1], [1, 21, 1], [2, 3, 1], [4, 22, 1], [5, 9, 1],\n    [5, 14, 1], [8, 15, 1], [8, 19, 1], [9, 19, 1], [11, 16, 1],\n    [12, 13, 1], [15, 17, 1], [15, 19, 1], [17, 24, 1], [0, 21, 2],\n    [1, 12, 2], [1, 23, 2], [2, 17, 2], [3, 21, 2], [4, 23, 2],\n    [5, 17, 2], [6, 15, 2], [7, 17, 2], [8, 11, 2], [9, 18, 2],\n    [11, 13, 2], [11, 24, 2], [12, 24, 2], [13, 15, 2], [15, 16, 2],\n    [18, 24, 2], [0, 8, 3], [0, 10, 3], [1, 19, 3], [2, 18, 3],\n    [2, 21, 3], [3, 4, 3], [3, 5, 3], [3, 10, 3], [3, 18, 3],\n    [3, 19, 3], [3, 24, 3], [4, 10, 3], [4, 13, 3], [5, 7, 3],\n    [5, 21, 3], [7, 13, 3], [7, 14, 3], [7, 24, 3], [8, 9, 3],\n    [9, 12, 3], [9, 22, 3], [10, 16, 3], [11, 21, 3], [11, 23, 3],\n    [12, 21, 3], [17, 21, 3], [18, 21, 3], [0, 16, 4], [0, 19, 4],\n    [1, 9, 4], [1, 16, 4], [3, 11, 4], [3, 14, 4], [3, 15, 4],\n    [3, 23, 4], [4, 7, 4], [4, 17, 4], [5, 10, 4], [5, 19, 4],\n    [6, 10, 4], [8, 14, 4], [9, 13, 4], [9, 20, 4], [10, 17, 4],\n    [12, 14, 4], [14, 16, 4], [14, 20, 4], [14, 23, 4], [15, 21, 4],\n    [15, 23, 4], [16, 18, 4], [19, 21, 4], [22, 23, 4]\n]\n\n# Create an empty graph\nG = nx.Graph()\n\n# Initialize a variable to store the first connection time\nfirst_connection_time = -1\n\n# Iterate through the edges and their corresponding timestamps\nfor edge in edges:\n    u, v, time = edge\n    G.add_edge(u, v)  # Add the edge to the graph\n\n    # Check if nodes 11 and 16 are connected\n    if nx.has_path(G, 11, 16):\n        first_connection_time = time\n        break  # Exit the loop once we find the first connection\n\n# Output the result\nprint(first_connection_time)\n",
                "key_api": "1. networkx.Graph(): Create an empty graph. 2. networkx.Graph.add_edge(): Add edges to the graph dynamically. 3. networkx.has_path(): Check if there is a path between two nodes in the graph.",
                "key_experience": "1. Iterate through edges with timestamps in sequence to dynamically update the graph. 2. Check for connections after each insertion of an edge to capture the first connection time. 3. Exit the loop immediately once the required connection is found to optimize performance."
            }
        ]
    },
    {
        "id": 39,
        "problem": "Determine when node 5 and node 13 are linked in the dynamic graph.",
        "graph_type": "undirected dynamic",
        "experience": "In the recent coding task, we were asked to determine at which time steps nodes 5 and 13 are linked in a dynamic graph. The input was given as a list of edges with their respective time steps. The solution involved parsing the input data, creating graph snapshots at each time step using the NetworkX library, and then checking for the presence of a specified edge in each snapshot.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer when two nodes are linked in the dynamic graph.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 8, 0), (2, 6, 0), (2, 8, 0), (2, 10, 0), (2, 19, 0), (2, 23, 0), (5, 16, 0), (5, 22, 0), (8, 11, 0), (8, 16, 0), (9, 14, 0), (9, 20, 0), (12, 17, 0), (14, 18, 0), (14, 19, 0), (16, 18, 0), (18, 23, 0), (20, 23, 0), (1, 6, 1), (1, 8, 1), (1, 20, 1), (3, 10, 1), (4, 9, 1), (5, 13, 1), (6, 11, 1), (7, 11, 1), (7, 16, 1), (7, 18, 1), (7, 20, 1), (9, 21, 1), (10, 15, 1), (10, 20, 1), (10, 24, 1), (15, 18, 1), (20, 21, 1), (0, 20, 2), (1, 5, 2), (1, 15, 2), (1, 22, 2), (2, 9, 2), (3, 20, 2), (4, 8, 2), (5, 14, 2), (6, 14, 2), (6, 15, 2), (8, 12, 2), (9, 11, 2), (10, 13, 2), (12, 13, 2), (17, 24, 2), (22, 23, 2), (23, 24, 2), (1, 9, 3), (1, 12, 3), (1, 16, 3), (2, 5, 3), (3, 4, 3), (3, 13, 3), (3, 14, 3), (3, 24, 3), (5, 8, 3), (5, 9, 3), (5, 10, 3), (6, 23, 3), (7, 19, 3), (8, 22, 3), (9, 10, 3), (11, 17, 3), (11, 19, 3), (11, 20, 3), (11, 21, 3), (11, 22, 3), (12, 16, 3), (12, 22, 3), (14, 15, 3), (17, 23, 3), (20, 22, 3), (20, 24, 3), (0, 4, 4), (1, 14, 4), (1, 21, 4), (2, 4, 4), (2, 11, 4), (4, 12, 4), (6, 9, 4), (6, 10, 4), (6, 24, 4), (7, 17, 4), (7, 22, 4), (8, 13, 4), (8, 19, 4), (8, 24, 4), (10, 16, 4), (15, 21, 4), (16, 19, 4), (16, 22, 4), (18, 21, 4)]. When are node 5 and node 13 linked?\n",
                "code": "\nimport networkx as nx\n\n# Input data representing edges in the format [source, target, time_step]\nedges = [\n    [0, 8, 0], [2, 6, 0], [2, 8, 0], [2, 10, 0], [2, 19, 0], [2, 23, 0],\n    [5, 16, 0], [5, 22, 0], [8, 11, 0], [8, 16, 0], [9, 14, 0], [9, 20, 0],\n    [12, 17, 0], [14, 18, 0], [14, 19, 0], [16, 18, 0], [18, 23, 0], [20, 23, 0],\n    [1, 6, 1], [1, 8, 1], [1, 20, 1], [3, 10, 1], [4, 9, 1], [5, 13, 1],\n    [6, 11, 1], [7, 11, 1], [7, 16, 1], [7, 18, 1], [7, 20, 1], [9, 21, 1],\n    [10, 15, 1], [10, 20, 1], [10, 24, 1], [15, 18, 1], [20, 21, 1], [0, 20, 2],\n    [1, 5, 2], [1, 15, 2], [1, 22, 2], [2, 9, 2], [3, 20, 2], [4, 8, 2],\n    [5, 14, 2], [6, 14, 2], [6, 15, 2], [8, 12, 2], [9, 11, 2], [10, 13, 2],\n    [12, 13, 2], [17, 24, 2], [22, 23, 2], [23, 24, 2], [1, 9, 3], [1, 12, 3],\n    [1, 16, 3], [2, 5, 3], [3, 4, 3], [3, 13, 3], [3, 14, 3], [3, 24, 3],\n    [5, 8, 3], [5, 9, 3], [5, 10, 3], [6, 23, 3], [7, 19, 3], [8, 22, 3],\n    [9, 10, 3], [11, 17, 3], [11, 19, 3], [11, 20, 3], [11, 21, 3], [11, 22, 3],\n    [12, 16, 3], [12, 22, 3], [14, 15, 3], [17, 23, 3], [20, 22, 3], [20, 24, 3],\n    [0, 4, 4], [1, 14, 4], [1, 21, 4], [2, 4, 4], [2, 11, 4], [4, 12, 4],\n    [6, 9, 4], [6, 10, 4], [6, 24, 4], [7, 17, 4], [7, 22, 4], [8, 13, 4],\n    [8, 19, 4], [8, 24, 4], [10, 16, 4], [15, 21, 4], [16, 19, 4], [16, 22, 4],\n    [18, 21, 4]\n]\n\n# Initialize a list to store the time steps when nodes 5 and 13 are linked\nlinked_time_steps = []\n\n# Create a dictionary to hold the graph snapshots\ngraph_snapshots = {}\n\n# Build the graph for each time step\nfor source, target, time_step in edges:\n    if time_step not in graph_snapshots:\n        graph_snapshots[time_step] = nx.Graph()\n    graph_snapshots[time_step].add_edge(source, target)\n\n# Check for the presence of an edge between nodes 5 and 13 in each snapshot\nfor time_step, graph in graph_snapshots.items():\n    if graph.has_edge(5, 13):\n        linked_time_steps.append(time_step)\n\n# Output the time steps when nodes 5 and 13 are linked\nprint(linked_time_steps)\n",
                "key_api": "networkx.Graph",
                "key_experience": "1. Parsing input data: We structured the input data to represent edges with their time steps 2. Dictionary for graph snapshots: We used a dictionary to hold different snapshots of the graph at each time step. 3. Iterative graph building: We iterated through the edges list to build the graph for each time step and stored it in the dictionary. 4. Edge existence check: We checked for the presence of a specific edge (nodes 5 and 13) in each graph snapshot and recorded the time steps when the edge was present."
            }
        ]
    },
    {
        "id": 40,
        "problem": "Determine when node 22 and node 3 are linked in the dynamic graph.",
        "graph_type": "undirected dynamic",
        "experience": "The task involved solving a dynamic graph problem where we needed to check if two nodes are linked at any time. Initially, the solution handled only direct connections between nodes, but upon realizing that nodes might be connected indirectly, the approach evolved to checking for connected components at each time step using graph traversal methods. The final solution built a time-based graph and ensured that both nodes existed in the graph before checking for paths.",
        "rag_data": [],
        "accuracy": 0.9,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer when two nodes are linked in the dynamic graph.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 2, 0), (0, 18, 0), (1, 10, 0), (1, 24, 0), (2, 11, 0), (4, 12, 0), (4, 15, 0), (4, 22, 0), (5, 7, 0), (5, 21, 0), (5, 23, 0), (6, 22, 0), (6, 24, 0), (7, 9, 0), (7, 19, 0), (8, 10, 0), (9, 13, 0), (9, 15, 0), (9, 17, 0), (9, 23, 0), (10, 19, 0), (11, 15, 0), (12, 23, 0), (13, 19, 0), (14, 17, 0), (15, 19, 0), (19, 23, 0), (0, 3, 1), (1, 4, 1), (1, 8, 1), (4, 5, 1), (4, 8, 1), (6, 15, 1), (7, 10, 1), (7, 12, 1), (7, 14, 1), (8, 19, 1), (9, 12, 1), (12, 16, 1), (12, 21, 1), (13, 15, 1), (13, 16, 1), (15, 16, 1), (17, 20, 1), (22, 24, 1), (0, 8, 2), (0, 21, 2), (1, 17, 2), (2, 3, 2), (2, 13, 2), (2, 20, 2), (6, 10, 2), (6, 13, 2), (8, 14, 2), (8, 23, 2), (12, 20, 2), (13, 17, 2), (0, 5, 3), (1, 6, 3), (1, 19, 3), (2, 22, 3), (3, 12, 3), (3, 13, 3), (3, 22, 3), (4, 9, 3), (5, 17, 3), (6, 11, 3), (7, 11, 3), (7, 13, 3), (7, 21, 3), (8, 11, 3), (8, 18, 3), (9, 16, 3), (10, 22, 3), (11, 24, 3), (12, 22, 3), (14, 23, 3), (20, 23, 3), (20, 24, 3), (0, 20, 4), (1, 9, 4), (2, 6, 4), (2, 18, 4), (2, 19, 4), (2, 21, 4), (3, 23, 4), (4, 7, 4), (4, 11, 4), (5, 18, 4), (5, 19, 4), (5, 20, 4), (6, 7, 4), (8, 13, 4), (8, 20, 4), (10, 15, 4), (10, 23, 4), (11, 22, 4), (13, 21, 4), (16, 23, 4)]. When are node 22 and node 3 linked?\n",
                "code": "import networkx as nx\n\n# List of edges in the form (u, v, t) where u and v are nodes and t is the time\nedges = [(0, 2, 0), (0, 18, 0), (1, 10, 0), (1, 24, 0), (2, 11, 0), (4, 12, 0), (4, 15, 0), \n         (4, 22, 0), (5, 7, 0), (5, 21, 0), (5, 23, 0), (6, 22, 0), (6, 24, 0), (7, 9, 0), \n         (7, 19, 0), (8, 10, 0), (9, 13, 0), (9, 15, 0), (9, 17, 0), (9, 23, 0), (10, 19, 0), \n         (11, 15, 0), (12, 23, 0), (13, 19, 0), (14, 17, 0), (15, 19, 0), (19, 23, 0), (0, 3, 1), \n         (1, 4, 1), (1, 8, 1), (4, 5, 1), (4, 8, 1), (6, 15, 1), (7, 10, 1), (7, 12, 1), (7, 14, 1), \n         (8, 19, 1), (9, 12, 1), (12, 16, 1), (12, 21, 1), (13, 15, 1), (13, 16, 1), (15, 16, 1), \n         (17, 20, 1), (22, 24, 1), (0, 8, 2), (0, 21, 2), (1, 17, 2), (2, 3, 2), (2, 13, 2), \n         (2, 20, 2), (6, 10, 2), (6, 13, 2), (8, 14, 2), (8, 23, 2), (12, 20, 2), (13, 17, 2), \n         (0, 5, 3), (1, 6, 3), (1, 19, 3), (2, 22, 3), (3, 12, 3), (3, 13, 3), (3, 22, 3), (4, 9, 3), \n         (5, 17, 3), (6, 11, 3), (7, 11, 3), (7, 13, 3), (7, 21, 3), (8, 11, 3), (8, 18, 3), \n         (9, 16, 3), (10, 22, 3), (11, 24, 3), (12, 22, 3), (14, 23, 3), (20, 23, 3), (20, 24, 3), \n         (0, 20, 4), (1, 9, 4), (2, 6, 4), (2, 18, 4), (2, 19, 4), (2, 21, 4), (3, 23, 4), \n         (4, 7, 4), (4, 11, 4), (5, 18, 4), (5, 19, 4), (5, 20, 4), (6, 7, 4), (8, 13, 4), \n         (8, 20, 4), (10, 15, 4), (10, 23, 4), (11, 22, 4), (13, 21, 4), (16, 23, 4)]\n\n# Function to build the graph for each time and check if two nodes are connected\ndef find_connected_times(edges, node1, node2):\n    # Dictionary to store graphs for each time step\n    time_graphs = {}\n\n    # Build the graph for each time step\n    for u, v, t in edges:\n        if t not in time_graphs:\n            time_graphs[t] = nx.Graph()\n        time_graphs[t].add_edge(u, v)\n\n    # List to store the times when the two nodes are connected\n    connected_times = []\n\n    # Check if the two nodes are connected in each time step\n    for t, graph in time_graphs.items():\n        # Ensure both nodes exist in the graph\n        if graph.has_node(node1) and graph.has_node(node2):\n            if nx.has_path(graph, node1, node2):\n                connected_times.append(t)\n\n    return connected_times\n\n# Call the function to find the connected times for nodes 22 and 3\nconnected_times = find_connected_times(edges, 22, 3)\n\n# Output the result\nprint(connected_times)\n",
                "key_api": "The key API used in the code was NetworkX's 'has_path' method, which checks if two nodes are connected in a graph. The 'Graph' class was also crucial for building dynamic graphs.",
                "key_experience": "Best practices included ensuring the presence of both nodes in the graph before performing path checks, handling dynamic time-based graphs efficiently, and building the graph incrementally for each time step. This approach ensured the solution was robust for both direct and indirect connections in the graph."
            }
        ]
    },
    {
        "id": 41,
        "problem": "Find a chronological path starting at node 7 with a length no less than 3.",
        "graph_type": "undirected dynamic",
        "experience": "In solving the graph problem, I built an adjacency list with time stamps from the given edge list, treating the graph as undirected. I implemented a depth-first search (DFS) starting from node 7. The DFS function recursively explores neighboring nodes, ensuring edges are traversed in chronological order by sorting them based on time stamps. I avoided revisiting nodes to prevent cycles and checked that the path length meets the minimum requirement of 3.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer whether a path is chronological in the dynamic graph. The time of the edges in a chronological path from source node to target node must not decrease, e.g., [2, 3, 5] is a chronological path in the dynamic graph [(2, 3, 0), (3, 5, 1)]\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 9, 0), (0, 17, 0), (0, 20, 0), (3, 12, 0), (4, 18, 0), (5, 10, 0), (5, 16, 0), (5, 23, 0), (6, 18, 0), (7, 13, 0), (8, 13, 0), (9, 22, 0), (11, 21, 0), (11, 23, 0), (13, 18, 0), (14, 17, 0), (15, 18, 0), (15, 20, 0), (16, 21, 0), (19, 22, 0), (22, 24, 0), (0, 10, 1), (0, 21, 1), (1, 5, 1), (3, 6, 1), (3, 7, 1), (3, 18, 1), (3, 23, 1), (4, 6, 1), (4, 15, 1), (5, 9, 1), (5, 21, 1), (6, 9, 1), (6, 10, 1), (6, 21, 1), (7, 19, 1), (8, 23, 1), (9, 15, 1), (10, 11, 1), (10, 20, 1), (12, 20, 1), (14, 18, 1), (14, 19, 1), (18, 23, 1), (1, 8, 2), (1, 10, 2), (1, 20, 2), (2, 13, 2), (5, 20, 2), (7, 11, 2), (7, 23, 2), (8, 24, 2), (9, 11, 2), (11, 24, 2), (12, 14, 2), (13, 17, 2), (15, 23, 2), (20, 23, 2), (0, 1, 3), (0, 14, 3), (1, 13, 3), (5, 19, 3), (5, 24, 3), (6, 12, 3), (6, 22, 3), (7, 15, 3), (10, 12, 3), (10, 19, 3), (11, 12, 3), (13, 14, 3), (14, 24, 3), (16, 19, 3), (16, 20, 3), (16, 23, 3), (17, 22, 3), (0, 4, 4), (1, 2, 4), (1, 4, 4), (1, 9, 4), (1, 12, 4), (1, 17, 4), (2, 12, 4), (2, 16, 4), (5, 8, 4), (6, 13, 4), (7, 8, 4), (7, 12, 4), (8, 14, 4), (10, 14, 4), (13, 16, 4), (15, 21, 4), (15, 24, 4), (17, 21, 4), (17, 24, 4), (18, 20, 4), (18, 21, 4), (20, 22, 4)]. Find a chronological path starting at node 7 with a length no less that 3. \n",
                "code": "edges = [[0, 9, 0], [0, 17, 0], [0, 20, 0], [3, 12, 0], [4, 18, 0], [5, 10, 0], [5, 16, 0], [5, 23, 0], [6, 18, 0], [7, 13, 0], [8, 13, 0], [9, 22, 0], [11, 21, 0], [11, 23, 0], [13, 18, 0], [14, 17, 0], [15, 18, 0], [15, 20, 0], [16, 21, 0], [19, 22, 0], [22, 24, 0], [0, 10, 1], [0, 21, 1], [1, 5, 1], [3, 6, 1], [3, 7, 1], [3, 18, 1], [3, 23, 1], [4, 6, 1], [4, 15, 1], [5, 9, 1], [5, 21, 1], [6, 9, 1], [6, 10, 1], [6, 21, 1], [7, 19, 1], [8, 23, 1], [9, 15, 1], [10, 11, 1], [10, 20, 1], [12, 20, 1], [14, 18, 1], [14, 19, 1], [18, 23, 1], [1, 8, 2], [1, 10, 2], [1, 20, 2], [2, 13, 2], [5, 20, 2], [7, 11, 2], [7, 23, 2], [8, 24, 2], [9, 11, 2], [11, 24, 2], [12, 14, 2], [13, 17, 2], [15, 23, 2], [20, 23, 2], [0, 1, 3], [0, 14, 3], [1, 13, 3], [5, 19, 3], [5, 24, 3], [6, 12, 3], [6, 22, 3], [7, 15, 3], [10, 12, 3], [10, 19, 3], [11, 12, 3], [13, 14, 3], [14, 24, 3], [16, 19, 3], [16, 20, 3], [16, 23, 3], [17, 22, 3], [0, 4, 4], [1, 2, 4], [1, 4, 4], [1, 9, 4], [1, 12, 4], [1, 17, 4], [2, 12, 4], [2, 16, 4], [5, 8, 4], [6, 13, 4], [7, 8, 4], [7, 12, 4], [8, 14, 4], [10, 14, 4], [13, 16, 4], [15, 21, 4], [15, 24, 4], [17, 21, 4], [17, 24, 4], [18, 20, 4], [18, 21, 4], [20, 22, 4]]\n\nfrom collections import defaultdict\n\n# Build adjacency list with time stamps\nadj = defaultdict(list)\nfor u, v, t in edges:\n    adj[u].append((v, t))\n    adj[v].append((u, t))  # Since the graph is undirected\n\ndef dfs(node, path, time):\n    if len(path) >= 4:\n        return path\n    for neighbor, edge_time in sorted(adj[node], key=lambda x: x[1]):\n        if neighbor not in path:\n            if time is None or edge_time >= time:\n                result = dfs(neighbor, path + [neighbor], edge_time)\n                if result:\n                    return result\n    return None\n\n# Start DFS from node 7\npath = dfs(7, [7], None)\nprint(path)",
                "key_api": "Used collections.defaultdict to create the adjacency list; utilized the sorted() function with a lambda key to sort neighbors by time stamps; implemented a recursive DFS function.",
                "key_experience": "Efficiently representing the graph using an adjacency list; correctly handling undirected edges; sorting neighbors to ensure chronological traversal; preventing cycles by tracking visited nodes; employing recursion for depth-first search; validating the path length against the problem's requirement."
            }
        ]
    },
    {
        "id": 42,
        "problem": "Find a chronological path starting at node 7 with a length no less than 3.",
        "graph_type": "undirected dynamic",
        "experience": "The task involved finding a chronological path in an undirected dynamic graph using NetworkX. Initially, a standard Graph was used, but it failed to handle multiple edges between the same nodes with different timestamps. The solution was improved by switching to a MultiGraph, which supports multiple edges. A recursive depth-first search (DFS) was implemented to explore paths while ensuring that the edge timestamps are non-decreasing. Error handling was added to manage multiple edges and prevent cycles by tracking visited nodes.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to answer whether a path is chronological in the dynamic graph. The time of the edges in a chronological path from source node to target node must not decrease, e.g., [2, 3, 5] is a chronological path in the dynamic graph [(2, 3, 0), (3, 5, 1)]\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(0, 9, 0), (0, 17, 0), (0, 20, 0), (3, 12, 0), (4, 18, 0), (5, 10, 0), (5, 16, 0), (5, 23, 0), (6, 18, 0), (7, 13, 0), (8, 13, 0), (9, 22, 0), (11, 21, 0), (11, 23, 0), (13, 18, 0), (14, 17, 0), (15, 18, 0), (15, 20, 0), (16, 21, 0), (19, 22, 0), (22, 24, 0), (0, 10, 1), (0, 21, 1), (1, 5, 1), (3, 6, 1), (3, 7, 1), (3, 18, 1), (3, 23, 1), (4, 6, 1), (4, 15, 1), (5, 9, 1), (5, 21, 1), (6, 9, 1), (6, 10, 1), (6, 21, 1), (7, 19, 1), (8, 23, 1), (9, 15, 1), (10, 11, 1), (10, 20, 1), (12, 20, 1), (14, 18, 1), (14, 19, 1), (18, 23, 1), (1, 8, 2), (1, 10, 2), (1, 20, 2), (2, 13, 2), (5, 20, 2), (7, 11, 2), (7, 23, 2), (8, 24, 2), (9, 11, 2), (11, 24, 2), (12, 14, 2), (13, 17, 2), (15, 23, 2), (20, 23, 2), (0, 1, 3), (0, 14, 3), (1, 13, 3), (5, 19, 3), (5, 24, 3), (6, 12, 3), (6, 22, 3), (7, 15, 3), (10, 12, 3), (10, 19, 3), (11, 12, 3), (13, 14, 3), (14, 24, 3), (16, 19, 3), (16, 20, 3), (16, 23, 3), (17, 22, 3), (0, 4, 4), (1, 2, 4), (1, 4, 4), (1, 9, 4), (1, 12, 4), (1, 17, 4), (2, 12, 4), (2, 16, 4), (5, 8, 4), (6, 13, 4), (7, 8, 4), (7, 12, 4), (8, 14, 4), (10, 14, 4), (13, 16, 4), (15, 21, 4), (15, 24, 4), (17, 21, 4), (17, 24, 4), (18, 20, 4), (18, 21, 4), (20, 22, 4)]. Find a chronological path starting at node 7 with a length no less that 3. \n",
                "code": "import networkx as nx\n\n# Define the input edges with their timestamps\nedges = [\n    [0, 9, 0], [0, 17, 0], [0, 20, 0], [3, 12, 0], [4, 18, 0],\n    [5, 10, 0], [5, 16, 0], [5, 23, 0], [6, 18, 0], [7, 13, 0],\n    [8, 13, 0], [9, 22, 0], [11, 21, 0], [11, 23, 0], [13, 18, 0],\n    [14, 17, 0], [15, 18, 0], [15, 20, 0], [16, 21, 0], [19, 22, 0],\n    [22, 24, 0], [0, 10, 1], [0, 21, 1], [1, 5, 1], [3, 6, 1],\n    [3, 7, 1], [3, 18, 1], [3, 23, 1], [4, 6, 1], [4, 15, 1],\n    [5, 9, 1], [5, 21, 1], [6, 9, 1], [6, 10, 1], [6, 21, 1],\n    [7, 19, 1], [8, 23, 1], [9, 15, 1], [10, 11, 1], [10, 20, 1],\n    [12, 20, 1], [14, 18, 1], [14, 19, 1], [18, 23, 1],\n    [1, 8, 2], [1, 10, 2], [1, 20, 2], [2, 13, 2], [5, 20, 2],\n    [7, 11, 2], [7, 23, 2], [8, 24, 2], [9, 11, 2], [11, 24, 2],\n    [12, 14, 2], [13, 17, 2], [15, 23, 2], [20, 23, 2],\n    [0, 1, 3], [0, 14, 3], [1, 13, 3], [5, 19, 3], [5, 24, 3],\n    [6, 12, 3], [6, 22, 3], [7, 15, 3], [10, 12, 3], [10, 19, 3],\n    [11, 12, 3], [13, 14, 3], [14, 24, 3], [16, 19, 3],\n    [16, 20, 3], [16, 23, 3], [17, 22, 3], [0, 4, 4],\n    [1, 2, 4], [1, 4, 4], [1, 9, 4], [1, 12, 4], [1, 17, 4],\n    [2, 12, 4], [2, 16, 4], [5, 8, 4], [6, 13, 4], [7, 8, 4],\n    [7, 12, 4], [8, 14, 4], [10, 14, 4], [13, 16, 4],\n    [15, 21, 4], [15, 24, 4], [17, 21, 4], [17, 24, 4],\n    [18, 20, 4], [18, 21, 4], [20, 22, 4]\n]\n\n# Create a list of edges with timestamps\n# Each edge is represented as (node1, node2, timestamp)\nedge_list = [(u, v, {'timestamp': t}) for u, v, t in edges]\n\n# Initialize an undirected MultiGraph to allow multiple edges between the same nodes\nG = nx.MultiGraph()\nG.add_edges_from(edge_list)\n\ndef find_chronological_path(G, start, min_length):\n    \"\"\"\n    Finds a chronological path starting at 'start' with length >= min_length.\n    A chronological path has non-decreasing edge timestamps.\n    \"\"\"\n    def dfs(current_node, path, last_timestamp):\n        if len(path) - 1 >= min_length:\n            return path\n        for neighbor in G.neighbors(current_node):\n            if neighbor in path:\n                continue  # Avoid cycles\n            # Iterate over all edges between current_node and neighbor\n            for key, edge_data in G.get_edge_data(current_node, neighbor, default={}).items():\n                t = edge_data['timestamp']\n                if t >= last_timestamp:\n                    result = dfs(neighbor, path + [neighbor], t)\n                    if result:\n                        return result\n        return None\n\n    return dfs(start, [start], -1)\n\n# Find a chronological path starting at node 7 with length no less than 3\npath = find_chronological_path(G, 7, 3)\n\n# Output the path as a Python list\nprint(path if path else \"No path found\")",
                "key_api": "networkx.MultiGraph, add_edges_from(), get_edge_data(), neighbors()",
                "key_experience": "Choosing the appropriate graph data structure (MultiGraph) for handling multiple edges, implementing recursive DFS with constraints on edge timestamps, avoiding cycles by tracking visited nodes, iterating over all edges between nodes to consider different timestamps, ensuring chronological order in path traversal."
            }
        ]
    },
    {
        "id": 43,
        "problem": "Sort the edges in the dynamic graph by time from earliest to latest.",
        "graph_type": "undirected dynamic",
        "experience": "To solve the task of sorting the edges in a dynamic graph based on the time from earliest to latest, the following steps were taken: 1) Define the input list of edges. 2) Use Python's sorted() function to sort the list based on the time attribute (the last element in each sub-list). This was achieved using a lambda function as the key for sorting.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to sort the edges in the dynamic graph by time from earlest to latest.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(19, 20, 4), (0, 18, 4), (9, 14, 4), (5, 20, 3), (5, 12, 1), (10, 19, 0), (14, 19, 1), (10, 17, 4), (5, 15, 4), (16, 21, 3), (10, 12, 3), (1, 17, 4), (13, 21, 2), (6, 15, 1), (14, 16, 0), (8, 22, 4), (6, 23, 3), (13, 22, 1), (6, 17, 4), (4, 15, 1), (12, 19, 3), (15, 21, 2), (6, 20, 0), (7, 10, 4), (6, 14, 2), (16, 20, 0), (5, 9, 3), (16, 24, 1), (5, 13, 3), (12, 13, 1), (3, 14, 2), (5, 7, 2), (9, 17, 2), (13, 23, 1), (7, 20, 4), (4, 22, 3), (7, 14, 1), (14, 15, 2), (0, 10, 3), (8, 14, 4), (8, 16, 3), (1, 8, 4), (12, 14, 0), (4, 23, 3), (7, 8, 1), (5, 11, 2), (1, 18, 0), (2, 14, 1), (10, 18, 4), (7, 23, 1), (8, 15, 3), (0, 22, 0), (1, 20, 2), (2, 8, 2), (11, 21, 1), (3, 9, 3), (6, 12, 1), (9, 15, 0), (13, 18, 2), (2, 23, 0), (11, 23, 0), (4, 19, 1), (0, 5, 0), (3, 10, 4), (16, 19, 1), (18, 19, 0), (6, 13, 3), (12, 16, 0), (9, 13, 3), (5, 8, 3), (7, 16, 1), (5, 23, 4), (3, 16, 2), (20, 24, 1), (1, 14, 2), (16, 18, 1), (0, 6, 4), (17, 21, 4), (14, 23, 1), (22, 24, 0), (11, 22, 0), (9, 20, 3), (0, 2, 4), (3, 4, 0), (0, 3, 4), (5, 24, 1), (20, 21, 0)]. Sort the edges in the dynamic graph by time from earliest to latest. \n",
                "code": "\n# Define the input list of edges\nedges = [\n    [19, 20, 4], [0, 18, 4], [9, 14, 4], [5, 20, 3], [5, 12, 1],\n    [10, 19, 0], [14, 19, 1], [10, 17, 4], [5, 15, 4], [16, 21, 3],\n    [10, 12, 3], [1, 17, 4], [13, 21, 2], [6, 15, 1], [14, 16, 0],\n    [8, 22, 4], [6, 23, 3], [13, 22, 1], [6, 17, 4], [4, 15, 1],\n    [12, 19, 3], [15, 21, 2], [6, 20, 0], [7, 10, 4], [6, 14, 2],\n    [16, 20, 0], [5, 9, 3], [16, 24, 1], [5, 13, 3], [12, 13, 1],\n    [3, 14, 2], [5, 7, 2], [9, 17, 2], [13, 23, 1], [7, 20, 4],\n    [4, 22, 3], [7, 14, 1], [14, 15, 2], [0, 10, 3], [8, 14, 4],\n    [8, 16, 3], [1, 8, 4], [12, 14, 0], [4, 23, 3], [7, 8, 1],\n    [5, 11, 2], [1, 18, 0], [2, 14, 1], [10, 18, 4], [7, 23, 1],\n    [8, 15, 3], [0, 22, 0], [1, 20, 2], [2, 8, 2], [11, 21, 1],\n    [3, 9, 3], [6, 12, 1], [9, 15, 0], [13, 18, 2], [2, 23, 0],\n    [11, 23, 0], [4, 19, 1], [0, 5, 0], [3, 10, 4], [16, 19, 1],\n    [18, 19, 0], [6, 13, 3], [12, 16, 0], [9, 13, 3], [5, 8, 3],\n    [7, 16, 1], [5, 23, 4], [3, 16, 2], [20, 24, 1], [1, 14, 2],\n    [16, 18, 1], [0, 6, 4], [17, 21, 4], [14, 23, 1], [22, 24, 0],\n    [11, 22, 0], [9, 20, 3], [0, 2, 4], [3, 4, 0], [0, 3, 4],\n    [5, 24, 1], [20, 21, 0]\n]\n\n# Sort the edges by the time value (third element)\nsorted_edges = sorted(edges, key=lambda x: x[2])\n\n# Output the sorted edges\nprint(sorted_edges)\n",
                "key_api": "sorted() function with a lambda function.",
                "key_experience": "1) Clearly define the input data structure. 2) Use a built-in Python function for sorting. 3) Leverage lambda functions for concise and readable code."
            }
        ]
    },
    {
        "id": 44,
        "problem": "Sort the edges in the dynamic graph by time from earliest to latest.",
        "graph_type": "undirected dynamic",
        "experience": "To solve the problem of sorting edges in a dynamic graph by time from earliest to latest, we can utilize libraries like NetworkX for added functionalities, although for simple sorting, Python's built-in functionalities will suffice. The problem required sorting tuples (edges) based on their third element (time).\n\nSteps to solve the problem:\n1. Read the input list of edges.\n2. Use Python's `sorted()` function with a key parameter to sort based on the third element (time) of each edge tuple.\n3. Return the sorted list of edges.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected dynamic graph, (u, v, t) means that node u and node v are linked with an undirected edge at time t.\nYour task is to sort the edges in the dynamic graph by time from earlest to latest.\nGive the answer as a python list at the last of your response after 'Answer:'.\nQuestion: Given an undirected dynamic graph with the edges [(7, 23, 2), (0, 4, 4), (1, 4, 4), (1, 10, 2), (0, 1, 3), (6, 21, 1), (6, 22, 3), (16, 21, 0), (8, 14, 4), (5, 24, 3), (4, 18, 0), (2, 13, 2), (16, 20, 3), (11, 12, 3), (5, 9, 1), (6, 18, 0), (5, 21, 1), (1, 20, 2), (6, 10, 1), (12, 20, 1), (0, 17, 0), (0, 14, 3), (4, 15, 1), (9, 22, 0), (0, 9, 0), (3, 18, 1), (7, 19, 1), (1, 8, 2), (8, 24, 2), (3, 12, 0), (14, 18, 1), (7, 12, 4), (4, 6, 1), (15, 18, 0), (18, 20, 4), (1, 9, 4), (10, 11, 1), (3, 23, 1), (13, 14, 3), (7, 8, 4), (9, 15, 1), (8, 23, 1), (16, 23, 3), (17, 21, 4), (5, 8, 4), (7, 13, 0), (6, 13, 4), (15, 21, 4), (9, 11, 2), (5, 16, 0), (18, 23, 1), (1, 12, 4), (10, 19, 3), (13, 18, 0), (7, 11, 2), (6, 12, 3), (19, 22, 0), (20, 23, 2), (10, 14, 4), (10, 20, 1), (0, 10, 1), (3, 7, 1), (15, 23, 2), (5, 19, 3), (13, 17, 2), (17, 24, 4), (11, 24, 2), (20, 22, 4), (0, 21, 1), (1, 2, 4), (13, 16, 4), (14, 19, 1), (15, 20, 0), (5, 10, 0), (14, 17, 0), (1, 17, 4), (5, 20, 2), (16, 19, 3), (10, 12, 3), (14, 24, 3), (12, 14, 2), (18, 21, 4), (0, 20, 0), (2, 16, 4), (15, 24, 4), (1, 13, 3), (7, 15, 3), (11, 21, 0), (6, 9, 1), (22, 24, 0), (17, 22, 3), (3, 6, 1), (5, 23, 0), (2, 12, 4), (1, 5, 1), (8, 13, 0), (11, 23, 0)]. Sort the edges in the dynamic graph by time from earliest to latest. \n",
                "code": "\n# Input: List of edges where each edge is represented as [node1, node2, time]\nedges = [\n    [7, 23, 2], [0, 4, 4], [1, 4, 4], [1, 10, 2], [0, 1, 3], [6, 21, 1],\n    [6, 22, 3], [16, 21, 0], [8, 14, 4], [5, 24, 3], [4, 18, 0], [2, 13, 2],\n    [16, 20, 3], [11, 12, 3], [5, 9, 1], [6, 18, 0], [5, 21, 1], [1, 20, 2],\n    [6, 10, 1], [12, 20, 1], [0, 17, 0], [0, 14, 3], [4, 15, 1], [9, 22, 0],\n    [0, 9, 0], [3, 18, 1], [7, 19, 1], [1, 8, 2], [8, 24, 2], [3, 12, 0],\n    [14, 18, 1], [7, 12, 4], [4, 6, 1], [15, 18, 0], [18, 20, 4], [1, 9, 4],\n    [10, 11, 1], [3, 23, 1], [13, 14, 3], [7, 8, 4], [9, 15, 1], [8, 23, 1],\n    [16, 23, 3], [17, 21, 4], [5, 8, 4], [7, 13, 0], [6, 13, 4], [15, 21, 4],\n    [9, 11, 2], [5, 16, 0], [18, 23, 1], [1, 12, 4], [10, 19, 3], [13, 18, 0],\n    [7, 11, 2], [6, 12, 3], [19, 22, 0], [20, 23, 2], [10, 14, 4], [10, 20, 1],\n    [0, 10, 1], [3, 7, 1], [15, 23, 2], [5, 19, 3], [13, 17, 2], [17, 24, 4],\n    [11, 24, 2], [20, 22, 4], [0, 21, 1], [1, 2, 4], [13, 16, 4], [14, 19, 1],\n    [15, 20, 0], [5, 10, 0], [14, 17, 0], [1, 17, 4], [5, 20, 2], [16, 19, 3],\n    [10, 12, 3], [14, 24, 3], [12, 14, 2], [18, 21, 4], [0, 20, 0], [2, 16, 4],\n    [15, 24, 4], [1, 13, 3], [7, 15, 3], [11, 21, 0], [6, 9, 1], [22, 24, 0],\n    [17, 22, 3], [3, 6, 1], [5, 23, 0], [2, 12, 4], [1, 5, 1], [8, 13, 0],\n    [11, 23, 0]\n]\n\n# Sort edges by the time value (the third element in each sublist)\nsorted_edges = sorted(edges, key=lambda x: x[2])\n\n# Output the sorted list of edges\nprint(sorted_edges)\n",
                "key_api": "NetworkX (optional but beneficial for more complex graph operations); built-in `sorted()` function with `key` parameter.",
                "key_experience": "1. Utilize Python\u2019s built-in sorting functions for quick and efficient sorting.\n2. Ensure the sorting key is correctly specified to sort based on the time attribute.\n3. Encapsulate the solution in a simple and reusable function for clarity and reusability."
            }
        ]
    },
    {
        "id": 45,
        "problem": "Determine if there is a path between node 13 and node 5.",
        "graph_type": "undirected",
        "experience": "The task involves determining if there is a path between two nodes in a graph using the NetworkX library in Python. The engagement focused on constructing an undirected graph from given edges, utilizing the `has_path` function to verify connectivity between the specified nodes, and outputting the result. The interaction included creating a list of edges, constructing the graph, and then checking for the path existence.",
        "rag_data": [
            {
                "Section ID": "has_path",
                "Description": [
                    "Returns True if G has a path from source to target ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node": "Starting node for path",
                        "target : node": "Ending node for path"
                    }
                },
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine if there is a path between two nodes in the graph. Note that (i,j) means that node i and node j are connected with an undirected edge.\nGraph: (0,5) (0,1) (1,11) (1,5) (1,8) (2,14) (2,10) (2,6) (2,3) (2,13) (2,4) (3,7) (3,14) (3,6) (3,12) (3,13) (3,4) (4,9) (4,7) (4,10) (4,12) (4,13) (5,11) (5,8) (6,7) (6,10) (6,12) (6,13) (7,9) (7,14) (7,10) (7,13) (8,11) (10,14) (10,12) (10,13) (12,14) (12,13) (13,14)\nQ: Is there a path between node 13 and node 5?\nA:",
                "code": "\nimport networkx as nx\n\n# Define the edges of the graph\nedges = [\n    (0, 5), (0, 1), (1, 11), (1, 5), (1, 8), (2, 14), (2, 10),\n    (2, 6), (2, 3), (2, 13), (2, 4), (3, 7), (3, 14), (3, 6),\n    (3, 12), (3, 13), (3, 4), (4, 9), (4, 7), (4, 10), (4, 12),\n    (4, 13), (5, 11), (5, 8), (6, 7), (6, 10), (6, 12), (6, 13),\n    (7, 9), (7, 14), (7, 10), (7, 13), (8, 11), (10, 14), (10, 12),\n    (10, 13), (12, 14), (12, 13), (13, 14)\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from(edges)\n\n# Check if there is a path between node 13 and node 5\npath_exists = nx.has_path(G, 13, 5)\n\n# Output the result\nprint(f\"Is there a path between node 13 and node 5? {path_exists}\")\n",
                "key_api": "NetworkX library (nx), particularly the nx.Graph() function for creating a graph and the nx.has_path() function for checking path existence.",
                "key_experience": "1. Defining the edges clearly in a list format. 2. Using the `add_edges_from` method to efficiently add multiple edges to the graph. 3. Leveraging `nx.has_path` to check the connectivity between nodes. 4. Ensuring the output is clear and interpretable by using formatted strings for printing results."
            }
        ]
    },
    {
        "id": 46,
        "problem": "Determine if there is a path between node 17 and node 10.",
        "graph_type": "undirected",
        "experience": "For determining if there is a path between two nodes in a graph, we used the NetworkX library in Python. The key steps involved defining the edges of the graph, creating an undirected graph, and then utilizing NetworkX's `has_path()` function to check for the existence of a path between the specified nodes.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Determine if there is a path between two nodes in the graph. Note that (i,j) means that node i and node j are connected with an undirected edge.\nGraph: (0,3) (0,17) (0,13) (0,12) (0,4) (0,1) (1,3) (1,17) (1,16) (1,14) (1,4) (2,5) (2,7) (2,9) (2,11) (2,8) (3,15) (3,13) (3,16) (3,12) (3,14) (3,6) (4,15) (4,13) (4,16) (4,12) (4,6) (5,9) (5,11) (5,10) (6,17) (6,13) (6,12) (7,11) (7,10) (7,8) (8,9) (8,11) (9,10) (10,11) (12,15) (12,17) (12,16) (12,14) (13,17) (13,16) (14,15) (14,17) (15,17) (15,16) (16,17)\nQ: Is there a path between node 17 and node 10?\nA:",
                "code": "\nimport networkx as nx\n\n# Define the edges based on the provided input\nedges = [\n    [0, 3], [0, 17], [0, 13], [0, 12], [0, 4], [0, 1],\n    [1, 3], [1, 17], [1, 16], [1, 14], [1, 4], [2, 5],\n    [2, 7], [2, 9], [2, 11], [2, 8], [3, 15], [3, 13],\n    [3, 16], [3, 12], [3, 14], [3, 6], [4, 15], [4, 13],\n    [4, 16], [4, 12], [4, 6], [5, 9], [5, 11], [5, 10],\n    [6, 17], [6, 13], [6, 12], [7, 11], [7, 10], [7, 8],\n    [8, 9], [8, 11], [9, 10], [10, 11], [12, 15], [12, 17],\n    [12, 16], [12, 14], [13, 17], [13, 16], [14, 15],\n    [14, 17], [15, 17], [15, 16], [16, 17]\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_edges_from(edges)\n\n# Check if there is a path between node 17 and node 10\npath_exists = nx.has_path(G, 17, 10)\n\n# Output the result\nprint(f\"There is a path between node 17 and node 10: {path_exists}\")\n",
                "key_api": "NetworkX's `has_path()` function.",
                "key_experience": "1. Defining the graph edges clearly and concisely. 2. Using NetworkX to create the graph and utilize its built-in functions for graph operations. 3. Checking for path existence in a graph using a well-known library function."
            }
        ]
    },
    {
        "id": 47,
        "problem": "Calculate the maximum flow from node 2 to node 6",
        "graph_type": "directed",
        "experience": "In the problem of calculating the maximum flow from node 2 to node 6 using NetworkX, the key steps involved defining a graph with nodes and edges, adding those edges to a directed graph (DiGraph), and then utilizing the maximum_flow function from NetworkX to compute the flow. The task was accomplished by carefully setting up the graph data, creating the graph structure in NetworkX, and finally calling the appropriate function to calculate and print the result.",
        "rag_data": [
            {
                "Section ID": "maximum_flow",
                "Description": [
                    "Find a maximum single-commodity flow."
                ],
                "Field List": {
                    "Parameters:": {
                        "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                        "_s : node": "Source node for the flow.",
                        "_t : node": "Sink node for the flow.",
                        "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                        "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                        "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
                    },
                    "Returns:": {
                        "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source.",
                        "flow_dict : dict": "A dictionary containing the value of the flow that went through\neach edge."
                    },
                    "Raises:": {
                        "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                        "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                    }
                },
                "Rubrics": {
                    "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
                    "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In a directed graph, the nodes are numbered from 0 to 8, and the edges are:\nan edge from node 0 to node 8 with capacity 3,\nan edge from node 1 to node 3 with capacity 6,\nan edge from node 2 to node 5 with capacity 7,\nan edge from node 2 to node 4 with capacity 4,\nan edge from node 2 to node 3 with capacity 6,\nan edge from node 3 to node 5 with capacity 5,\nan edge from node 3 to node 6 with capacity 10,\nan edge from node 4 to node 2 with capacity 2,\nan edge from node 5 to node 8 with capacity 7,\nan edge from node 8 to node 4 with capacity 8,\nan edge from node 8 to node 6 with capacity 6.\nQ: What is the maximum flow from node 2 to node 6?\nA:",
                "code": "\nimport networkx as nx\n\n# Define the graph\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 8],\n    'Edges': [\n        {'from': 0, 'to': 8, 'capacity': 3},\n        {'from': 1, 'to': 3, 'capacity': 6},\n        {'from': 2, 'to': 5, 'capacity': 7},\n        {'from': 2, 'to': 4, 'capacity': 4},\n        {'from': 2, 'to': 3, 'capacity': 6},\n        {'from': 3, 'to': 5, 'capacity': 5},\n        {'from': 3, 'to': 6, 'capacity': 10},\n        {'from': 4, 'to': 2, 'capacity': 2},\n        {'from': 5, 'to': 8, 'capacity': 7},\n        {'from': 8, 'to': 4, 'capacity': 8},\n        {'from': 8, 'to': 6, 'capacity': 6}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['capacity'])\n\n# Calculate the maximum flow from node 2 to node 6\nsource = 2\ntarget = 6\nflow_value, flow_dict = nx.maximum_flow(G, _s=source, _t=target)\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source} to node {target} is: {flow_value}\")\n",
                "key_api": "NetworkX (specifically: nx.DiGraph, nx.maximum_flow)",
                "key_experience": "['Correctly initializing and defining graph data.', 'Constructing the graph using nx.DiGraph and adding edges with capacities.', 'Ensuring that the correct parameters are passed to the maximum_flow function.', 'Using clear and concise variable names to represent source and target nodes.', 'Printing the result in a formatted and readable manner.']"
            }
        ]
    },
    {
        "id": 48,
        "problem": "What is the maximum flow from node 6 to node 4?",
        "graph_type": "directed",
        "experience": "To solve the maximum flow problem from node 6 to node 4, the following steps were taken: 1. Define the graph using the NetworkX library. 2. Define the nodes and edges with their respective capacities. 3. Use NetworkX's built-in algorithm to compute the maximum flow between the specified nodes.",
        "rag_data": [
            {
                "Section ID": "maximum_flow",
                "Description": [
                    "Find a maximum single-commodity flow."
                ],
                "Field List": {
                    "Parameters:": {
                        "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                        "_s : node": "Source node for the flow.",
                        "_t : node": "Sink node for the flow.",
                        "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                        "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                        "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
                    },
                    "Returns:": {
                        "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source.",
                        "flow_dict : dict": "A dictionary containing the value of the flow that went through\neach edge."
                    },
                    "Raises:": {
                        "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                        "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                    }
                },
                "Rubrics": {
                    "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
                    "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In a directed graph, the nodes are numbered from 0 to 13, and the edges are:\nan edge from node 0 to node 10 with capacity 14,\nan edge from node 0 to node 8 with capacity 13,\nan edge from node 1 to node 0 with capacity 1,\nan edge from node 1 to node 7 with capacity 2,\nan edge from node 3 to node 11 with capacity 18,\nan edge from node 3 to node 5 with capacity 16,\nan edge from node 3 to node 10 with capacity 15,\nan edge from node 3 to node 9 with capacity 15,\nan edge from node 3 to node 8 with capacity 5,\nan edge from node 4 to node 1 with capacity 7,\nan edge from node 4 to node 9 with capacity 15,\nan edge from node 4 to node 7 with capacity 8,\nan edge from node 5 to node 0 with capacity 9,\nan edge from node 5 to node 1 with capacity 4,\nan edge from node 5 to node 10 with capacity 8,\nan edge from node 6 to node 0 with capacity 17,\nan edge from node 6 to node 12 with capacity 17,\nan edge from node 6 to node 4 with capacity 7,\nan edge from node 6 to node 10 with capacity 9,\nan edge from node 6 to node 9 with capacity 1,\nan edge from node 6 to node 8 with capacity 17,\nan edge from node 7 to node 12 with capacity 12,\nan edge from node 7 to node 8 with capacity 18,\nan edge from node 8 to node 5 with capacity 11,\nan edge from node 8 to node 6 with capacity 1,\nan edge from node 8 to node 1 with capacity 6,\nan edge from node 8 to node 4 with capacity 4,\nan edge from node 8 to node 13 with capacity 9,\nan edge from node 9 to node 6 with capacity 11,\nan edge from node 9 to node 12 with capacity 1,\nan edge from node 9 to node 8 with capacity 17,\nan edge from node 10 to node 11 with capacity 17,\nan edge from node 10 to node 3 with capacity 8,\nan edge from node 10 to node 9 with capacity 19,\nan edge from node 11 to node 4 with capacity 1,\nan edge from node 11 to node 10 with capacity 19,\nan edge from node 11 to node 2 with capacity 8,\nan edge from node 12 to node 11 with capacity 14,\nan edge from node 12 to node 10 with capacity 16,\nan edge from node 12 to node 9 with capacity 17,\nan edge from node 12 to node 7 with capacity 17,\nan edge from node 12 to node 13 with capacity 19,\nan edge from node 12 to node 8 with capacity 7,\nan edge from node 13 to node 0 with capacity 15,\nan edge from node 13 to node 5 with capacity 11,\nan edge from node 13 to node 10 with capacity 7,\nan edge from node 13 to node 2 with capacity 1,\nan edge from node 13 to node 8 with capacity 11.\nQ: What is the maximum flow from node 6 to node 4?\nA:",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n    'Edges': [\n        {'from': 0, 'to': 10, 'capacity': 14}, \n        {'from': 0, 'to': 8, 'capacity': 13}, \n        {'from': 1, 'to': 0, 'capacity': 1}, \n        {'from': 1, 'to': 7, 'capacity': 2}, \n        {'from': 3, 'to': 11, 'capacity': 18}, \n        {'from': 3, 'to': 5, 'capacity': 16}, \n        {'from': 3, 'to': 10, 'capacity': 15}, \n        {'from': 3, 'to': 9, 'capacity': 15}, \n        {'from': 3, 'to': 8, 'capacity': 5}, \n        {'from': 4, 'to': 1, 'capacity': 7}, \n        {'from': 4, 'to': 9, 'capacity': 15}, \n        {'from': 4, 'to': 7, 'capacity': 8}, \n        {'from': 5, 'to': 0, 'capacity': 9}, \n        {'from': 5, 'to': 1, 'capacity': 4}, \n        {'from': 5, 'to': 10, 'capacity': 8}, \n        {'from': 6, 'to': 0, 'capacity': 17}, \n        {'from': 6, 'to': 12, 'capacity': 17}, \n        {'from': 6, 'to': 4, 'capacity': 7}, \n        {'from': 6, 'to': 10, 'capacity': 9}, \n        {'from': 6, 'to': 9, 'capacity': 1}, \n        {'from': 6, 'to': 8, 'capacity': 17}, \n        {'from': 7, 'to': 12, 'capacity': 12}, \n        {'from': 7, 'to': 8, 'capacity': 18}, \n        {'from': 8, 'to': 5, 'capacity': 11}, \n        {'from': 8, 'to': 6, 'capacity': 1}, \n        {'from': 8, 'to': 1, 'capacity': 6}, \n        {'from': 8, 'to': 4, 'capacity': 4}, \n        {'from': 8, 'to': 13, 'capacity': 9}, \n        {'from': 9, 'to': 6, 'capacity': 11}, \n        {'from': 9, 'to': 12, 'capacity': 1}, \n        {'from': 9, 'to': 8, 'capacity': 17}, \n        {'from': 10, 'to': 11, 'capacity': 17}, \n        {'from': 10, 'to': 3, 'capacity': 8}, \n        {'from': 10, 'to': 9, 'capacity': 19}, \n        {'from': 11, 'to': 4, 'capacity': 1}, \n        {'from': 11, 'to': 10, 'capacity': 19}, \n        {'from': 11, 'to': 2, 'capacity': 8}, \n        {'from': 12, 'to': 11, 'capacity': 14}, \n        {'from': 12, 'to': 10, 'capacity': 16}, \n        {'from': 12, 'to': 9, 'capacity': 17}, \n        {'from': 12, 'to': 7, 'capacity': 17}, \n        {'from': 12, 'to': 13, 'capacity': 19}, \n        {'from': 12, 'to': 8, 'capacity': 7}, \n        {'from': 13, 'to': 0, 'capacity': 15}, \n        {'from': 13, 'to': 5, 'capacity': 11}, \n        {'from': 13, 'to': 10, 'capacity': 7}, \n        {'from': 13, 'to': 2, 'capacity': 1}, \n        {'from': 13, 'to': 8, 'capacity': 11}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges with capacities to the graph\nfor edge in graph_data['Edges']:\n    G.add_edge(edge['from'], edge['to'], capacity=edge['capacity'])\n\n# Calculate the maximum flow from node 6 to node 4\nsource = 6\ntarget = 4\nflow_value, flow_dict = nx.maximum_flow(G, _s=source, _t=target)\n\n# Output the maximum flow value\nprint(f\"The maximum flow from node {source} to node {target} is: {flow_value}\")\n",
                "key_api": "NetworkX's max_flow function (nx.maximum_flow)",
                "key_experience": "Best practices include defining the graph clearly with nodes and edge capacities, utilizing a well-documented library like NetworkX for complex graph operations, and using built-in functions to leverage optimized algorithms for computing maximum flow."
            }
        ]
    },
    {
        "id": 49,
        "problem": "Is there a cycle in this graph?",
        "graph_type": "undirected",
        "experience": "To determine if a graph contains a cycle, the process involves using the NetworkX library in Python. Here are the steps and best practices observed:\n\n1. **Input Data Preparation**: The nodes and edges were provided as lists within a dictionary.\n2. **Graph Construction**: An undirected graph was created using `nx.Graph()`, with nodes and edges added through `add_nodes_from` and `add_edges_from` methods.\n3. **Cycle Detection**: The `nx.is_tree()` method was used to determine if the graph is a tree (a tree has no cycles). Therefore, the negation of `is_tree` being `False` indicated the presence of a cycle.\n4. **Output the Result**: A simple if-else structure was used to print whether the graph contains a cycle or not.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge.\nThe nodes are numbered from 0 to 33, and the edges are: (32,14) (4,12) (26,23) (29,17) (28,13) (9,0) (24,0) (18,23) (10,21) (30,19) (15,24) (31,1) (25,5) (9,11) (6,17) (22,14) (0,16) (28,9) (23,10) (20,17) (32,3) (27,33) (4,32) (12,29) (30,2) (27,5) (7,33) (5,14) (25,21) (21,30) (3,13) (1,3) (8,22)\nQ: Is there a cycle in this graph?\nA:",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33],\n    'Edges': [[32, 14], [4, 12], [26, 23], [29, 17], [28, 13], [9, 0], [24, 0], [18, 23], [10, 21], [30, 19], [15, 24], [31, 1], [25, 5], [9, 11], [6, 17], [22, 14], [0, 16], [28, 9], [23, 10], [20, 17], [32, 3], [27, 33], [4, 32], [12, 29], [30, 2], [27, 5], [7, 33], [5, 14], [25, 21], [21, 30], [3, 13], [1, 3], [8, 22]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Check for cycles\nhas_cycle = nx.is_tree(G) == False  # A tree has no cycles, so we check the negation\n\n# Output result\nif has_cycle:\n    print(\"The graph has a cycle.\")\nelse:\n    print(\"The graph does not have a cycle.\")\n",
                "key_api": "NetworkX (functions: Graph, add_nodes_from, add_edges_from, is_tree)",
                "key_experience": "1. **Modular Code**: Separate sections for data input, graph creation, and cycle detection.\n2. **Library Utilization**: Efficient use of NetworkX functions to manage graph operations.\n3. **Clear Output**: Easy-to-understand if-else statement for results.\n4. **Code Clarity**: Use of comments to explain each step."
            }
        ]
    },
    {
        "id": 50,
        "problem": "Is there a cycle in this graph?",
        "graph_type": "undirected",
        "experience": "In solving the task of detecting cycles in a graph, the approach involved using the NetworkX library, which is well-suited for graph-related problems. First, the input data comprising nodes and edges was defined. An undirected graph was then created and populated with these nodes and edges. The cycle detection was implemented using the NetworkX function `cycle_basis`, which detects all cycles in the graph. Lastly, the results were printed based on whether cycles were found.",
        "rag_data": [
            {
                "Section ID": "cycle_basis",
                "Description": [
                    "Returns a list of cycles which form a basis for cycles of G.",
                    "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "",
                        "root : node, optional": "Specify starting node for basis."
                    },
                    "Returns:": {
                        "A list of cycle lists.  Each cycle list is a list of nodes": "",
                        "which forms a cycle (loop) in G.": ""
                    }
                },
                "Rubrics": {
                    "Notes": "This is adapted from algorithm CACM 491 [1] .",
                    "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
                    "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge.\nThe nodes are numbered from 0 to 32, and the edges are: (32,23) (15,23) (10,16) (17,30) (14,31) (29,10) (17,21) (19,9) (27,1) (7,17) (27,22) (11,3) (22,31) (13,22) (27,0) (17,4) (0,25) (26,29) (29,28) (2,13) (1,24) (6,7) (2,26) (4,23) (1,12) (18,19) (27,11) (8,5) (5,19) (20,27) (8,16) (19,30)\nQ: Is there a cycle in this graph?\nA:",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],\n    'Edges': [[32, 23], [15, 23], [10, 16], [17, 30], [14, 31], [29, 10], [17, 21], [19, 9], [27, 1], [7, 17], [27, 22], [11, 3], [22, 31], [13, 22], [27, 0], [17, 4], [0, 25], [26, 29], [29, 28], [2, 13], [1, 24], [6, 7], [2, 26], [4, 23], [1, 12], [18, 19], [27, 11], [8, 5], [5, 19], [20, 27], [8, 16], [19, 30]]\n}\n\n# Create an undirected graph from the input data\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Check for cycles in the graph\ncycles = list(nx.cycle_basis(G))\n\n# Output the result\nif cycles:\n    print(\"The graph has cycles:\", cycles)\nelse:\n    print(\"The graph has no cycles.\")\n",
                "key_api": "networkx.cycle_basis(G)",
                "key_experience": "1. Employing a well-established library (NetworkX) for graph manipulation and analysis. 2. Systematic approach: Define data, create the graph, add nodes and edges, and then analyze the graph. 3. Clear and concise conditions to output whether cycles are present in the graph or not."
            }
        ]
    },
    {
        "id": 51,
        "problem": "Calculate the embedding of each node after two layers of simple graph convolution layer.",
        "graph_type": "undirected",
        "experience": "In this engagement, the task involved applying a graph convolution operation on an undirected graph with nodes and their embeddings. The solution required building an adjacency list from the provided edges and using matrix operations to update the embeddings of each node by summing the embeddings of its neighbors. The process involved two convolution layers, where each node's new embedding was determined by aggregating the embeddings of its neighbors from the previous layer. The focus was on ensuring the graph structure was accurately represented and applying the convolution function twice to get the desired result.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, the nodes are numbered from 0 to 14, and every node has an embedding. (i,j) means that node i and node j are connected with an undirected edge.\nEmbeddings:\nnode 0: [1,0]\nnode 1: [0,1]\nnode 2: [0,0]\nnode 3: [0,1]\nnode 4: [0,1]\nnode 5: [0,1]\nnode 6: [1,0]\nnode 7: [1,1]\nnode 8: [0,1]\nnode 9: [1,0]\nnode 10: [1,1]\nnode 11: [1,1]\nnode 12: [1,0]\nnode 13: [0,1]\nnode 14: [1,1]\nThe edges are: (0,8) (0,3) (0,9) (0,12) (1,8) (1,3) (1,5) (2,10) (2,8) (2,13) (2,7) (2,4) (2,11) (3,8) (3,13) (3,7) (3,5) (3,9) (4,6) (4,14) (5,9) (5,6) (7,13) (7,9) (9,10) (10,12) (11,13)\nIn a simple graph convolution layer, each node's embedding is updated by the sum of its neighbors' embeddings.\nQ: What's the embedding of each node after two layers of simple graph convolution layer?\nA:",
                "code": "import numpy as np\n\n# Define the embeddings for each node\nembeddings = {\n    0: np.array([1, 0]),\n    1: np.array([0, 1]),\n    2: np.array([0, 0]),\n    3: np.array([0, 1]),\n    4: np.array([0, 1]),\n    5: np.array([0, 1]),\n    6: np.array([1, 0]),\n    7: np.array([1, 1]),\n    8: np.array([0, 1]),\n    9: np.array([1, 0]),\n    10: np.array([1, 1]),\n    11: np.array([1, 1]),\n    12: np.array([1, 0]),\n    13: np.array([0, 1]),\n    14: np.array([1, 1]),\n}\n\n# Define the edges in the graph\nedges = [\n    (0, 8), (0, 3), (0, 9), (0, 12),\n    (1, 8), (1, 3), (1, 5),\n    (2, 10), (2, 8), (2, 13), (2, 7), (2, 4), (2, 11),\n    (3, 8), (3, 13), (3, 7), (3, 5), (3, 9),\n    (4, 6), (4, 14),\n    (5, 9), (5, 6),\n    (7, 13), (7, 9),\n    (9, 10),\n    (10, 12),\n    (11, 13)\n]\n\n# Build adjacency list for the graph\nadjacency_list = {i: [] for i in range(15)}\nfor u, v in edges:\n    adjacency_list[u].append(v)\n    adjacency_list[v].append(u)\n\n# Perform one layer of simple graph convolution\ndef graph_convolution_layer(embeddings, adjacency_list):\n    new_embeddings = {}\n    for node, neighbors in adjacency_list.items():\n        neighbor_embeddings = np.sum([embeddings[neighbor] for neighbor in neighbors], axis=0)\n        new_embeddings[node] = neighbor_embeddings\n    return new_embeddings\n\n# Apply two layers of graph convolution\nfirst_layer_embeddings = graph_convolution_layer(embeddings, adjacency_list)\nsecond_layer_embeddings = graph_convolution_layer(first_layer_embeddings, adjacency_list)\n\n# Display the updated embeddings after two layers in the desired format\nprint(\"The answer is:\")\nfor node, embedding in sorted(second_layer_embeddings.items()):\n    print(f\"node {node}: {embedding.tolist()}\")",
                "key_api": "The key API used in the code was numpy's array and sum functions, which facilitated efficient matrix operations for summing neighbor embeddings.",
                "key_experience": "The best practices included: (1) using adjacency lists to represent the graph efficiently, allowing for easy traversal and aggregation of neighbor embeddings, (2) structuring the code in a modular way by defining a separate function for the graph convolution layer, enabling code reuse and better readability, and (3) using numpy arrays for efficient numerical computation, which is crucial for handling large-scale graph data."
            }
        ]
    },
    {
        "id": 52,
        "problem": "Calculate the updated embedding of each node after two layers of simple graph convolution.",
        "graph_type": "undirected",
        "experience": "In the recent task, the problem was focused on implementing a simple graph convolution layer to update node embeddings based on their neighbors' embeddings. The graph was undirected, and each node was connected via edges that required efficient traversal to sum the embeddings of neighboring nodes. The key steps involved defining the node embeddings, creating an adjacency list from the given edges, and implementing the graph convolution logic using summation over neighbors' embeddings. After one layer of convolution, the process was repeated for a second layer.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, the nodes are numbered from 0 to 14, and every node has an embedding. (i,j) means that node i and node j are connected with an undirected edge.\nEmbeddings:\nnode 0: [0,1]\nnode 1: [0,1]\nnode 2: [1,1]\nnode 3: [1,0]\nnode 4: [1,0]\nnode 5: [0,0]\nnode 6: [1,1]\nnode 7: [0,1]\nnode 8: [0,1]\nnode 9: [1,0]\nnode 10: [0,1]\nnode 11: [0,0]\nnode 12: [0,1]\nnode 13: [1,1]\nnode 14: [0,1]\nThe edges are: (0,6) (0,5) (0,12) (0,7) (1,6) (1,11) (1,3) (1,2) (2,8) (2,10) (3,5) (3,11) (3,12) (4,7) (5,14) (6,9) (6,12) (6,10) (7,13) (7,12) (8,13) (9,13) (10,14) (12,13)\nIn a simple graph convolution layer, each node's embedding is updated by the sum of its neighbors' embeddings.\nQ: What's the embedding of each node after two layers of simple graph convolution layer?\nA:",
                "code": "import networkx as nx\nimport numpy as np\n\n# Input data\ndata = {\n    'Nodes': {\n        '0': [0, 1], '1': [0, 1], '2': [1, 1], '3': [1, 0], '4': [1, 0],\n        '5': [0, 0], '6': [1, 1], '7': [0, 1], '8': [0, 1], '9': [1, 0],\n        '10': [0, 1], '11': [0, 0], '12': [0, 1], '13': [1, 1], '14': [0, 1]\n    },\n    'Edges': [\n        [0, 6], [0, 5], [0, 12], [0, 7], [1, 6], [1, 11], [1, 3],\n        [1, 2], [2, 8], [2, 10], [3, 5], [3, 11], [3, 12], [4, 7],\n        [5, 14], [6, 9], [6, 12], [6, 10], [7, 13], [7, 12], [8, 13],\n        [9, 13], [10, 14], [12, 13]\n    ]\n}\n\n# Create a graph from the input data\nG = nx.Graph()\nG.add_nodes_from(data['Nodes'].keys())\nG.add_edges_from([(str(edge[0]), str(edge[1])) for edge in data['Edges']])\n\n# Initialize node embeddings\nembeddings = {node: np.array(data['Nodes'][node]) for node in G.nodes()}\n\n# Function to perform one layer of graph convolution\ndef graph_convolution(embeddings, G):\n    new_embeddings = {}\n    for node in G.nodes():\n        neighbors = list(G.neighbors(node))\n        if neighbors:\n            neighbor_embeddings = np.sum([embeddings[neighbor] for neighbor in neighbors], axis=0)\n            new_embeddings[node] = neighbor_embeddings\n        else:\n            new_embeddings[node] = embeddings[node]  # No neighbors, keep the same embedding\n    return new_embeddings\n\n# Perform two layers of graph convolution\nfor _ in range(2):\n    embeddings = graph_convolution(embeddings, G)\n\n# Output the updated embeddings in the desired format\nprint(\"The answer is:\")\nfor node, embedding in sorted(embeddings.items()):\n    print(f\"node {node}: {embedding.tolist()}\")",
                "key_api": "The key APIs used in this code were numpy for numerical operations and sum calculations, as well as Python's basic dictionary manipulation to handle embeddings and adjacency lists.",
                "key_experience": "Key best practices included: 1) using an adjacency list to represent graph connections, making neighbor traversal efficient; 2) separating the graph convolution logic into a reusable function; 3) using numpy for summing arrays efficiently, ensuring optimal performance;"
            }
        ]
    },
    {
        "id": 53,
        "problem": "Find the shortest path from node 4 to node 5.",
        "graph_type": "undirected",
        "experience": "To solve the shortest path problem in a weighted graph, the approach involves defining the graph structure, adding nodes and edges with associated weights, and utilizing graph algorithms to determine the optimal path between specified nodes. The key steps include initializing the graph, populating it with nodes and edges, and applying Dijkstra's algorithm to find the shortest path while handling cases where no path exists.",
        "rag_data": [
            {
                "Section ID": "dijkstra_path_length",
                "Description": [
                    "Returns the shortest weighted path length in G from source to target.",
                    "Uses Dijkstra\u2019s Method to compute the shortest weighted path length\nbetween two nodes in a graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node label": "starting node for path",
                        "target : node label": "ending node for path",
                        "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
                    },
                    "Returns:": {
                        "length : number": "Shortest path length."
                    },
                    "Raises:": {
                        "NodeNotFound": "Ifsourceis not inG.",
                        "NetworkXNoPath": "If no path exists between source and target."
                    }
                },
                "Rubrics": {
                    "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The function single_source_dijkstra() computes both\npath and length-of-path if you need both, use that.",
                    "Examples": "G=nx.path_graph(5)\nnx.dijkstra_path_length(G,0,4)\n# 4"
                }
            },
            {
                "Section ID": "dijkstra_path",
                "Description": [
                    "Returns the shortest weighted path from source to target in G.",
                    "Uses Dijkstra\u2019s Method to compute the shortest weighted path\nbetween two nodes in a graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node": "Starting node",
                        "target : node": "Ending node",
                        "weight : string or function": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number or None to indicate a hidden edge."
                    },
                    "Returns:": {
                        "path : list": "List of nodes in a shortest path."
                    },
                    "Raises:": {
                        "NodeNotFound": "Ifsourceis not inG.",
                        "NetworkXNoPath": "If no path exists between source and target."
                    }
                },
                "Rubrics": {
                    "Notes": "Edge weight attributes must be numerical.\nDistances are calculated as sums of weighted edges traversed. The weight function can be used to hide edges by returning None.\nSo weight=lambdau,v,d:1ifd['color']==\"red\"elseNone will find the shortest red path. The weight function can be used to include node weights.",
                    "Examples": "G=nx.path_graph(5)\nprint(nx.dijkstra_path(G,0,4))\n# [0, 1, 2, 3, 4]\nFind edges of shortest path in Multigraph\nG=nx.MultiDiGraph()\nG.add_weighted_edges_from([(1,2,0.75),(1,2,0.5),(2,3,0.5),(1,3,1.5)])\nnodes=nx.dijkstra_path(G,1,3)\nedges=nx.utils.pairwise(nodes)\nlist(\n(u,v,min(G[u][v],key=lambdak:G[u][v][k].get(\"weight\",1)))\nforu,vinedges\n)\n# [(1, 2, 1), (2, 3, 0)]"
                }
            },
            {
                "Section ID": "NetworkXNoPath",
                "Description": [
                    "Exception for algorithms that should return a path when running on graphs where such a path does not exist."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, the nodes are numbered from 0 to 13, and the edges are:\nan edge between node 0 and node 12 with weight 2,\nan edge between node 0 and node 9 with weight 8,\nan edge between node 0 and node 6 with weight 4,\nan edge between node 0 and node 10 with weight 6,\nan edge between node 1 and node 12 with weight 4,\nan edge between node 1 and node 8 with weight 9,\nan edge between node 1 and node 9 with weight 4,\nan edge between node 2 and node 13 with weight 10,\nan edge between node 2 and node 7 with weight 3,\nan edge between node 2 and node 4 with weight 7,\nan edge between node 3 and node 13 with weight 8,\nan edge between node 3 and node 8 with weight 5,\nan edge between node 4 and node 13 with weight 2,\nan edge between node 5 and node 11 with weight 5,\nan edge between node 6 and node 13 with weight 2,\nan edge between node 6 and node 8 with weight 5,\nan edge between node 6 and node 9 with weight 1,\nan edge between node 7 and node 8 with weight 3,\nan edge between node 8 and node 13 with weight 5,\nan edge between node 9 and node 13 with weight 7,\nan edge between node 10 and node 11 with weight 9,\nan edge between node 12 and node 13 with weight 8.\nQ: Give the shortest path from node 4 to node 5.\nA:",
                "code": "import networkx as nx\n\n# Define the graph\nG = nx.Graph()\n\n# Add nodes\nG.add_nodes_from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n\n# Add edges with weights\nedges = [\n    (0, 12, 2), (0, 9, 8), (0, 6, 4), (0, 10, 6),\n    (1, 12, 4), (1, 8, 9), (1, 9, 4),\n    (2, 13, 10), (2, 7, 3), (2, 4, 7),\n    (3, 13, 8), (3, 8, 5),\n    (4, 13, 2),\n    (5, 11, 5),\n    (6, 13, 2), (6, 8, 5), (6, 9, 1),\n    (7, 8, 3),\n    (8, 13, 5),\n    (9, 13, 7),\n    (10, 11, 9),\n    (12, 13, 8)\n]\n\n# Add edges to the graph\nfor from_node, to_node, weight in edges:\n    G.add_edge(from_node, to_node, weight=weight)\n\n# Find the shortest path from node 4 to node 5\ntry:\n    path = nx.dijkstra_path(G, source=4, target=5, weight='weight')\n    path_length = nx.dijkstra_path_length(G, source=4, target=5, weight='weight')\n    print(f\"Shortest path from node 4 to node 5: {path} with total weight {path_length}\")\nexcept nx.NetworkXNoPath:\n    print(\"No path exists between node 4 and node 5.\")",
                "key_api": "networkx.Graph(), G.add_nodes_from(), G.add_edge(), nx.dijkstra_path(), nx.dijkstra_path_length(), nx.NetworkXNoPath",
                "key_experience": "1. Use of NetworkX to manage graph-related data structures and algorithms. 2. Applying Dijkstra's algorithm for finding the shortest path in a weighted graph. 3. Handling exceptions to gracefully manage scenarios where no path exists between the nodes."
            }
        ]
    },
    {
        "id": 54,
        "problem": "Find the shortest path from node 0 to node 7.",
        "graph_type": "undirected",
        "experience": "In the recent engagement, the task involved finding the shortest path in a graph using Python's NetworkX library. The task was approached by clearly understanding the graph structure provided in the input (nodes and edges with weights) and then translating it into NetworkX's API to efficiently solve the problem. The steps included creating a graph, adding nodes and edges, and using the shortest path functions available in the library. Understanding how to work with weighted edges and using Dijkstra\u00a1\u00afs algorithm by default was essential for accurate problem-solving.",
        "rag_data": [
            {
                "Section ID": "shortest_path",
                "Description": [
                    "Compute shortest paths in the graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node, optional": "Starting node for path. If not specified, compute shortest\npaths for each possible starting node.",
                        "target : node, optional": "Ending node for path. If not specified, compute shortest\npaths to all possible nodes.",
                        "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                        "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
                    },
                    "Returns:": {
                        "path: list or dictionary": "All returned paths include both the source and target in the path.If the source and target are both specified, return a single list\nof nodes in a shortest path from the source to the target.If only the source is specified, return a dictionary keyed by\ntargets with a list of nodes in a shortest path from the source\nto one of the targets.If only the target is specified, return a dictionary keyed by\nsources with a list of nodes in a shortest path from one of the\nsources to the target.If neither the source nor target are specified return a dictionary\nof dictionaries with path[source][target]=[list of nodes in path]."
                    },
                    "Raises:": {
                        "NodeNotFound": "Ifsourceis not inG.",
                        "ValueError": "Ifmethodis not among the supported options."
                    }
                },
                "Rubrics": {
                    "Notes": "There may be more than one shortest path between a source and target.\nThis returns only one of them.",
                    "Examples": "G=nx.path_graph(5)\nprint(nx.shortest_path(G,source=0,target=4))\n# [0, 1, 2, 3, 4]\np=nx.shortest_path(G,source=0)# target not specified\np[3]# shortest path from source=0 to target=3\n# [0, 1, 2, 3]\np=nx.shortest_path(G,target=4)# source not specified\np[1]# shortest path from source=1 to target=4\n# [1, 2, 3, 4]\np=dict(nx.shortest_path(G))# source, target not specified\np[2][4]# shortest path from source=2 to target=4\n# [2, 3, 4]"
                }
            },
            {
                "Section ID": "shortest_path_length",
                "Description": [
                    "Compute shortest path lengths in the graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node, optional": "Starting node for path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.",
                        "target : node, optional": "Ending node for path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.",
                        "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                        "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path length.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
                    },
                    "Returns:": {
                        "length: int or iterator": "If the source and target are both specified, return the length of\nthe shortest path from the source to the target.If only the source is specified, return a dict keyed by target\nto the shortest path length from the source to that target.If only the target is specified, return a dict keyed by source\nto the shortest path length from that source to the target.If neither the source nor target are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by target to\nshortest path length from source to that target."
                    },
                    "Raises:": {
                        "NodeNotFound": "Ifsourceis not inG.",
                        "NetworkXNoPath": "If no path exists between source and target.",
                        "ValueError": "Ifmethodis not among the supported options."
                    }
                },
                "Rubrics": {
                    "Notes": "The length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed. For digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.",
                    "Examples": "G=nx.path_graph(5)\nnx.shortest_path_length(G,source=0,target=4)\n# 4\np=nx.shortest_path_length(G,source=0)# target not specified\np[4]\n# 4\np=nx.shortest_path_length(G,target=4)# source not specified\np[0]\n# 4\np=dict(nx.shortest_path_length(G))# source,target not specified\np[0][4]\n# 4"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, the nodes are numbered from 0 to 7, and the edges are:\nan edge between node 0 and node 4 with weight 4,\nan edge between node 0 and node 6 with weight 3,\nan edge between node 0 and node 3 with weight 1,\nan edge between node 0 and node 5 with weight 4,\nan edge between node 0 and node 2 with weight 4,\nan edge between node 0 and node 1 with weight 2,\nan edge between node 1 and node 4 with weight 2,\nan edge between node 1 and node 3 with weight 1,\nan edge between node 1 and node 5 with weight 3,\nan edge between node 1 and node 2 with weight 1,\nan edge between node 2 and node 6 with weight 3,\nan edge between node 2 and node 3 with weight 2,\nan edge between node 2 and node 5 with weight 1,\nan edge between node 2 and node 7 with weight 2,\nan edge between node 3 and node 4 with weight 3,\nan edge between node 3 and node 6 with weight 1,\nan edge between node 3 and node 5 with weight 4,\nan edge between node 3 and node 7 with weight 3,\nan edge between node 4 and node 6 with weight 1,\nan edge between node 4 and node 7 with weight 1,\nan edge between node 5 and node 6 with weight 1,\nan edge between node 5 and node 7 with weight 1,\nan edge between node 6 and node 7 with weight 2.\nQ: Give the shortest path from node 0 to node 7.\nA:",
                "code": "import networkx as nx\n\n# Input graph data\nnodes = [0, 1, 2, 3, 4, 5, 6, 7]\nedges = [\n    (0, 4, 4), (0, 6, 3), (0, 3, 1), (0, 5, 4), (0, 2, 4), (0, 1, 2),\n    (1, 4, 2), (1, 3, 1), (1, 5, 3), (1, 2, 1), (2, 6, 3), (2, 3, 2), \n    (2, 5, 1), (2, 7, 2), (3, 4, 3), (3, 6, 1), (3, 5, 4), (3, 7, 3),\n    (4, 6, 1), (4, 7, 1), (5, 6, 1), (5, 7, 1), (6, 7, 2)\n]\n\n# Create a graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(nodes)\nG.add_weighted_edges_from(edges)\n\n# Find the shortest path from node 0 to node 7\nshortest_path = nx.shortest_path(G, source=0, target=7, weight='weight')\nshortest_path_length = nx.shortest_path_length(G, source=0, target=7, weight='weight')\n\n# Output the result\nprint(\"Shortest path from node 0 to node 7:\", shortest_path)\nprint(\"Length of the shortest path:\", shortest_path_length)",
                "key_api": "networkx.Graph, networkx.shortest_path, networkx.shortest_path_length",
                "key_experience": "1. Using NetworkX for graph-related tasks, leveraging its comprehensive set of functions for graph manipulation and analysis. 2. Adding nodes and edges to the graph efficiently using 'add_nodes_from' and 'add_weighted_edges_from'. 3. Utilizing Dijkstra's algorithm by default in 'nx.shortest_path' to find the shortest path in a weighted graph and 'nx.shortest_path_length' to calculate the shortest path."
            }
        ]
    },
    {
        "id": 55,
        "problem": "Find an assignment of jobs to applicants such that the maximum number of applicants find the job they are interested in.",
        "graph_type": "undirected",
        "experience": "The task involved solving a bipartite matching problem where the goal was to assign jobs to applicants based on their preferences. The problem was formulated as a graph, with applicants and jobs as nodes, and edges representing the interest of an applicant in a job. NetworkX was utilized to create and manipulate the bipartite graph, compute the maximum matching to determine the best job assignments, and extract the results to display which applicants were successfully assigned to their interested jobs.",
        "rag_data": [
            {
                "Section ID": "maximum_matching",
                "Description": [
                    "Returns the maximum cardinality matching in the given bipartite graph.",
                    "This function is simply an alias for hopcroft_karp_matching() ."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "There are 6 job applicants numbered from 0 to 5, and 4 jobs numbered from 0 to 3. Each applicant is interested in some of the jobs. Each job can only accept one applicant and a job applicant can be appointed for only one job.\nApplicant 0 is interested in job 0.\nApplicant 1 is interested in job 3.\nApplicant 2 is interested in job 2.\nApplicant 3 is interested in job 2.\nApplicant 3 is interested in job 0.\nApplicant 4 is interested in job 3.\nApplicant 4 is interested in job 1.\nApplicant 5 is interested in job 0.\nApplicant 5 is interested in job 2.\nQ: Find an assignment of jobs to applicants in such that the maximum number of applicants find the job they are interested in.\nA:",
                "code": "import networkx as nx\n\n# Input data\ndata = {\n    'Applicants': [\n        {'id': 0, 'interested_jobs': [0]},\n        {'id': 1, 'interested_jobs': [3]},\n        {'id': 2, 'interested_jobs': [2]},\n        {'id': 3, 'interested_jobs': [2, 0]},\n        {'id': 4, 'interested_jobs': [3, 1]},\n        {'id': 5, 'interested_jobs': [0, 2]}\n    ],\n    'Jobs': [0, 1, 2, 3]\n}\n\n# Create a bipartite graph\nB = nx.Graph()\n\n# Add nodes with bipartition attribute\napplicant_nodes = [f\"applicant_{app['id']}\" for app in data['Applicants']]\njob_nodes = [f\"job_{job_id}\" for job_id in data['Jobs']]\n\nB.add_nodes_from(applicant_nodes, bipartite=0)\nB.add_nodes_from(job_nodes, bipartite=1)\n\n# Add edges based on interested jobs\nfor app in data['Applicants']:\n    applicant = f\"applicant_{app['id']}\"\n    for job_id in app['interested_jobs']:\n        job = f\"job_{job_id}\"\n        B.add_edge(applicant, job)\n\n# Compute maximum matching\nmatching = nx.algorithms.bipartite.maximum_matching(B, top_nodes=applicant_nodes)\n\n# Extract assignments\nassignments = []\nfor applicant in applicant_nodes:\n    if applicant in matching:\n        job = matching[applicant]\n        applicant_id = int(applicant.split('_')[1])\n        job_id = int(job.split('_')[1])\n        assignments.append({'applicant_id': applicant_id, 'job_id': job_id})\n\n# Print the assignments\nprint(\"Job Assignments:\")\nfor assignment in assignments:\n    print(f\"Applicant {assignment['applicant_id']} assigned to Job {assignment['job_id']}\")\n\n# Print the number of successful assignments\nprint(f\"{len(assignments)} applicants can find the job they are interested in.\\n\")",
                "key_api": "networkx.algorithms.bipartite.maximum_matching",
                "key_experience": "Using a bipartite graph to model the relationship between two distinct sets (applicants and jobs) and employing NetworkX's maximum matching function to efficiently find an optimal assignment of jobs to applicants based on their preferences. The solution emphasizes clear structure and naming conventions for nodes to simplify the management and readability of graph-related operations."
            }
        ]
    },
    {
        "id": 56,
        "problem": "Find an assignment of jobs to applicants in such that the maximum number of applicants find the job they are interested in.",
        "graph_type": "undirected",
        "experience": "Analyzed the problem to model it as a bipartite graph, where one set represents applicants and the other represents jobs. Constructed the graph by adding nodes for applicants and jobs, and edges based on applicants' job interests. Utilized NetworkX's maximum matching algorithm to find the optimal assignments that maximize the number of applicants getting their desired jobs. Finally, formatted the output to match the specified requirements.",
        "rag_data": [
            {
                "Section ID": "maximum_matching",
                "Description": [
                    "Returns the maximum cardinality matching in the given bipartite graph.",
                    "This function is simply an alias for hopcroft_karp_matching() ."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "There are 15 job applicants numbered from 0 to 14, and 15 jobs numbered from 0 to 14. Each applicant is interested in some of the jobs. Each job can only accept one applicant and a job applicant can be appointed for only one job.\nApplicant 0 is interested in job 6.\nApplicant 0 is interested in job 7.\nApplicant 0 is interested in job 14.\nApplicant 1 is interested in job 13.\nApplicant 1 is interested in job 7.\nApplicant 1 is interested in job 9.\nApplicant 1 is interested in job 6.\nApplicant 1 is interested in job 5.\nApplicant 1 is interested in job 2.\nApplicant 2 is interested in job 0.\nApplicant 2 is interested in job 12.\nApplicant 2 is interested in job 2.\nApplicant 2 is interested in job 10.\nApplicant 2 is interested in job 4.\nApplicant 2 is interested in job 3.\nApplicant 3 is interested in job 8.\nApplicant 3 is interested in job 11.\nApplicant 3 is interested in job 0.\nApplicant 3 is interested in job 10.\nApplicant 3 is interested in job 6.\nApplicant 3 is interested in job 12.\nApplicant 3 is interested in job 1.\nApplicant 3 is interested in job 9.\nApplicant 4 is interested in job 12.\nApplicant 4 is interested in job 3.\nApplicant 4 is interested in job 5.\nApplicant 4 is interested in job 13.\nApplicant 4 is interested in job 6.\nApplicant 4 is interested in job 11.\nApplicant 4 is interested in job 8.\nApplicant 4 is interested in job 10.\nApplicant 4 is interested in job 4.\nApplicant 4 is interested in job 1.\nApplicant 4 is interested in job 9.\nApplicant 4 is interested in job 7.\nApplicant 5 is interested in job 5.\nApplicant 5 is interested in job 12.\nApplicant 5 is interested in job 2.\nApplicant 5 is interested in job 7.\nApplicant 5 is interested in job 4.\nApplicant 6 is interested in job 14.\nApplicant 6 is interested in job 11.\nApplicant 6 is interested in job 9.\nApplicant 6 is interested in job 0.\nApplicant 6 is interested in job 2.\nApplicant 6 is interested in job 3.\nApplicant 6 is interested in job 5.\nApplicant 6 is interested in job 8.\nApplicant 6 is interested in job 13.\nApplicant 7 is interested in job 0.\nApplicant 7 is interested in job 14.\nApplicant 7 is interested in job 4.\nApplicant 7 is interested in job 2.\nApplicant 8 is interested in job 14.\nApplicant 8 is interested in job 4.\nApplicant 8 is interested in job 6.\nApplicant 8 is interested in job 7.\nApplicant 8 is interested in job 9.\nApplicant 8 is interested in job 12.\nApplicant 8 is interested in job 11.\nApplicant 8 is interested in job 13.\nApplicant 8 is interested in job 2.\nApplicant 8 is interested in job 0.\nApplicant 9 is interested in job 9.\nApplicant 9 is interested in job 4.\nApplicant 9 is interested in job 6.\nApplicant 9 is interested in job 10.\nApplicant 9 is interested in job 1.\nApplicant 10 is interested in job 7.\nApplicant 10 is interested in job 4.\nApplicant 10 is interested in job 14.\nApplicant 10 is interested in job 0.\nApplicant 10 is interested in job 11.\nApplicant 11 is interested in job 8.\nApplicant 11 is interested in job 13.\nApplicant 11 is interested in job 11.\nApplicant 11 is interested in job 7.\nApplicant 12 is interested in job 10.\nApplicant 12 is interested in job 9.\nApplicant 12 is interested in job 6.\nApplicant 12 is interested in job 3.\nApplicant 12 is interested in job 0.\nApplicant 12 is interested in job 11.\nApplicant 12 is interested in job 14.\nApplicant 12 is interested in job 13.\nApplicant 13 is interested in job 6.\nApplicant 13 is interested in job 1.\nApplicant 13 is interested in job 7.\nApplicant 13 is interested in job 0.\nApplicant 14 is interested in job 4.\nApplicant 14 is interested in job 3.\nApplicant 14 is interested in job 13.\nQ: Find an assignment of jobs to applicants in such that the maximum number of applicants find the job they are interested in.\nA:",
                "code": "import networkx as nx\n\n# Input data\ndata = {\n    'Applicants': [\n        {'Applicant': 0, 'Interested_Jobs': [6, 7, 14]},\n        {'Applicant': 1, 'Interested_Jobs': [13, 7, 9, 6, 5, 2]},\n        {'Applicant': 2, 'Interested_Jobs': [0, 12, 2, 10, 4, 3]},\n        {'Applicant': 3, 'Interested_Jobs': [8, 11, 0, 10, 6, 12, 1, 9]},\n        {'Applicant': 4, 'Interested_Jobs': [12, 3, 5, 13, 6, 11, 8, 10, 4, 1, 9, 7]},\n        {'Applicant': 5, 'Interested_Jobs': [5, 12, 2, 7, 4]},\n        {'Applicant': 6, 'Interested_Jobs': [14, 11, 9, 0, 2, 3, 5, 8, 13]},\n        {'Applicant': 7, 'Interested_Jobs': [0, 14, 4, 2]},\n        {'Applicant': 8, 'Interested_Jobs': [14, 4, 6, 7, 9, 12, 11, 13, 2, 0]},\n        {'Applicant': 9, 'Interested_Jobs': [9, 4, 6, 10, 1]},\n        {'Applicant': 10, 'Interested_Jobs': [7, 4, 14, 0, 11]},\n        {'Applicant': 11, 'Interested_Jobs': [8, 13, 11, 7]},\n        {'Applicant': 12, 'Interested_Jobs': [10, 9, 6, 3, 0, 11, 14, 13]},\n        {'Applicant': 13, 'Interested_Jobs': [6, 1, 7, 0]},\n        {'Applicant': 14, 'Interested_Jobs': [4, 3, 13]}\n    ]\n}\n\n# Create a bipartite graph\nG = nx.Graph()\n\n# Define applicant and job nodes\napplicants = [f\"A{app['Applicant']}\" for app in data['Applicants']]\njobs = [f\"J{job}\" for job in range(15)]  # Assuming jobs are numbered from 0 to 14\n\n# Add nodes with bipartite attribute\nG.add_nodes_from(applicants, bipartite=0)\nG.add_nodes_from(jobs, bipartite=1)\n\n# Add edges based on interested jobs\nfor app in data['Applicants']:\n    applicant_node = f\"A{app['Applicant']}\"\n    for job in app['Interested_Jobs']:\n        job_node = f\"J{job}\"\n        G.add_edge(applicant_node, job_node)\n\n# Find the maximum matching\nmatching = nx.algorithms.bipartite.maximum_matching(G, top_nodes=applicants)\n\n# Extract the assignments\nassignments = {}\nfor applicant in applicants:\n    if applicant in matching:\n        job = matching[applicant]\n        assignments[applicant] = job\n\n# Print the assignments in the desired format\nfor applicant_node in sorted(assignments.keys(), key=lambda x: int(x[1:])):\n    applicant_num = int(applicant_node[1:])\n    job_node = assignments[applicant_node]\n    job_num = int(job_node[1:])\n    print(f\"applicant {applicant_num}: job {job_num}\")\n\n# Print the total number of assignments\ntotal_assigned = len(assignments)\nprint(f\"{total_assigned} applicants can find the job they are interested in.\")",
                "key_api": "networkx.Graph(), add_nodes_from(), add_edge(), networkx.algorithms.bipartite.maximum_matching()",
                "key_experience": "Creating a clear mapping of applicants and jobs to nodes in the graph, ensuring that all potential edges (applicant-job preferences) are added correctly. Utilizing the maximum matching algorithm from NetworkX, which efficiently finds an optimal set of pairings between two sets of nodes. Extracting and formatting the matching results to provide clear and structured output, demonstrating which applicants were assigned to which jobs."
            }
        ]
    },
    {
        "id": 57,
        "problem": "Is there a path in this graph that visits every node exactly once? If yes, give the path.",
        "graph_type": "undirected",
        "experience": "The experience from this task involved solving the problem of finding a Hamiltonian path in a graph, which is a path that visits every node exactly once. Initially, an attempt was made to solve the problem by generating all permutations of the nodes and checking if each permutation was a valid path, but this approach was inefficient due to the large number of permutations. The solution was revised to use a more efficient backtracking approach, which incrementally builds the path and backtracks when a valid extension cannot be made. This method was faster and avoided the performance issues of the initial approach. The task also involved constructing an adjacency list representation of the graph and checking connectivity between nodes to ensure that the path remained valid at each step.",
        "rag_data": [],
        "accuracy": 0.95,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge.\nThe nodes are numbered from 0 to 18, and the edges are: (0,7) (0,8) (0,13) (0,2) (0,16) (1,2) (1,14) (1,7) (1,18) (1,9) (1,12) (1,3) (1,5) (1,17) (2,15) (2,4) (2,9) (2,12) (2,8) (2,16) (2,10) (3,5) (3,9) (3,15) (3,11) (3,8) (3,17) (4,15) (4,11) (4,5) (4,17) (4,6) (5,17) (5,14) (5,12) (5,16) (6,12) (6,7) (6,15) (6,17) (6,11) (7,15) (7,12) (8,10) (8,14) (8,9) (8,16) (8,15) (8,12) (9,13) (9,12) (9,14) (10,16) (10,12) (10,11) (10,18) (11,16) (12,17) (12,16) (13,15) (13,17) (14,16) (15,16) (15,18)\nQ: Is there a path in this graph that visits every node exactly once? If yes, give the path. Note that in a path, adjacent nodes must be connected with edges.\nA:",
                "code": "# Define the graph edges as an adjacency list\nedges = [(0,7), (0,8), (0,13), (0,2), (0,16), (1,2), (1,14), (1,7), (1,18), (1,9), (1,12), \n         (1,3), (1,5), (1,17), (2,15), (2,4), (2,9), (2,12), (2,8), (2,16), (2,10), (3,5), \n         (3,9), (3,15), (3,11), (3,8), (3,17), (4,15), (4,11), (4,5), (4,17), (4,6), (5,17), \n         (5,14), (5,12), (5,16), (6,12), (6,7), (6,15), (6,17), (6,11), (7,15), (7,12), (8,10), \n         (8,14), (8,9), (8,16), (8,15), (8,12), (9,13), (9,12), (9,14), (10,16), (10,12), \n         (10,11), (10,18), (11,16), (12,17), (12,16), (13,15), (13,17), (14,16), (15,16), (15,18)]\n\n# Create an adjacency list\ngraph = {i: [] for i in range(19)}\nfor u, v in edges:\n    graph[u].append(v)\n    graph[v].append(u)\n\n# Helper function to check if a path is Hamiltonian\ndef is_valid_move(v, path, graph):\n    # Check if the current node v can be added to the path\n    if v in path:  # node has already been visited\n        return False\n    if len(path) > 0 and v not in graph[path[-1]]:  # no edge between last node and current node\n        return False\n    return True\n\ndef hamiltonian_path_backtrack(graph, path):\n    # Base case: if all nodes are in the path, we have a Hamiltonian path\n    if len(path) == len(graph):\n        return path\n    \n    # Try to extend the path by adding a valid next node\n    for neighbor in graph[path[-1]]:\n        if is_valid_move(neighbor, path, graph):\n            path.append(neighbor)  # add node to the path\n            result = hamiltonian_path_backtrack(graph, path)\n            if result:\n                return result\n            path.pop()  # backtrack if the path is not valid\n\n    return None\n\n# Start the search from each node, because the Hamiltonian path can start from any node\nhamiltonian_path = None\nfor start_node in graph.keys():\n    hamiltonian_path = hamiltonian_path_backtrack(graph, [start_node])\n    if hamiltonian_path:\n        break\n\nhamiltonian_path",
                "key_api": "The key APIs used in this solution were Python's backtracking approach with recursive function calls and adjacency list construction for the graph representation.",
                "key_experience": "The best practices followed include using an adjacency list to represent the graph for efficient neighbor lookup, implementing backtracking to incrementally construct solutions and avoid unnecessary computation, and ensuring that the algorithm handles edge cases such as revisiting nodes and checking connectivity efficiently."
            }
        ]
    },
    {
        "id": 58,
        "problem": "Is there a path in this graph that visits every node exactly once?",
        "graph_type": "undirected",
        "experience": "This task involves checking for a Hamiltonian path in a graph using the NetworkX library in Python. The process includes defining the graph, writing utility functions to check for Hamiltonian paths, and testing the function starting from each node in the graph. Key steps involved validating the uniqueness and completeness of node visits, and exploring neighbors iteratively.",
        "rag_data": [
            {
                "Section ID": "nodes",
                "Description": [
                    "Returns a NodeView over the graph nodes.",
                    "This function wraps the G.nodes property."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 0.95,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge.\nThe nodes are numbered from 0 to 7, and the edges are: (0,5) (0,7) (0,4) (0,2) (1,4) (1,3) (2,4) (2,5) (3,6) (3,7) (4,7) (4,5) (5,7)\nQ: Is there a path in this graph that visits every node exactly once? If yes, give the path. Note that in a path, adjacent nodes must be connected with edges.\nA:",
                "code": "\nimport networkx as nx\n\ndef is_hamiltonian_path(graph, path):\n    # Check if the path visits every node exactly once\n    return len(path) == len(graph.nodes) and len(set(path)) == len(graph.nodes)\n\ndef hamiltonian_path_util(graph, path):\n    # If the path includes all nodes, check if it's a Hamiltonian path\n    if len(path) == len(graph.nodes):\n        return path if is_hamiltonian_path(graph, path) else None\n\n    # Explore neighbors of the last node in the current path\n    last_node = path[-1]\n    for neighbor in graph.neighbors(last_node):\n        if neighbor not in path:  # Ensure we don't revisit nodes\n            new_path = path + [neighbor]\n            result = hamiltonian_path_util(graph, new_path)\n            if result is not None:\n                return result\n    return None\n\ndef find_hamiltonian_path(graph):\n    # Start from each node and try to find a Hamiltonian path\n    for start_node in graph.nodes:\n        path = [start_node]\n        result = hamiltonian_path_util(graph, path)\n        if result is not None:\n            return result\n    return None\n\n# Define the graph based on the input\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7],\n    'Edges': [[0, 5], [0, 7], [0, 4], [0, 2], [1, 4], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 7], [4, 5], [5, 7]]\n}\n\n# Create a graph from the input data\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Find a Hamiltonian path\nhamiltonian_path = find_hamiltonian_path(G)\n\n# Output the result\nif hamiltonian_path:\n    print(\"Hamiltonian Path:\", hamiltonian_path)\nelse:\n    print(\"No Hamiltonian Path exists.\")\n",
                "key_api": "networkx.Graph, networkx.Graph.neighbors, graph.nodes",
                "key_experience": "1. Define utility functions for specific tasks (checking Hamiltonian path validity). 2. Iteratively explore potential paths and backtrack as needed. 3. Utilize Python list comprehensions and set operations for efficient checks."
            }
        ]
    },
    {
        "id": 59,
        "problem": "Is there a path in this graph that visits every node exactly once?",
        "graph_type": "undirected",
        "experience": "This task involves checking for a Hamiltonian path in a graph using the NetworkX library in Python. The process includes defining the graph, writing utility functions to check for Hamiltonian paths, and testing the function starting from each node in the graph. Key steps involved validating the uniqueness and completeness of node visits, and exploring neighbors iteratively.",
        "rag_data": [
            {
                "Section ID": "nodes",
                "Description": [
                    "Returns a NodeView over the graph nodes.",
                    "This function wraps the G.nodes property."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 0.95,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge.\nThe nodes are numbered from 0 to 7, and the edges are: (0,5) (0,7) (0,4) (0,2) (1,4) (1,3) (2,4) (2,5) (3,6) (3,7) (4,7) (4,5) (5,7)\nQ: Is there a path in this graph that visits every node exactly once? If yes, give the path. Note that in a path, adjacent nodes must be connected with edges.\nA:",
                "code": "\nimport networkx as nx\n\ndef is_hamiltonian_path(graph, path):\n    # Check if the path visits every node exactly once\n    return len(path) == len(graph.nodes) and len(set(path)) == len(graph.nodes)\n\ndef hamiltonian_path_util(graph, path):\n    # If the path includes all nodes, check if it's a Hamiltonian path\n    if len(path) == len(graph.nodes):\n        return path if is_hamiltonian_path(graph, path) else None\n\n    # Explore neighbors of the last node in the current path\n    last_node = path[-1]\n    for neighbor in graph.neighbors(last_node):\n        if neighbor not in path:  # Ensure we don't revisit nodes\n            new_path = path + [neighbor]\n            result = hamiltonian_path_util(graph, new_path)\n            if result is not None:\n                return result\n    return None\n\ndef find_hamiltonian_path(graph):\n    # Start from each node and try to find a Hamiltonian path\n    for start_node in graph.nodes:\n        path = [start_node]\n        result = hamiltonian_path_util(graph, path)\n        if result is not None:\n            return result\n    return None\n\n# Define the graph based on the input\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7],\n    'Edges': [[0, 5], [0, 7], [0, 4], [0, 2], [1, 4], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 7], [4, 5], [5, 7]]\n}\n\n# Create a graph from the input data\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Find a Hamiltonian path\nhamiltonian_path = find_hamiltonian_path(G)\n\n# Output the result\nif hamiltonian_path:\n    print(\"Hamiltonian Path:\", hamiltonian_path)\nelse:\n    print(\"No Hamiltonian Path exists.\")\n",
                "key_api": "networkx.Graph, networkx.Graph.neighbors, graph.nodes",
                "key_experience": "1. Define utility functions for specific tasks (checking Hamiltonian path validity). 2. Iteratively explore potential paths and backtrack as needed. 3. Utilize Python list comprehensions and set operations for efficient checks."
            }
        ]
    },
    {
        "id": 60,
        "problem": "Determine if all nodes can be visited based on the given constraints.",
        "graph_type": "directed",
        "experience": "The task involved checking if all nodes in a directed graph could be visited based on the given constraints. The solution was formulated using NetworkX to create and manage the graph structure. We processed the input by adding nodes and edges to construct the graph. The problem required determining the visitability of all nodes, which was solved using topological sorting. If the graph contained cycles, the topological sort would fail, indicating not all nodes could be visited. Exception handling was incorporated to account for this possibility, which would throw an error for unfeasible topological sorting.",
        "rag_data": [
            {
                "Section ID": "topological_sort",
                "Description": [
                    "Returns a generator of nodes in topologically sorted order.",
                    "A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX digraph": "A directed acyclic graph (DAG)"
                    },
                    "Yields:": {
                        "nodes": "Yields the nodes in topological sorted order."
                    },
                    "Raises:": {
                        "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                        "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                        "RuntimeError": "IfGis changed while the returned iterator is being processed."
                    }
                },
                "Rubrics": {
                    "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
                    "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
                    "Examples": "To get the reverse order of the topological sort:\nDG=nx.DiGraph([(1,2),(2,3)])\nlist(reversed(list(nx.topological_sort(DG))))\n# [3, 2, 1]\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwithnetworkx.line_graph()as follows:\nlist(nx.topological_sort(nx.line_graph(DG)))\n# [(1, 2), (2, 3)]"
                }
            },
            {
                "Section ID": "NetworkXUnfeasible",
                "Description": [
                    "Exception raised by algorithms trying to solve a problem instance that has no feasible solution."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 0.95,
        "example": [
            {
                "question": "In a directed graph with 22 nodes numbered from 0 to 21:\nnode 0 should be visited before node 2\nnode 0 should be visited before node 19\nnode 0 should be visited before node 8\nnode 0 should be visited before node 1\nnode 0 should be visited before node 21\nnode 0 should be visited before node 16\nnode 0 should be visited before node 6\nnode 0 should be visited before node 18\nnode 0 should be visited before node 7\nnode 0 should be visited before node 12\nnode 0 should be visited before node 3\nnode 0 should be visited before node 20\nnode 0 should be visited before node 10\nnode 0 should be visited before node 13\nnode 0 should be visited before node 5\nnode 1 should be visited before node 21\nnode 1 should be visited before node 16\nnode 1 should be visited before node 6\nnode 1 should be visited before node 17\nnode 1 should be visited before node 18\nnode 1 should be visited before node 7\nnode 1 should be visited before node 12\nnode 1 should be visited before node 3\nnode 1 should be visited before node 20\nnode 1 should be visited before node 10\nnode 1 should be visited before node 13\nnode 1 should be visited before node 5\nnode 2 should be visited before node 19\nnode 2 should be visited before node 8\nnode 2 should be visited before node 21\nnode 2 should be visited before node 16\nnode 2 should be visited before node 18\nnode 2 should be visited before node 3\nnode 2 should be visited before node 20\nnode 2 should be visited before node 13\nnode 3 should be visited before node 20\nnode 3 should be visited before node 10\nnode 3 should be visited before node 13\nnode 3 should be visited before node 5\nnode 4 should be visited before node 15\nnode 4 should be visited before node 2\nnode 4 should be visited before node 19\nnode 4 should be visited before node 1\nnode 4 should be visited before node 21\nnode 4 should be visited before node 16\nnode 4 should be visited before node 6\nnode 4 should be visited before node 17\nnode 4 should be visited before node 9\nnode 4 should be visited before node 7\nnode 4 should be visited before node 3\nnode 4 should be visited before node 10\nnode 4 should be visited before node 13\nnode 6 should be visited before node 18\nnode 6 should be visited before node 7\nnode 6 should be visited before node 12\nnode 6 should be visited before node 3\nnode 6 should be visited before node 10\nnode 6 should be visited before node 13\nnode 7 should be visited before node 20\nnode 7 should be visited before node 10\nnode 7 should be visited before node 13\nnode 7 should be visited before node 5\nnode 8 should be visited before node 1\nnode 8 should be visited before node 21\nnode 8 should be visited before node 16\nnode 8 should be visited before node 7\nnode 8 should be visited before node 12\nnode 8 should be visited before node 3\nnode 8 should be visited before node 20\nnode 8 should be visited before node 10\nnode 8 should be visited before node 13\nnode 8 should be visited before node 5\nnode 9 should be visited before node 7\nnode 9 should be visited before node 12\nnode 9 should be visited before node 3\nnode 9 should be visited before node 13\nnode 10 should be visited before node 13\nnode 11 should be visited before node 2\nnode 11 should be visited before node 1\nnode 11 should be visited before node 16\nnode 11 should be visited before node 6\nnode 11 should be visited before node 17\nnode 11 should be visited before node 18\nnode 11 should be visited before node 9\nnode 11 should be visited before node 7\nnode 11 should be visited before node 12\nnode 11 should be visited before node 20\nnode 11 should be visited before node 10\nnode 11 should be visited before node 5\nnode 12 should be visited before node 3\nnode 12 should be visited before node 20\nnode 12 should be visited before node 10\nnode 12 should be visited before node 13\nnode 12 should be visited before node 5\nnode 13 should be visited before node 5\nnode 14 should be visited before node 15\nnode 14 should be visited before node 11\nnode 14 should be visited before node 2\nnode 14 should be visited before node 8\nnode 14 should be visited before node 1\nnode 14 should be visited before node 21\nnode 14 should be visited before node 16\nnode 14 should be visited before node 17\nnode 14 should be visited before node 7\nnode 14 should be visited before node 12\nnode 14 should be visited before node 20\nnode 14 should be visited before node 10\nnode 14 should be visited before node 13\nnode 14 should be visited before node 5\nnode 15 should be visited before node 11\nnode 15 should be visited before node 0\nnode 15 should be visited before node 2\nnode 15 should be visited before node 19\nnode 15 should be visited before node 21\nnode 15 should be visited before node 16\nnode 15 should be visited before node 6\nnode 15 should be visited before node 17\nnode 15 should be visited before node 18\nnode 15 should be visited before node 9\nnode 15 should be visited before node 7\nnode 15 should be visited before node 12\nnode 15 should be visited before node 3\nnode 15 should be visited before node 10\nnode 15 should be visited before node 13\nnode 16 should be visited before node 6\nnode 16 should be visited before node 17\nnode 16 should be visited before node 18\nnode 16 should be visited before node 9\nnode 16 should be visited before node 12\nnode 16 should be visited before node 3\nnode 16 should be visited before node 20\nnode 16 should be visited before node 5\nnode 17 should be visited before node 18\nnode 17 should be visited before node 7\nnode 17 should be visited before node 12\nnode 17 should be visited before node 3\nnode 17 should be visited before node 20\nnode 17 should be visited before node 10\nnode 17 should be visited before node 13\nnode 17 should be visited before node 5\nnode 18 should be visited before node 9\nnode 18 should be visited before node 7\nnode 18 should be visited before node 12\nnode 18 should be visited before node 20\nnode 18 should be visited before node 10\nnode 18 should be visited before node 13\nnode 19 should be visited before node 1\nnode 19 should be visited before node 21\nnode 19 should be visited before node 6\nnode 19 should be visited before node 18\nnode 19 should be visited before node 9\nnode 19 should be visited before node 12\nnode 19 should be visited before node 20\nnode 19 should be visited before node 10\nnode 19 should be visited before node 5\nnode 20 should be visited before node 10\nnode 20 should be visited before node 13\nnode 20 should be visited before node 5\nnode 21 should be visited before node 16\nnode 21 should be visited before node 6\nnode 21 should be visited before node 17\nnode 21 should be visited before node 18\nnode 21 should be visited before node 7\nnode 21 should be visited before node 3\nnode 21 should be visited before node 20\nnode 21 should be visited before node 10\nnode 21 should be visited before node 13\nQ: Can all the nodes be visited? Give the solution.\nA:",
                "code": "import networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': 22,\n    'Edges': [\n        {'from': 0, 'to': 2}, {'from': 0, 'to': 19}, {'from': 0, 'to': 8},\n        {'from': 0, 'to': 1}, {'from': 0, 'to': 21}, {'from': 0, 'to': 16},\n        {'from': 0, 'to': 6}, {'from': 0, 'to': 18}, {'from': 0, 'to': 7},\n        {'from': 0, 'to': 12}, {'from': 0, 'to': 3}, {'from': 0, 'to': 20},\n        {'from': 0, 'to': 10}, {'from': 0, 'to': 13}, {'from': 0, 'to': 5},\n        {'from': 1, 'to': 21}, {'from': 1, 'to': 16}, {'from': 1, 'to': 6},\n        {'from': 1, 'to': 17}, {'from': 1, 'to': 18}, {'from': 1, 'to': 7},\n        {'from': 1, 'to': 12}, {'from': 1, 'to': 3}, {'from': 1, 'to': 20},\n        {'from': 1, 'to': 10}, {'from': 1, 'to': 13}, {'from': 1, 'to': 5},\n        {'from': 2, 'to': 19}, {'from': 2, 'to': 8}, {'from': 2, 'to': 21},\n        {'from': 2, 'to': 16}, {'from': 2, 'to': 18}, {'from': 2, 'to': 3},\n        {'from': 2, 'to': 20}, {'from': 2, 'to': 13}, {'from': 3, 'to': 20},\n        {'from': 3, 'to': 10}, {'from': 3, 'to': 13}, {'from': 3, 'to': 5},\n        {'from': 4, 'to': 15}, {'from': 4, 'to': 2}, {'from': 4, 'to': 19},\n        {'from': 4, 'to': 1}, {'from': 4, 'to': 21}, {'from': 4, 'to': 16},\n        {'from': 4, 'to': 6}, {'from': 4, 'to': 17}, {'from': 4, 'to': 9},\n        {'from': 4, 'to': 7}, {'from': 4, 'to': 3}, {'from': 4, 'to': 10},\n        {'from': 4, 'to': 13}, {'from': 6, 'to': 18}, {'from': 6, 'to': 7},\n        {'from': 6, 'to': 12}, {'from': 6, 'to': 3}, {'from': 6, 'to': 10},\n        {'from': 6, 'to': 13}, {'from': 7, 'to': 20}, {'from': 7, 'to': 10},\n        {'from': 7, 'to': 13}, {'from': 7, 'to': 5}, {'from': 8, 'to': 1},\n        {'from': 8, 'to': 21}, {'from': 8, 'to': 16}, {'from': 8, 'to': 7},\n        {'from': 8, 'to': 12}, {'from': 8, 'to': 3}, {'from': 8, 'to': 20},\n        {'from': 8, 'to': 10}, {'from': 8, 'to': 13}, {'from': 8, 'to': 5},\n        {'from': 9, 'to': 7}, {'from': 9, 'to': 12}, {'from': 9, 'to': 3},\n        {'from': 9, 'to': 13}, {'from': 10, 'to': 13}, {'from': 11, 'to': 2},\n        {'from': 11, 'to': 1}, {'from': 11, 'to': 16}, {'from': 11, 'to': 6},\n        {'from': 11, 'to': 17}, {'from': 11, 'to': 18}, {'from': 11, 'to': 9},\n        {'from': 11, 'to': 7}, {'from': 11, 'to': 12}, {'from': 11, 'to': 20},\n        {'from': 11, 'to': 10}, {'from': 11, 'to': 5}, {'from': 12, 'to': 3},\n        {'from': 12, 'to': 20}, {'from': 12, 'to': 10}, {'from': 12, 'to': 13},\n        {'from': 12, 'to': 5}, {'from': 13, 'to': 5}, {'from': 14, 'to': 15},\n        {'from': 14, 'to': 11}, {'from': 14, 'to': 2}, {'from': 14, 'to': 8},\n        {'from': 14, 'to': 1}, {'from': 14, 'to': 21}, {'from': 14, 'to': 16},\n        {'from': 14, 'to': 17}, {'from': 14, 'to': 7}, {'from': 14, 'to': 12},\n        {'from': 14, 'to': 20}, {'from': 14, 'to': 10}, {'from': 14, 'to': 13}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes\nG.add_nodes_from(range(input_data['Nodes']))\n\n# Add edges\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'])\n\ntry:\n    # Attempt to perform a topological sort\n    topo_order = list(nx.topological_sort(G))\n    \n    # Check if all nodes are included in the topological order\n    if len(topo_order) == input_data['Nodes']:\n        print(\"The solution is: \" + \",\".join(map(str, topo_order)))\n    else:\n        print(\"Not all nodes can be visited. The topological sort does not include all nodes.\")\nexcept nx.NetworkXUnfeasible:\n    # A cycle exists in the graph, so topological sort is not possible\n    print(\"Not all nodes can be visited. The graph contains a cycle and is not a DAG.\")",
                "key_api": "The key API used in the solution is the NetworkX library, specifically the functions 'nx.DiGraph()' for constructing a directed graph and 'nx.topological_sort()' for attempting topological sorting. The 'nx.NetworkXUnfeasible' exception was also used to catch errors when the graph contains cycles, preventing topological sorting.",
                "key_experience": "Best practices included: 1. Exception handling to manage scenarios where topological sorting is unfeasible. 2. Breaking down the problem into clear steps: constructing the graph, adding nodes and edges, and checking for cycles. 3. Ensuring the solution handles edge cases, like cyclic graphs. 4. Presenting a user-friendly output indicating both the success of the operation and the topological order if it exists."
            }
        ]
    },
    {
        "id": 61,
        "problem": "Determine if all nodes can be visited based on the given constraints.",
        "graph_type": "directed",
        "experience": "In this engagement, the task was to determine if all nodes in a directed graph can be visited based on given constraints. The approach involved constructing the graph using NetworkX, adding nodes and edges as specified, and then applying topological sorting to assess the graph's properties. The process included handling exceptions to account for cycles that would prevent a successful topological sort, thereby determining the visitability of all nodes.",
        "rag_data": [],
        "accuracy": 0.85,
        "example": [
            {
                "question": "In a directed graph with 16 nodes numbered from 0 to 15:\nnode 1 should be visited before node 9\nnode 1 should be visited before node 10\nnode 1 should be visited before node 3\nnode 1 should be visited before node 6\nnode 2 should be visited before node 13\nnode 2 should be visited before node 0\nnode 2 should be visited before node 8\nnode 4 should be visited before node 15\nnode 4 should be visited before node 7\nnode 4 should be visited before node 2\nnode 4 should be visited before node 0\nnode 4 should be visited before node 6\nnode 5 should be visited before node 2\nnode 5 should be visited before node 8\nnode 5 should be visited before node 11\nnode 7 should be visited before node 10\nnode 7 should be visited before node 0\nnode 7 should be visited before node 6\nnode 7 should be visited before node 11\nnode 9 should be visited before node 5\nnode 9 should be visited before node 2\nnode 9 should be visited before node 13\nnode 9 should be visited before node 6\nnode 9 should be visited before node 11\nnode 10 should be visited before node 3\nnode 12 should be visited before node 9\nnode 12 should be visited before node 8\nnode 12 should be visited before node 6\nnode 12 should be visited before node 11\nnode 13 should be visited before node 3\nnode 13 should be visited before node 8\nnode 13 should be visited before node 6\nnode 14 should be visited before node 5\nnode 14 should be visited before node 3\nnode 15 should be visited before node 2\nnode 15 should be visited before node 0\nQ: Can all the nodes be visited? Give the solution.\nA:",
                "code": "import networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': 16,\n    'Edges': [\n        {'from': 1, 'to': 9}, {'from': 1, 'to': 10}, {'from': 1, 'to': 3},\n        {'from': 1, 'to': 6}, {'from': 2, 'to': 13}, {'from': 2, 'to': 0},\n        {'from': 2, 'to': 8}, {'from': 4, 'to': 15}, {'from': 4, 'to': 7},\n        {'from': 4, 'to': 2}, {'from': 4, 'to': 0}, {'from': 4, 'to': 6},\n        {'from': 5, 'to': 2}, {'from': 5, 'to': 8}, {'from': 5, 'to': 11},\n        {'from': 7, 'to': 10}, {'from': 7, 'to': 0}, {'from': 7, 'to': 6},\n        {'from': 7, 'to': 11}, {'from': 9, 'to': 5}, {'from': 9, 'to': 2},\n        {'from': 9, 'to': 13}, {'from': 9, 'to': 6}, {'from': 9, 'to': 11},\n        {'from': 10, 'to': 3}, {'from': 12, 'to': 9}, {'from': 12, 'to': 8},\n        {'from': 12, 'to': 6}, {'from': 12, 'to': 11}, {'from': 13, 'to': 3},\n        {'from': 13, 'to': 8}, {'from': 13, 'to': 6}, {'from': 14, 'to': 5},\n        {'from': 14, 'to': 3}, {'from': 15, 'to': 2}, {'from': 15, 'to': 0}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes\nG.add_nodes_from(range(input_data['Nodes']))\n\n# Add edges\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'])\n\ntry:\n    # Attempt to perform a topological sort\n    topo_order = list(nx.topological_sort(G))\n    \n    # Check if all nodes are included in the topological order\n    if len(topo_order) == input_data['Nodes']:\n        print(\"The solution is: \" + \",\".join(map(str, topo_order)))\n    else:\n        print(\"Not all nodes can be visited. The topological sort does not include all nodes.\")\nexcept nx.NetworkXUnfeasible:\n    # A cycle exists in the graph, so topological sort is not possible\n    print(\"Not all nodes can be visited. The graph contains a cycle and is not a DAG.\")",
                "key_api": "\"networkx.DiGraph()\",\n\"G.add_nodes_from()\",\n\"G.add_edge()\",\n\"networkx.topological_sort()\",\n\"networkx.NetworkXUnfeasible\"",
                "key_experience": "1. Use NetworkX to simplify graph representation and operations.\n2. Define the graph as undirected if the connection is bidirectional.\n3. Add all nodes and edges to the graph before performing connectivity checks.\n4. Utilize existing libraries and their methods to avoid reinventing the wheel and ensure efficiency."
            }
        ]
    },
    {
        "id": 62,
        "problem": "List all the nodes connected to 4 in alphabetical order.",
        "graph_type": "undirected",
        "experience": "The task involved creating an undirected graph using NetworkX, adding nodes and edges from the provided input data, and listing nodes connected to node 4 in alphabetical order. The correct steps were followed, and the task was successfully completed.",
        "rag_data": [
            {
                "Section ID": "neighbors",
                "Description": [
                    "Returns an iterator over all neighbors of node n.",
                    "This function wraps the G.neighbors function."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, and 4.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 4) (1, 2) (1, 3) (1, 4) (2, 3) (2, 4) (3, 4).\nQ: List all the nodes connected to 4 in alphabetical order.\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'nodes': [0, 1, 2, 3, 4],\n    'edges': [[0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(input_data['nodes'])\nG.add_edges_from(input_data['edges'])\n\n# Find all nodes connected to node 4\nconnected_nodes = list(G.neighbors(4))\n\n# Sort the connected nodes in alphabetical order (numerically in this case)\nconnected_nodes.sort()\n\n# Print the result\nprint(connected_nodes)\n",
                "key_api": "The key API used was NetworkX for graph-related operations. The relevant functions included `nx.Graph()` for creating a graph, `add_nodes_from` for adding nodes, `add_edges_from` for adding edges, and `G.neighbors(4)` for finding neighbors of a node.",
                "key_experience": "The best practices included:\n1. Clearly defining input data.\n2. Using NetworkX's built-in functions for handling graph data structures.\n3. Ensuring correct addition of nodes and edges to the graph.\n4. Using Python's list operations to sort and display the result.\n5. Maintaining clear and readable code structure."
            }
        ]
    },
    {
        "id": 63,
        "problem": "List all the nodes connected to 1 in alphabetical order.",
        "graph_type": "undirected",
        "experience": "In the recent engagement, the task was to list all nodes connected to node 1 in a graph, sorted alphabetically. The process involved using the NetworkX library to create and manipulate graphs.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, and 12.\nThe edges in G are: (0, 12) (1, 3) (1, 4) (1, 10) (1, 11) (2, 12) (3, 5) (3, 10) (4, 8) (7, 11) (9, 10).\nQ: List all the nodes connected to 1 in alphabetical order.\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n    'Edges': [[0, 12], [1, 3], [1, 4], [1, 10], [1, 11], [2, 12], [3, 5], [3, 10], [4, 8], [7, 11], [9, 10]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Find all nodes connected to node 1\nconnected_nodes = list(G.neighbors(1))\n\n# Sort the connected nodes in alphabetical order (numerically in this case)\nconnected_nodes.sort()\n\n# Print the connected nodes\nprint(connected_nodes)\n",
                "key_api": "networkx",
                "key_experience": "['1. Initialize graph using `nx.Graph()` for creating an undirected graph.', '2. Add nodes and edges using `G.add_nodes_from(nodes)` and `G.add_edges_from(edges)` respectively.', '3. Retrieve neighbors of a node using `G.neighbors(node)`.', \"4. Sorting the result using Python's built-in `sort()` method.\", '5. Regular printing for validation.', '6. Maintain clarity in code through structured comments.']"
            }
        ]
    },
    {
        "id": 64,
        "problem": "What is the degree of node 10?",
        "graph_type": "undirected",
        "experience": "To determine the degree of a node in a graph, networkx is an extremely useful library. The steps involve creating a graph structure with nodes and edges, and then using networkx functions to analyze the graph.",
        "rag_data": [
            {
                "Section ID": "degree",
                "Description": [
                    "Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of all nodes.",
                    "This function wraps the G.degree property."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, and 16.\nThe edges in G are: (1, 4) (1, 15) (1, 16) (2, 10) (2, 11) (3, 7) (3, 9) (3, 10) (3, 11) (3, 12) (4, 8) (4, 15) (5, 13) (6, 11) (6, 13) (7, 9) (8, 14) (9, 14) (10, 16) (12, 15) (13, 15) (15, 16).\nQ: What is the degree of node 10?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided nodes and edges\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n    'Edges': [[1, 4], [1, 15], [1, 16], [2, 10], [2, 11], [3, 7], [3, 9], \n              [3, 10], [3, 11], [3, 12], [4, 8], [4, 15], [5, 13], \n              [6, 11], [6, 13], [7, 9], [8, 14], [9, 14], [10, 16], \n              [12, 15], [13, 15], [15, 16]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(graph_data['Nodes'])\nG.add_edges_from(graph_data['Edges'])\n\n# Get the degree of node 10\ndegree_node_10 = G.degree[10]\n\n# Print the degree of node 10\nprint(f\"The degree of node 10 is: {degree_node_10}\")\n",
                "key_api": "networkx (nx), such as nx.Graph, add_nodes_from, add_edges_from, and G.degree.",
                "key_experience": "1. Defining the graph data structure clearly with nodes and edges. 2. Using add_nodes_from() and add_edges_from() to efficiently populate the graph. 3. Using nx.Graph() to ensure the graph is undirected by default. 4. Extracting the degree of a node using G.degree[node] for simplicity and readability. 5. Printing the results clearly to provide immediate feedback on the operation."
            }
        ]
    },
    {
        "id": 65,
        "problem": "What is the degree of node 4?",
        "graph_type": "undirected",
        "experience": "To find the degree of a node in a graph, we used the NetworkX library. The steps included defining the graph data (nodes and edges), creating an undirected graph using NetworkX, adding the nodes and edges to the graph, and then calculating and printing the degree of the specified node (node 4 in this case).",
        "rag_data": [
            {
                "Section ID": "degree",
                "Description": [
                    "Returns a degree view of single node or of nbunch of nodes.\nIf nbunch is omitted, then return degrees of all nodes.",
                    "This function wraps the G.degree property."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, and 5.\nThe edges in G are: (0, 1) (0, 2) (0, 4) (0, 5) (1, 2) (1, 3) (1, 4) (2, 3) (2, 5) (3, 4) (3, 5) (4, 5).\nQ: What is the degree of node 4?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph using the provided nodes and edges\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5],\n    'Edges': [[0, 1], [0, 2], [0, 4], [0, 5], [1, 2], [1, 3], [1, 4], \n              [2, 3], [2, 5], [3, 4], [3, 5], [4, 5]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(graph_data['Nodes'])\nG.add_edges_from(graph_data['Edges'])\n\n# Calculate the degree of node 4\ndegree_node_4 = G.degree[4]\n\n# Output the degree of node 4\nprint(f\"The degree of node 4 is: {degree_node_4}\")\n",
                "key_api": "networkx (nx), specifically nx.Graph(), add_nodes_from(), add_edges_from(), and G.degree",
                "key_experience": "Using libraries suited for the domain task (NetworkX for graph manipulation), clearly defining graph structure, and ensuring proper use of library functions to handle graph operations efficiently."
            }
        ]
    },
    {
        "id": 66,
        "problem": "How many nodes are in this graph?",
        "graph_type": "undirected",
        "experience": "The task involved counting the number of nodes in a graph using the NetworkX library in Python. The given code included input data, which consisted of nodes and edges, and utilized various NetworkX methods to create the graph, add nodes and edges, and then calculate and print the number of nodes.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, and 18.\nThe edges in G are: (0, 3) (0, 11) (0, 18) (1, 4) (1, 8) (1, 10) (1, 12) (1, 13) (1, 17) (2, 3) (2, 6) (2, 13) (2, 17) (3, 7) (3, 12) (3, 13) (3, 15) (3, 16) (3, 17) (4, 8) (4, 9) (4, 14) (4, 17) (5, 8) (5, 13) (5, 16) (6, 7) (6, 14) (6, 16) (7, 15) (8, 9) (8, 14) (8, 16) (8, 17) (8, 18) (9, 10) (9, 11) (9, 12) (9, 15) (9, 16) (9, 17) (10, 15) (10, 16) (11, 14) (11, 15) (11, 18) (12, 13) (12, 14) (12, 17) (14, 16) (14, 18) (16, 18).\nQ: How many nodes are in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],\n    'Edges': [[0, 3], [0, 11], [0, 18], [1, 4], [1, 8], [1, 10], [1, 12], [1, 13], [1, 17], \n              [2, 3], [2, 6], [2, 13], [2, 17], [3, 7], [3, 12], [3, 13], [3, 15], \n              [3, 16], [3, 17], [4, 8], [4, 9], [4, 14], [4, 17], [5, 8], [5, 13], \n              [5, 16], [6, 7], [6, 14], [6, 16], [7, 15], [8, 9], [8, 14], [8, 16], \n              [8, 17], [8, 18], [9, 10], [9, 11], [9, 12], [9, 15], [9, 16], [9, 17], \n              [10, 15], [10, 16], [11, 14], [11, 15], [11, 18], [12, 13], [12, 14], \n              [12, 17], [14, 16], [14, 18], [16, 18]]\n}\n\n# Create a graph\nG = nx.Graph()  # Use nx.DiGraph() for directed graphs if needed\n\n# Add nodes and edges to the graph\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Count the number of nodes\nnum_nodes = G.number_of_nodes()\n\n# Output the result\nprint(f'The number of nodes in the graph is: {num_nodes}')\n",
                "key_api": "networkx",
                "key_experience": "['Use of NetworkX Graph object', 'Adding nodes to the graph', 'Adding edges to the graph', 'Using number_of_nodes() method to count the nodes']"
            }
        ]
    },
    {
        "id": 67,
        "problem": "How many nodes are in this graph?",
        "graph_type": "undirected",
        "experience": "In this engagement, we focused on using the NetworkX library to determine the number of nodes in a graph from given input data. The user's initial attempt and the assistant's response were largely similar, emphasizing reading the input data, constructing the graph, and counting the nodes efficiently.",
        "rag_data": [
            {
                "Section ID": "number_of_nodes",
                "Description": [
                    "Returns the number of nodes in the graph.",
                    "This function wraps the G.number_of_nodes function."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9.\nThe edges in G are: (0, 2) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (1, 2) (1, 3) (1, 4) (1, 6) (1, 7) (1, 8) (1, 9) (2, 4) (2, 5) (2, 6) (2, 7) (2, 9) (3, 5) (3, 6) (3, 7) (4, 6) (4, 7) (4, 8) (5, 7) (6, 7) (6, 8) (7, 8) (7, 9) (8, 9).\nQ: How many nodes are in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n    'Edges': [[0, 2], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], \n              [1, 2], [1, 3], [1, 4], [1, 6], [1, 7], [1, 8], \n              [1, 9], [2, 4], [2, 5], [2, 6], [2, 7], [2, 9], \n              [3, 5], [3, 6], [3, 7], [4, 6], [4, 7], [4, 8], \n              [5, 7], [6, 7], [6, 8], [7, 8], [7, 9], [8, 9]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Count the number of nodes in the graph\nnum_nodes = G.number_of_nodes()\n\n# Output the number of nodes\nprint(f'The number of nodes in the graph is: {num_nodes}')\n",
                "key_api": "The key API used in the code is the NetworkX library, specifically: nx.Graph(), G.add_nodes_from(), G.add_edges_from(), and G.number_of_nodes().",
                "key_experience": "The best practices in the code include: 1. Organizing input data clearly. 2. Constructing the graph using NetworkX in a straightforward way by adding nodes and edges. 3. Utilizing specific NetworkX methods for graph operations. 4. Printing the final output in a readable format."
            }
        ]
    },
    {
        "id": 68,
        "problem": "How many edges are in this graph?",
        "graph_type": "undirected",
        "experience": "In a recent code-writing task, the goal was to determine the number of edges in a graph using the NetworkX library. The process involved creating a graph from given nodes and edges and then counting the edges. This approach involved specific steps to ensure the correct structure and accurate count.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, and 12.\nThe edges in G are: (0, 1) (0, 3) (0, 6) (0, 7) (0, 10) (0, 11) (0, 12) (1, 2) (1, 3) (1, 5) (1, 6) (1, 7) (1, 9) (1, 10) (1, 11) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 9) (2, 11) (3, 4) (3, 5) (3, 6) (3, 7) (3, 8) (3, 10) (3, 11) (3, 12) (4, 5) (4, 7) (4, 8) (4, 9) (4, 10) (4, 11) (5, 6) (5, 8) (5, 10) (5, 11) (5, 12) (6, 12) (7, 8) (7, 9) (7, 10) (7, 12) (8, 10) (8, 11) (8, 12) (9, 10) (9, 11) (9, 12) (10, 12) (11, 12).\nQ: How many edges are in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],\n    'Edges': [\n        [0, 1], [0, 3], [0, 6], [0, 7], [0, 10], [0, 11], [0, 12],\n        [1, 2], [1, 3], [1, 5], [1, 6], [1, 7], [1, 9], [1, 10], [1, 11],\n        [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 9], [2, 11],\n        [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [3, 10], [3, 11], [3, 12],\n        [4, 5], [4, 7], [4, 8], [4, 9], [4, 10], [4, 11],\n        [5, 6], [5, 8], [5, 10], [5, 11], [5, 12],\n        [6, 12], [7, 8], [7, 9], [7, 10], [7, 12],\n        [8, 10], [8, 11], [8, 12],\n        [9, 10], [9, 11], [9, 12],\n        [10, 12], [11, 12]\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Count the number of edges in the graph\nnumber_of_edges = G.number_of_edges()\n\n# Output the result\nprint(f'The number of edges in the graph is: {number_of_edges}')\n",
                "key_api": "NetworkX library, specifically the `nx.Graph()` class and its methods `add_nodes_from`, `add_edges_from`, and `number_of_edges`.",
                "key_experience": "Key best practices include: 1) Clear input structuring with nodes and edges, 2) Proper use of NetworkX methods for adding nodes and edges, and 3) Efficiently using NetworkX's built-in function to count edges, ensuring accurate and optimized solutions."
            }
        ]
    },
    {
        "id": 69,
        "problem": "How many edges are in this graph?",
        "graph_type": "undirected",
        "experience": "In the recent engagement to determine the number of edges in a graph using NetworkX, the solution involved constructing a graph from given nodes and edges, then using built-in NetworkX functions to count and print the number of edges. The process was successfully executed without any errors.",
        "rag_data": [
            {
                "Section ID": "number_of_edges",
                "Description": [
                    "Returns the number of edges in the graph.",
                    "This function wraps the G.number_of_edges function."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10.\nThe edges in G are: (2, 6) (3, 8) (4, 5) (6, 7).\nQ: How many edges are in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    'Edges': [[2, 6], [3, 8], [4, 5], [6, 7]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes to the graph\nG.add_nodes_from(data['Nodes'])\n\n# Add edges to the graph\nG.add_edges_from(data['Edges'])\n\n# Count the number of edges in the graph\nnumber_of_edges = G.number_of_edges()\n\n# Output the result\nprint(\"Number of edges in the graph:\", number_of_edges)\n",
                "key_api": "['networkx.Graph()', 'Graph.add_nodes_from()', 'Graph.add_edges_from()', 'Graph.number_of_edges()']",
                "key_experience": "['Utilizing NetworkX for graph operations, which simplifies creating and managing graph structures', 'Structuring the data properly with nodes and edges clearly defined', \"Using specific methods from the NetworkX library for node and edge manipulations like 'add_nodes_from' and 'add_edges_from'\", \"Counting elements using 'number_of_edges()', which is a direct and efficient method to retrieve the edge count\"]"
            }
        ]
    },
    {
        "id": 70,
        "problem": "Is node 16 has an edge to node 9?",
        "graph_type": "undirected",
        "experience": "Use NetworkX's built-in function to check for the existence of a edge between the two nodes.",
        "rag_data": [
            {
                "Section ID": "has_edge",
                "Description": [],
                "Field List": {
                    "Parameters:": {
                        "u, v : nodes": "Nodes can be, for example, strings or numbers.\nNodes must be hashable (and not None) Python objects."
                    },
                    "Returns:": {
                        "edge_ind : bool": "True if edge is in the graph, False otherwise."
                    }
                },
                "Rubrics": {
                    "Examples": "G=nx.path_graph(4)# or DiGraph, MultiGraph, MultiDiGraph, etc\nG.has_edge(0,1)# using two nodes\n# True\ne=(0,1)\nG.has_edge(*e)#  e is a 2-tuple (u, v)\n# True\ne=(0,1,{\"weight\":7})\nG.has_edge(*e[:2])# e is a 3-tuple (u, v, data_dictionary)\n# True\nThe following syntax are equivalent:\nG.has_edge(0,1)\n# True\n1inG[0]# though this gives KeyError if 0 not in G\n# True"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, and 18.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (0, 10) (0, 11) (0, 12) (0, 13) (0, 14) (0, 15) (0, 16) (0, 17) (0, 18) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 9) (1, 10) (1, 11) (1, 12) (1, 14) (1, 15) (1, 16) (1, 17) (1, 18) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 8) (2, 10) (2, 11) (2, 12) (2, 13) (2, 14) (2, 16) (2, 17) (2, 18) (3, 4) (3, 5) (3, 6) (3, 8) (3, 9) (3, 10) (3, 11) (3, 12) (3, 13) (3, 14) (3, 15) (3, 16) (3, 17) (3, 18) (4, 5) (4, 6) (4, 7) (4, 8) (4, 9) (4, 10) (4, 11) (4, 13) (4, 14) (4, 15) (4, 16) (4, 17) (4, 18) (5, 6) (5, 7) (5, 8) (5, 10) (5, 11) (5, 12) (5, 13) (5, 14) (5, 15) (5, 16) (5, 17) (5, 18) (6, 7) (6, 8) (6, 9) (6, 10) (6, 11) (6, 12) (6, 13) (6, 14) (6, 15) (6, 16) (6, 17) (6, 18) (7, 8) (7, 9) (7, 10) (7, 11) (7, 12) (7, 13) (7, 14) (7, 15) (7, 16) (7, 17) (7, 18) (8, 9) (8, 10) (8, 11) (8, 13) (8, 16) (8, 17) (8, 18) (9, 10) (9, 11) (9, 12) (9, 13) (9, 14) (9, 15) (9, 16) (9, 17) (9, 18) (10, 12) (10, 13) (10, 14) (10, 15) (10, 16) (10, 17) (10, 18) (11, 12) (11, 13) (11, 14) (11, 15) (11, 16) (11, 17) (11, 18) (12, 13) (12, 15) (12, 16) (12, 17) (12, 18) (13, 14) (13, 15) (13, 16) (13, 17) (13, 18) (14, 15) (14, 16) (14, 18) (15, 16) (15, 17) (15, 18) (16, 17) (16, 18) (17, 18).\nQ: Is node 16 has an edge to node 9?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the input graph data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],\n    'Edges': [\n        [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9],\n        [0, 10], [0, 11], [0, 12], [0, 13], [0, 14], [0, 15], [0, 16], [0, 17],\n        [0, 18], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9],\n        [1, 10], [1, 11], [1, 12], [1, 14], [1, 15], [1, 16], [1, 17], [1, 18],\n        [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 10], [2, 11], [2, 12],\n        [2, 13], [2, 14], [2, 16], [2, 17], [2, 18], [3, 4], [3, 5], [3, 6],\n        [3, 8], [3, 9], [3, 10], [3, 11], [3, 12], [3, 13], [3, 14], [3, 15],\n        [3, 16], [3, 17], [3, 18], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9],\n        [4, 10], [4, 11], [4, 13], [4, 14], [4, 15], [4, 16], [4, 17], [4, 18],\n        [5, 6], [5, 7], [5, 8], [5, 10], [5, 11], [5, 12], [5, 13], [5, 14],\n        [5, 15], [5, 16], [5, 17], [5, 18], [6, 7], [6, 8], [6, 9], [6, 10],\n        [6, 11], [6, 12], [6, 13], [6, 14], [6, 15], [6, 16], [6, 17], [6, 18],\n        [7, 8], [7, 9], [7, 10], [7, 11], [7, 12], [7, 13], [7, 14], [7, 15],\n        [7, 16], [7, 17], [7, 18], [8, 9], [8, 10], [8, 11], [8, 13], [8, 16],\n        [8, 17], [8, 18], [9, 10], [9, 11], [9, 12], [9, 13], [9, 14], [9, 15],\n        [9, 16], [9, 17], [9, 18], [10, 12], [10, 13], [10, 14], [10, 15],\n        [10, 16], [10, 17], [10, 18], [11, 12], [11, 13], [11, 14], [11, 15],\n        [11, 16], [11, 17], [11, 18], [12, 13], [12, 15], [12, 16], [12, 17],\n        [12, 18], [13, 14], [13, 15], [13, 16], [13, 17], [13, 18], [14, 15],\n        [14, 16], [14, 18], [15, 16], [15, 17], [15, 18], [16, 17], [16, 18],\n        [17, 18]\n    ]\n}\n\n# Create an undirected graph from the input data\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Check if there is a path from node 16 to node 9\nedge_exists = G.has_edge(16, 9)\n\n# Output the result\nprint(f\"Is there a edge from node 16 to node 9? {edge_exists}\")\n",
                "key_api": "networkx (nx), nx.Graph(), G.add_nodes_from(), G.add_edges_from(), nx.has_path()",
                "key_experience": "['Using a clear and structured approach to solve the problem.', 'Leveraging built-in functions for efficiency.'']"
            }
        ]
    },
    {
        "id": 71,
        "problem": "Is node 0 has an edge to node 3?",
        "graph_type": "undirected",
        "experience": "Your experience and practices here. You can use tell the key points and the steps to solve the problem.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, and 10.\nThe edges in G are: (0, 1) (0, 3) (0, 5) (0, 8) (0, 10) (1, 2) (1, 4) (1, 6) (1, 7) (1, 8) (2, 7) (2, 9) (2, 10) (3, 5) (3, 8) (3, 9) (4, 5) (4, 6) (4, 9) (4, 10) (5, 9) (6, 7) (6, 10) (7, 10) (8, 9) (8, 10).\nQ: Is node 0 has an edge to node 3?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the input\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n    'Edges': [\n        [0, 1], [0, 3], [0, 5], [0, 8], [0, 10],\n        [1, 2], [1, 4], [1, 6], [1, 7], [1, 8],\n        [2, 7], [2, 9], [2, 10], [3, 5], [3, 8],\n        [3, 9], [4, 5], [4, 6], [4, 9], [4, 10],\n        [5, 9], [6, 7], [6, 10], [7, 10], [8, 9],\n        [8, 10]\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Check if there is an edge from node 0 to node 3\nedge_exists = G.has_edge(0, 3)\n\n# Output the result\nprint(f\"Is there an edge from node 0 to node 3? {edge_exists}\")\n",
                "key_api": "networkx has_path",
                "key_experience": "defining graph data structure, creating undirected graph, function to check edge existence and using nx.has_edge"
            }
        ]
    },
    {
        "id": 72,
        "problem": "How many triangles are in this graph?",
        "graph_type": "undirected",
        "experience": "In the provided engagement, the task was to determine the number of triangles in a given graph. The key steps included defining the graph with nodes and edges, creating an undirected graph with NetworkX, and using NetworkX's triangle counting functionality to sum the number of triangles.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, and 18.\nThe edges in G are: (0, 2) (0, 5) (0, 13) (0, 16) (0, 17) (1, 2) (1, 4) (1, 5) (1, 6) (1, 8) (1, 10) (1, 11) (1, 13) (1, 14) (1, 18) (2, 4) (2, 5) (2, 7) (2, 10) (2, 11) (2, 12) (2, 13) (2, 14) (2, 15) (2, 16) (2, 17) (2, 18) (3, 4) (3, 5) (3, 7) (3, 9) (3, 10) (3, 12) (3, 14) (3, 15) (3, 16) (3, 17) (4, 5) (4, 7) (4, 8) (4, 9) (4, 10) (4, 13) (4, 14) (4, 15) (4, 18) (5, 6) (5, 7) (5, 12) (5, 13) (5, 15) (5, 16) (5, 17) (5, 18) (6, 7) (6, 9) (6, 10) (6, 13) (7, 11) (7, 12) (7, 13) (7, 14) (7, 15) (7, 17) (8, 9) (8, 10) (8, 12) (8, 14) (8, 17) (9, 10) (9, 13) (9, 17) (9, 18) (10, 14) (10, 15) (11, 12) (11, 17) (11, 18) (12, 13) (12, 14) (12, 17) (12, 18) (13, 14) (13, 16) (14, 16) (14, 17) (14, 18) (15, 16) (16, 18).\nQ: How many triangles are in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],\n    'Edges': [\n        [0, 2], [0, 5], [0, 13], [0, 16], [0, 17], [1, 2], [1, 4], [1, 5], [1, 6],\n        [1, 8], [1, 10], [1, 11], [1, 13], [1, 14], [1, 18], [2, 4], [2, 5], [2, 7],\n        [2, 10], [2, 11], [2, 12], [2, 13], [2, 14], [2, 15], [2, 16], [2, 17], [2, 18],\n        [3, 4], [3, 5], [3, 7], [3, 9], [3, 10], [3, 12], [3, 14], [3, 15], [3, 16],\n        [3, 17], [4, 5], [4, 7], [4, 8], [4, 9], [4, 10], [4, 13], [4, 14], [4, 15],\n        [4, 18], [5, 6], [5, 7], [5, 12], [5, 13], [5, 15], [5, 16], [5, 17], [5, 18],\n        [6, 7], [6, 9], [6, 10], [6, 13], [7, 11], [7, 12], [7, 13], [7, 14], [7, 15],\n        [7, 17], [8, 9], [8, 10], [8, 12], [8, 14], [8, 17], [9, 10], [9, 13], [9, 17],\n        [9, 18], [10, 14], [10, 15], [11, 12], [11, 17], [11, 18], [12, 13], [12, 14],\n        [12, 17], [12, 18], [13, 14], [13, 16], [14, 16], [14, 17], [14, 18], [15, 16],\n        [16, 18]\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Count the number of triangles in the graph\ntriangle_count = sum(nx.triangles(G).values()) // 3\n\n# Output the number of triangles\nprint(f'The number of triangles in the graph is: {triangle_count}')\n",
                "key_api": "NetworkX",
                "key_experience": "['Defining the graph data using dictionaries for nodes and edges.', \"Creating an undirected graph using NetworkX's Graph class.\", 'Adding nodes and edges to the graph from the input data.', \"Utilizing NetworkX's triangles function to count the number of triangles.\", 'Ensuring the output is correctly divided by 3 because each triangle is counted three times.']"
            }
        ]
    },
    {
        "id": 73,
        "problem": "How many triangles are in this graph?",
        "graph_type": "undirected",
        "experience": "When analyzing and solving a problem involving counting triangles in a graph, the user created a graph using the NetworkX library. The graph was defined by a given set of nodes and edges. The assistant provided a solution by constructing the graph with NetworkX, then using the `nx.triangles()` method to count the number of triangles. The number of triangles was determined by summing the values from `nx.triangles()` and dividing by three to account for each triangle being counted three times (once at each vertex). The connection between defining nodes and edges, creating a graph, and using NetworkX's built-in functionalities was demonstrated effectively.",
        "rag_data": [
            {
                "Section ID": "triangles",
                "Description": [
                    "Compute the number of triangles.",
                    "Finds the number of triangles that include a node as one vertex."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A networkx graph",
                        "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG."
                    },
                    "Returns:": {
                        "out : dict or int": "Ifnodesis a container of nodes, returns number of triangles keyed by node (dict).\nIfnodesis a specific node, returns number of triangles for the node (int)."
                    }
                },
                "Rubrics": {
                    "Notes": "Self loops are ignored.",
                    "Examples": "G=nx.complete_graph(5)\nprint(nx.triangles(G,0))\n# 6\nprint(nx.triangles(G))\n# {0: 6, 1: 6, 2: 6, 3: 6, 4: 6}\nprint(list(nx.triangles(G,[0,1]).values()))\n# [6, 6]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, and 6.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 5) (0, 6) (1, 3) (1, 4) (1, 6) (2, 3) (2, 4) (2, 5) (2, 6) (3, 5) (4, 5) (5, 6).\nQ: How many triangles are in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the input\ninput_data = {\n    'nodes': [0, 1, 2, 3, 4, 5, 6],\n    'edges': [[0, 1], [0, 2], [0, 3], [0, 5], [0, 6], \n              [1, 3], [1, 4], [1, 6], [2, 3], [2, 4], \n              [2, 5], [2, 6], [3, 5], [4, 5], [5, 6]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(input_data['nodes'])\nG.add_edges_from(input_data['edges'])\n\n# Calculate the number of triangles\ntriangle_count = sum(nx.triangles(G).values()) // 3  # Each triangle is counted three times\n\n# Output the number of triangles\nprint(f'The number of triangles in the graph is: {triangle_count}')\n",
                "key_api": "nx.triangles()",
                "key_experience": "1. Using NetworkX for graph modeling, leveraging its extensive library for graph-based algorithms and functionalities.\n2. Summing triangle counts and appropriate normalization/division to account for multiple counts of the same triangles.\n3. Clearly defining input data for the graph structure and methodically adding nodes and edges to the graph."
            }
        ]
    },
    {
        "id": 74,
        "problem": "Is there a path from node 6 to node 0?",
        "graph_type": "undirected",
        "experience": "Analyzing the recent engagement, the task was to determine if there is a path from node 6 to node 0 in an undirected graph using the NetworkX library. The steps included defining the nodes and edges, creating an undirected graph, adding nodes and edges, and utilizing the has_path method to check for a path between the specified nodes.",
        "rag_data": [
            {
                "Section ID": "has_path",
                "Description": [
                    "Returns True if G has a path from source to target ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node": "Starting node for path",
                        "target : node": "Ending node for path"
                    }
                },
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, and 7.\nThe edges in G are: (0, 7) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (2, 7) (3, 5) (5, 7) (6, 7).\nQ: Is there a path from node 6 to node 0?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7],\n    'Edges': [[0, 7], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [2, 7], [3, 5], [5, 7], [6, 7]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(graph_data['Nodes'])\nG.add_edges_from(graph_data['Edges'])\n\n# Check if there is a path from node 6 to node 0\npath_exists = nx.has_path(G, 6, 0)\n\n# Output the result\nif path_exists:\n    print(\"There is a path from node 6 to node 0.\")\nelse:\n    print(\"There is no path from node 6 to node 0.\")\n",
                "key_api": "networkx.has_path(G, 6, 0)",
                "key_experience": "['Defining graph data in a structured format (nodes and edges)', 'Creating an undirected graph using NetworkX', 'Adding nodes and edges to the graph with add_nodes_from and add_edges_from methods', 'Using the has_path function to verify if a path exists between two nodes', 'Returning readable and informative output based on the result of the path check']"
            }
        ]
    },
    {
        "id": 75,
        "problem": "Is there a path from node 8 to node 0?",
        "graph_type": "undirected",
        "experience": "The task was to determine if there is a path from node 8 to node 0 in a graph. The nodes and edges were provided, representing a network of connections. We used the NetworkX library to create and analyze this graph.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, and 15.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 7) (0, 9) (0, 10) (0, 11) (0, 12) (0, 13) (0, 15) (1, 3) (1, 5) (1, 6) (1, 7) (1, 8) (1, 14) (2, 4) (2, 5) (2, 7) (2, 8) (2, 9) (2, 13) (2, 14) (2, 15) (3, 5) (3, 6) (3, 7) (3, 8) (3, 9) (3, 10) (3, 13) (3, 14) (3, 15) (4, 5) (4, 6) (4, 7) (4, 8) (4, 9) (4, 10) (4, 11) (4, 13) (5, 6) (5, 7) (5, 9) (5, 10) (5, 12) (5, 13) (6, 9) (6, 10) (6, 11) (6, 13) (6, 14) (7, 8) (7, 9) (7, 10) (7, 11) (7, 13) (7, 14) (7, 15) (8, 10) (8, 11) (8, 12) (9, 10) (9, 11) (9, 12) (9, 13) (9, 14) (9, 15) (10, 11) (10, 12) (10, 14) (11, 12) (11, 13) (12, 14) (13, 14) (13, 15) (14, 15).\nQ: Is there a path from node 8 to node 0?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the nodes and edges based on the input\nnodes = list(range(16))  # Nodes from 0 to 15\nedges = [\n    [0, 1], [0, 2], [0, 3], [0, 7], [0, 9], [0, 10], [0, 11], [0, 12], \n    [0, 13], [0, 15], [1, 3], [1, 5], [1, 6], [1, 7], [1, 8], [1, 14], \n    [2, 4], [2, 5], [2, 7], [2, 8], [2, 9], [2, 13], [2, 14], [2, 15], \n    [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [3, 10], [3, 13], [3, 14], \n    [3, 15], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [4, 10], [4, 11], \n    [4, 13], [5, 6], [5, 7], [5, 9], [5, 10], [5, 12], [5, 13], [6, 9], \n    [6, 10], [6, 11], [6, 13], [6, 14], [7, 8], [7, 9], [7, 10], [7, 11], \n    [7, 13], [7, 14], [7, 15], [8, 10], [8, 11], [8, 12], [9, 10], \n    [9, 11], [9, 12], [9, 13], [9, 14], [9, 15], [10, 11], [10, 12], \n    [10, 14], [11, 12], [11, 13], [12, 14], [13, 14], [13, 15], [14, 15]\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Check if there is a path from node 8 to node 0\npath_exists = nx.has_path(G, 8, 0)\n\n# Output the result\nprint(f\"Is there a path from node 8 to node 0? {'Yes' if path_exists else 'No'}\")\n",
                "key_api": "NetworkX's has_path function",
                "key_experience": "1. Defining nodes and edges explicitly. 2. Creating an undirected graph using NetworkX. 3. Using the has_path function to check for path existence. 4. Printing clear and readable output using formatted strings."
            }
        ]
    },
    {
        "id": 76,
        "problem": "Is there a cycle in this graph?",
        "graph_type": "undirected",
        "experience": "In this engagement, the user tasked the system with determining if there is a cycle in a given graph using the NetworkX library in Python. The steps taken to solve the problem included: 1) Importing the NetworkX library. 2) Preparing the input data with nodes and edges. 3) Creating an undirected graph and adding nodes and edges. 4) Checking for cycles in the graph.",
        "rag_data": [
            {
                "Section ID": "cycle_basis",
                "Description": [
                    "Returns a list of cycles which form a basis for cycles of G.",
                    "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "",
                        "root : node, optional": "Specify starting node for basis."
                    },
                    "Returns:": {
                        "A list of cycle lists.  Each cycle list is a list of nodes": "",
                        "which forms a cycle (loop) in G.": ""
                    }
                },
                "Rubrics": {
                    "Notes": "This is adapted from algorithm CACM 491 [1] .",
                    "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
                    "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, and 18.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (0, 10) (0, 11) (0, 12) (0, 13) (0, 14) (0, 15) (0, 16) (0, 17) (0, 18) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 9) (1, 10) (1, 11) (1, 12) (1, 14) (1, 15) (1, 16) (1, 17) (1, 18) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 8) (2, 10) (2, 11) (2, 12) (2, 13) (2, 14) (2, 16) (2, 17) (2, 18) (3, 4) (3, 5) (3, 6) (3, 8) (3, 9) (3, 10) (3, 11) (3, 12) (3, 13) (3, 14) (3, 15) (3, 16) (3, 17) (3, 18) (4, 5) (4, 6) (4, 7) (4, 8) (4, 9) (4, 10) (4, 11) (4, 13) (4, 14) (4, 15) (4, 16) (4, 17) (4, 18) (5, 6) (5, 7) (5, 8) (5, 10) (5, 11) (5, 12) (5, 13) (5, 14) (5, 15) (5, 16) (5, 17) (5, 18) (6, 7) (6, 8) (6, 9) (6, 10) (6, 11) (6, 12) (6, 13) (6, 14) (6, 15) (6, 16) (6, 17) (6, 18) (7, 8) (7, 9) (7, 10) (7, 11) (7, 12) (7, 13) (7, 14) (7, 15) (7, 16) (7, 17) (7, 18) (8, 9) (8, 10) (8, 11) (8, 13) (8, 16) (8, 17) (8, 18) (9, 10) (9, 11) (9, 12) (9, 13) (9, 14) (9, 15) (9, 16) (9, 17) (9, 18) (10, 12) (10, 13) (10, 14) (10, 15) (10, 16) (10, 17) (10, 18) (11, 12) (11, 13) (11, 14) (11, 15) (11, 16) (11, 17) (11, 18) (12, 13) (12, 15) (12, 16) (12, 17) (12, 18) (13, 14) (13, 15) (13, 16) (13, 17) (13, 18) (14, 15) (14, 16) (14, 18) (15, 16) (15, 17) (15, 18) (16, 17) (16, 18) (17, 18).\nQ: Is there a cycle in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],\n    'Edges': [\n        [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9],\n        [0, 10], [0, 11], [0, 12], [0, 13], [0, 14], [0, 15], [0, 16], [0, 17],\n        [0, 18], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9],\n        [1, 10], [1, 11], [1, 12], [1, 14], [1, 15], [1, 16], [1, 17], [1, 18],\n        [2, 3], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 10], [2, 11], [2, 12],\n        [2, 13], [2, 14], [2, 16], [2, 17], [2, 18], [3, 4], [3, 5], [3, 6],\n        [3, 8], [3, 9], [3, 10], [3, 11], [3, 12], [3, 13], [3, 14], [3, 15],\n        [3, 16], [3, 17], [3, 18], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9],\n        [4, 10], [4, 11], [4, 13], [4, 14], [4, 15], [4, 16], [4, 17], [4, 18],\n        [5, 6], [5, 7], [5, 8], [5, 10], [5, 11], [5, 12], [5, 13], [5, 14],\n        [5, 15], [5, 16], [5, 17], [5, 18], [6, 7], [6, 8], [6, 9], [6, 10],\n        [6, 11], [6, 12], [6, 13], [6, 14], [6, 15], [6, 16], [6, 17], [6, 18],\n        [7, 8], [7, 9], [7, 10], [7, 11], [7, 12], [7, 13], [7, 14], [7, 15],\n        [7, 16], [7, 17], [7, 18], [8, 9], [8, 10], [8, 11], [8, 13], [8, 16],\n        [8, 17], [8, 18], [9, 10], [9, 11], [9, 12], [9, 13], [9, 14], [9, 15],\n        [9, 16], [9, 17], [9, 18], [10, 12], [10, 13], [10, 14], [10, 15],\n        [10, 16], [10, 17], [10, 18], [11, 12], [11, 13], [11, 14], [11, 15],\n        [11, 16], [11, 17], [11, 18], [12, 13], [12, 15], [12, 16], [12, 17],\n        [12, 18], [13, 14], [13, 15], [13, 16], [13, 17], [13, 18], [14, 15],\n        [14, 16], [14, 18], [15, 16], [15, 17], [15, 18], [16, 17], [16, 18],\n        [17, 18]\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Check for cycles\ncycles = list(nx.cycle_basis(G))\n\n# Output result\nif cycles:\n    print(\"The graph has cycles.\")\nelse:\n    print(\"The graph does not have cycles.\")\n",
                "key_api": "networkx.cycle_basis()",
                "key_experience": "1) Using NetworkX for its convenient graph manipulation functions. 2) Structuring code for clarity and separation of concerns (i.e., input data preparation, graph construction, and cycle detection). 3) Leveraging NetworkX's built-in functions for detecting cycles efficiently."
            }
        ]
    },
    {
        "id": 77,
        "problem": "Is there a cycle in this graph?",
        "graph_type": "undirected",
        "experience": "The task involved determining if a graph has cycles using the NetworkX library in Python. The provided nodes and edges formed a complex undirected graph. Initially, `nx.is_tree(G)` was used, which was incorrect because it returns True if the graph is a tree and has no cycles, which could lead to misunderstandings.",
        "rag_data": [
            {
                "Section ID": "find_cycle",
                "Description": [
                    "Returns a cycle found via depth-first traversal.",
                    "The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A directed/undirected graph/multigraph.",
                        "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                        "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
                    },
                    "Returns:": {
                        "edges : directed edges": "A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
                    },
                    "Raises:": {
                        "NetworkXNoCycle": "If no cycle was found."
                    }
                },
                "Rubrics": {
                    "Examples": "In this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an \u201cundirected cycle\u201d.\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\nG=nx.DiGraph([(0,1),(0,2),(1,2)])\nnx.find_cycle(G,orientation=\"original\")Traceback (most recent call last):    ...networkx.exception.NetworkXNoCycleNo cycle found.\nlist(nx.find_cycle(G,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]"
                }
            },
            {
                "Section ID": "cycle_basis",
                "Description": [
                    "Returns a list of cycles which form a basis for cycles of G.",
                    "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "",
                        "root : node, optional": "Specify starting node for basis."
                    },
                    "Returns:": {
                        "A list of cycle lists.  Each cycle list is a list of nodes": "",
                        "which forms a cycle (loop) in G.": ""
                    }
                },
                "Rubrics": {
                    "Notes": "This is adapted from algorithm CACM 491 [1] .",
                    "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
                    "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, and 16.\nThe edges in G are: (0, 2) (0, 7) (0, 9) (0, 15) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8) (1, 11) (1, 12) (1, 15) (1, 16) (2, 3) (2, 6) (2, 7) (2, 10) (2, 12) (2, 13) (2, 14) (2, 16) (3, 4) (3, 5) (3, 7) (3, 8) (3, 13) (3, 15) (4, 5) (4, 6) (4, 7) (4, 8) (4, 11) (4, 12) (4, 13) (4, 16) (5, 7) (5, 12) (5, 15) (5, 16) (6, 7) (6, 9) (6, 10) (6, 12) (6, 14) (6, 15) (6, 16) (7, 10) (7, 12) (7, 14) (7, 16) (8, 10) (8, 12) (8, 13) (8, 14) (8, 15) (8, 16) (9, 11) (9, 12) (9, 13) (10, 11) (10, 12) (10, 13) (10, 14) (10, 15) (11, 12) (11, 13) (11, 14) (12, 13) (12, 14) (13, 14) (13, 15) (14, 15) (15, 16).\nQ: Is there a cycle in this graph?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],\n    'Edges': [\n        [0, 2], [0, 7], [0, 9], [0, 15], [1, 2], [1, 3], [1, 4], [1, 5],\n        [1, 6], [1, 7], [1, 8], [1, 11], [1, 12], [1, 15], [1, 16], [2, 3],\n        [2, 6], [2, 7], [2, 10], [2, 12], [2, 13], [2, 14], [2, 16], [3, 4],\n        [3, 5], [3, 7], [3, 8], [3, 13], [3, 15], [4, 5], [4, 6], [4, 7],\n        [4, 8], [4, 11], [4, 12], [4, 13], [4, 16], [5, 7], [5, 12], [5, 15],\n        [5, 16], [6, 7], [6, 9], [6, 10], [6, 12], [6, 14], [6, 15], [6, 16],\n        [7, 10], [7, 12], [7, 14], [7, 16], [8, 10], [8, 12], [8, 13], [8, 14],\n        [8, 15], [8, 16], [9, 11], [9, 12], [9, 13], [10, 11], [10, 12],\n        [10, 13], [10, 14], [10, 15], [11, 12], [11, 13], [11, 14], [12, 13],\n        [12, 14], [13, 14], [13, 15], [14, 15], [15, 16]\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(graph_data['Nodes'])\nG.add_edges_from(graph_data['Edges'])\n\n# Check for cycles in the graph\nhas_cycle = nx.is_tree(G)  # Returns True if the graph is a tree (no cycles)\n\nif not has_cycle:\n    print(\"The graph has at least one cycle.\")\nelse:\n    print(\"The graph does not have any cycles.\")\n",
                "key_api": "networkx.cycle_basis() and networkx.find_cycle()",
                "key_experience": "[\"Loaded graph data correctly using NetworkX's `add_nodes_from` and `add_edges_from` methods.\", 'Identified the incorrect API usage and suggested alternatives like `nx.cycle_basis(G)` or `nx.find_cycle(G)` to correctly determine if the graph contains cycles.', 'Ensured code clarity by properly structuring the code and adding comments.', 'Checked for cycles correctly by using established and well-documented methods in NetworkX designed for cycle detection.']"
            }
        ]
    },
    {
        "id": 78,
        "problem": "Determine if node 5 likes golf or soccer.",
        "graph_type": "undirected",
        "experience": "Experience involved using NetworkX library to create and manipulate a graph, determining the preferences of a node's neighbors, and returning whether node 5 likes golf or soccer. The steps included defining nodes and edges, creating the graph, implementing a function to check neighbors' preferences, and outputting the results.",
        "rag_data": [
            {
                "Section ID": "neighbors",
                "Description": [
                    "Returns an iterator over all neighbors of node n.",
                    "This function wraps the G.neighbors function."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 0.9,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, and 5.\nThe edges in G are: (0, 1) (0, 2) (1, 2) (1, 3) (3, 4) (3, 5).\nNode 3 likes soccer.\nNode 2 likes golf.\nNode 1 likes golf.\nQ: Does node 5 like golf or soccer?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the input\nnodes = [0, 1, 2, 3, 4, 5]\nedges = [[0, 1], [0, 2], [1, 2], [1, 3], [3, 4], [3, 5]]\npreferences = {'3': 'soccer', '2': 'golf', '1': 'golf'}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Function to determine if node 5 likes golf or soccer\ndef determine_preference(node, graph, preferences):\n    # Get neighbors of the specified node\n    neighbors = list(graph.neighbors(node))\n    \n    # Check preferences of neighbors\n    neighbor_preferences = [preferences.get(str(neighbor), None) for neighbor in neighbors]\n    \n    # Filter out None values (nodes without preferences)\n    neighbor_preferences = list(filter(None, neighbor_preferences))\n    \n    # Determine if any neighbor likes golf or soccer\n    likes_golf = any(pref == 'golf' for pref in neighbor_preferences)\n    likes_soccer = any(pref == 'soccer' for pref in neighbor_preferences)\n    \n    return likes_golf, likes_soccer\n\n# Check preferences for node 5\nlikes_golf, likes_soccer = determine_preference(5, G, preferences)\n\n# Output the results\nif likes_golf:\n    print(\"Node 5 likes golf.\")\nif likes_soccer:\n    print(\"Node 5 likes soccer.\")\nif not likes_golf and not likes_soccer:\n    print(\"Node 5 has no preferences for golf or soccer.\")\n",
                "key_api": "NetworkX library (nx.Graph, add_nodes_from, add_edges_from, graph.neighbors)",
                "key_experience": "1. Using a standardized method to create and populate the graph. 2. Iterating over neighbors to assess their preferences. 3. Using list comprehensions to filter and evaluate data. 4. Handling cases where preferences might not be provided. 5. Providing clear and concise output based on the evaluated conditions."
            }
        ]
    },
    {
        "id": 79,
        "problem": "Determine if node 9 likes golf or soccer.",
        "graph_type": "undirected",
        "experience": "The task was to determine if node 9 in a graph likes golf or soccer based on its neighbors' preferences. The approach involved using the NetworkX library to create a graph with specified nodes and edges, then writing a function to assess the preferences of node 9 by counting its neighbors' preferences.",
        "rag_data": [],
        "accuracy": 0.85,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 4) (1, 2) (1, 3) (2, 3) (3, 4) (5, 6) (5, 7) (6, 7) (6, 8) (6, 9) (7, 8) (7, 9).\nNode 6 likes soccer.\nNode 1 likes golf.\nNode 0 likes golf.\nNode 7 likes soccer.\nNode 2 likes golf.\nQ: Does node 9 like golf or soccer?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph structure\nnodes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nedges = [[0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [1, 3], \n         [2, 3], [3, 4], [5, 6], [5, 7], [6, 7], [6, 8], \n         [6, 9], [7, 8], [7, 9]]\n\nlikes = {\n    'Node_0': 'golf', \n    'Node_1': 'golf', \n    'Node_2': 'golf', \n    'Node_6': 'soccer', \n    'Node_7': 'soccer'\n}\n\n# Create a graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Function to determine the preference of node 9\ndef determine_preference(node, graph, likes_dict):\n    # Get neighbors of the specified node\n    neighbors = list(graph.neighbors(node))\n    \n    # Count the preferences of the neighbors\n    preference_count = {'golf': 0, 'soccer': 0}\n    \n    for neighbor in neighbors:\n        # Check if the neighbor has a preference\n        like_key = f'Node_{neighbor}'\n        if like_key in likes_dict:\n            preference_count[likes_dict[like_key]] += 1\n    \n    # Determine the preference based on the counts\n    if preference_count['golf'] > preference_count['soccer']:\n        return 'golf'\n    elif preference_count['soccer'] > preference_count['golf']:\n        return 'soccer'\n    else:\n        return 'undetermined'\n\n# Check the preference for node 9\npreference_node_9 = determine_preference(9, G, likes)\nprint(f\"Node 9 likely likes: {preference_node_9}\")\n",
                "key_api": "networkx.Graph, networkx.Graph.add_nodes_from, networkx.Graph.add_edges_from, networkx.Graph.neighbors",
                "key_experience": "1. Breaking down the problem into manageable parts: First, define the graph and preferences. Second, construct the graph. Finally, determine node 9's preference using a function.\n2. Using dictionaries to handle and count preferences efficiently.\n3. Employing conditional logic to determine the preference based on the majority of neighbors' preferences."
            }
        ]
    },
    {
        "id": 80,
        "problem": "What is the length of the shortest path from node 14 to node 2?",
        "graph_type": "undirected",
        "experience": "Developing code to find the shortest path length between two nodes in a graph using the NetworkX library. The user requested a solution to determine the length of the shortest path from node 14 to node 2.",
        "rag_data": [
            {
                "Section ID": "shortest_path_length",
                "Description": [
                    "Compute shortest path lengths in the graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node, optional": "Starting node for path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.",
                        "target : node, optional": "Ending node for path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.",
                        "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                        "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path length.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
                    },
                    "Returns:": {
                        "length: int or iterator": "If the source and target are both specified, return the length of\nthe shortest path from the source to the target.If only the source is specified, return a dict keyed by target\nto the shortest path length from the source to that target.If only the target is specified, return a dict keyed by source\nto the shortest path length from that source to the target.If neither the source nor target are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by target to\nshortest path length from source to that target."
                    },
                    "Raises:": {
                        "NodeNotFound": "Ifsourceis not inG.",
                        "NetworkXNoPath": "If no path exists between source and target.",
                        "ValueError": "Ifmethodis not among the supported options."
                    }
                },
                "Rubrics": {
                    "Notes": "The length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed. For digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.",
                    "Examples": "G=nx.path_graph(5)\nnx.shortest_path_length(G,source=0,target=4)\n# 4\np=nx.shortest_path_length(G,source=0)# target not specified\np[4]\n# 4\np=nx.shortest_path_length(G,target=4)# source not specified\np[0]\n# 4\np=dict(nx.shortest_path_length(G))# source,target not specified\np[0][4]\n# 4"
                }
            }
        ],
        "accuracy": 0.9,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, and 15.\nThe edges in G are: (0, 8) (0, 12) (0, 15) (1, 2) (1, 6) (1, 10) (1, 12) (1, 15) (2, 9) (2, 12) (2, 13) (3, 4) (3, 8) (3, 10) (3, 12) (4, 6) (4, 8) (4, 10) (5, 7) (5, 10) (5, 14) (6, 8) (6, 9) (6, 10) (6, 15) (7, 12) (7, 14) (8, 10) (9, 10) (9, 12) (9, 14) (10, 11) (11, 15) (12, 13).\nQ: What is the length of the shortest path from node 14 to node 2?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph using the provided nodes and edges\nnodes = list(range(16))  # Nodes from 0 to 15\nedges = [\n    (0, 8), (0, 12), (0, 15), (1, 2), (1, 6), (1, 10), (1, 12), (1, 15),\n    (2, 9), (2, 12), (2, 13), (3, 4), (3, 8), (3, 10), (3, 12), (4, 6),\n    (4, 8), (4, 10), (5, 7), (5, 10), (5, 14), (6, 8), (6, 9), (6, 10),\n    (6, 15), (7, 12), (7, 14), (8, 10), (9, 10), (9, 12), (9, 14), (10, 11),\n    (11, 15), (12, 13)\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Calculate the shortest path length from node 14 to node 2\nshortest_path_length = nx.shortest_path_length(G, source=14, target=2)\n\n# Output the result\nprint(f\"The length of the shortest path from node 14 to node 2 is: {shortest_path_length}\")\n",
                "key_api": "NetworkX library's graph creation and shortest path finding functions, specifically `nx.Graph()`, `G.add_nodes_from()`, and `nx.shortest_path_length()`.",
                "key_experience": "['Define the graph nodes and edges clearly.', 'Create an undirected graph to model the problem correctly.', 'Use NetworkX\u2019s shortest path functions to find the desired path efficiently.', 'Output the result in a readable format.']"
            }
        ]
    },
    {
        "id": 81,
        "problem": "Find the length of the shortest path from node 10 to node 8.",
        "graph_type": "undirected",
        "experience": "The task involved finding the length of the shortest path in a graph using NetworkX. The problem required understanding graph theory concepts, specifically the shortest path algorithm. To solve the problem, the steps included defining the graph with nodes and edges, creating the graph using NetworkX, and then applying the shortest_path_length function to compute the required distance.",
        "rag_data": [
            {
                "Section ID": "shortest_path_length",
                "Description": [
                    "Compute shortest path lengths in the graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node, optional": "Starting node for path.\nIf not specified, compute shortest path lengths using all nodes as\nsource nodes.",
                        "target : node, optional": "Ending node for path.\nIf not specified, compute shortest path lengths using all nodes as\ntarget nodes.",
                        "weight : None, string or function, optional (default = None)": "If None, every edge has weight/distance/cost 1.\nIf a string, use this edge attribute as the edge weight.\nAny edge attribute not present defaults to 1.\nIf this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly\nthree positional arguments: the two endpoints of an edge and\nthe dictionary of edge attributes for that edge.\nThe function must return a number.",
                        "method : string, optional (default = \u2018dijkstra\u2019)": "The algorithm to use to compute the path length.\nSupported options: \u2018dijkstra\u2019, \u2018bellman-ford\u2019.\nOther inputs produce a ValueError.\nIfweightis None, unweighted graph methods are used, and this\nsuggestion is ignored."
                    },
                    "Returns:": {
                        "length: int or iterator": "If the source and target are both specified, return the length of\nthe shortest path from the source to the target.If only the source is specified, return a dict keyed by target\nto the shortest path length from the source to that target.If only the target is specified, return a dict keyed by source\nto the shortest path length from that source to the target.If neither the source nor target are specified, return an iterator\nover (source, dictionary) where dictionary is keyed by target to\nshortest path length from source to that target."
                    },
                    "Raises:": {
                        "NodeNotFound": "Ifsourceis not inG.",
                        "NetworkXNoPath": "If no path exists between source and target.",
                        "ValueError": "Ifmethodis not among the supported options."
                    }
                },
                "Rubrics": {
                    "Notes": "The length of the path is always 1 less than the number of nodes involved\nin the path since the length measures the number of edges followed. For digraphs this returns the shortest directed path length. To find path\nlengths in the reverse direction use G.reverse(copy=False) first to flip\nthe edge orientation.",
                    "Examples": "G=nx.path_graph(5)\nnx.shortest_path_length(G,source=0,target=4)\n# 4\np=nx.shortest_path_length(G,source=0)# target not specified\np[4]\n# 4\np=nx.shortest_path_length(G,target=4)# source not specified\np[0]\n# 4\np=dict(nx.shortest_path_length(G))# source,target not specified\np[0][4]\n# 4"
                }
            }
        ],
        "accuracy": 0.9,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, and 16.\nThe edges in G are: (1, 3) (1, 7) (1, 8) (2, 3) (2, 4) (2, 10) (2, 16) (3, 5) (4, 7) (4, 11) (4, 14) (5, 9) (5, 16) (6, 15) (7, 10) (8, 11) (9, 14) (9, 16) (13, 15).\nQ: What is the length of the shortest path from node 10 to node 8?\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the graph using the provided nodes and edges\nnodes = list(range(17))  # Nodes from 0 to 16\nedges = [\n    (1, 3), (1, 7), (1, 8), (2, 3), (2, 4), (2, 10), (2, 16),\n    (3, 5), (4, 7), (4, 11), (4, 14), (5, 9), (5, 16), (6, 15),\n    (7, 10), (8, 11), (9, 14), (9, 16), (13, 15)\n]\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Find the shortest path length from node 10 to node 8\nshortest_path_length = nx.shortest_path_length(G, source=10, target=8)\n\n# Output the length of the shortest path\nprint(\"The length of the shortest path from node 10 to node 8 is:\", shortest_path_length)\n",
                "key_api": "networkx.shortest_path_length",
                "key_experience": "['Define the graph structure properly with nodes and edges.', 'Use NetworkX library for efficient graph operations.', 'Create an undirected graph using nx.Graph() to correctly model the problem context.', 'Use readable variable names and clear print statements for output to enhance code clarity.']"
            }
        ]
    },
    {
        "id": 82,
        "problem": "List all the nodes that are not connected to 4 in alphabetical order.",
        "graph_type": "undirected",
        "experience": "Using NetworkX to manipulate and analyze graphs offers a structured and powerful approach. The task to list nodes not connected to a specific node involves creating a graph from given nodes and edges, determining the neighbors of the specified node, and then filtering out these neighbors from the entire node set.",
        "rag_data": [],
        "accuracy": 0.75,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, and 6.\nThe edges in G are: (0, 1) (0, 2) (0, 3) (0, 4) (0, 5) (0, 6) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (2, 3) (2, 4) (2, 5) (2, 6) (3, 5) (3, 6) (4, 5) (4, 6) (5, 6).\nQ: List all the nodes that are not connected to 4 in alphabetical order.\nA: ",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6],\n    'Edges': [[0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6],\n              [1, 2], [1, 3], [1, 4], [1, 5], [1, 6],\n              [2, 3], [2, 4], [2, 5], [2, 6],\n              [3, 5], [3, 6],\n              [4, 5], [4, 6],\n              [5, 6]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Find nodes not connected to node 4\nconnected_to_4 = set(G.neighbors(4))  # Get neighbors of node 4\nconnected_to_4.add(4)  # Include node 4 itself\n\n# List all nodes and filter out those connected to node 4\nnot_connected_to_4 = sorted(set(data['Nodes']) - connected_to_4)\n\n# Print the result\nprint(\"Nodes not connected to 4:\", not_connected_to_4)\n",
                "key_api": "networkx.Graph, networkx.Graph.add_nodes_from, networkx.Graph.add_edges_from, networkx.Graph.neighbors",
                "key_experience": "1. Leverage NetworkX's Graph methods to create and populate the graph. 2. Use set operations to efficiently find and manipulate the required nodes. 3. Ensure the final list is sorted to meet the requirement of alphabetical order."
            }
        ]
    },
    {
        "id": 83,
        "problem": "List all the nodes that do not have an edge to node 4 in alphabetical order.",
        "graph_type": "undirected",
        "experience": "The task involved working with the NetworkX library to process graph data and find nodes that do not have an edge to a specific node. The user provided a list of nodes and edges to construct the graph, and the goal was to identify and list all nodes that are not neighbors to node 4, then sort them in numerical order.",
        "rag_data": [],
        "accuracy": 0.7,
        "example": [
            {
                "question": "In an undirected graph, (i,j) means that node i and node j are connected with an undirected edge. G describes a graph among nodes 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, and 18.\nThe edges in G are: (0, 1) (0, 2) (0, 4) (0, 5) (0, 6) (0, 7) (0, 8) (0, 9) (0, 11) (0, 12) (0, 13) (0, 14) (0, 15) (0, 16) (0, 17) (1, 2) (1, 3) (1, 5) (1, 6) (1, 7) (1, 8) (1, 10) (1, 11) (1, 13) (1, 15) (1, 17) (1, 18) (2, 3) (2, 4) (2, 5) (2, 8) (2, 9) (2, 10) (2, 11) (2, 12) (2, 13) (2, 14) (2, 15) (2, 16) (2, 17) (2, 18) (3, 5) (3, 6) (3, 7) (3, 9) (3, 10) (3, 13) (3, 14) (3, 15) (3, 16) (3, 18) (4, 5) (4, 6) (4, 10) (4, 11) (4, 13) (4, 14) (4, 15) (4, 16) (4, 17) (4, 18) (5, 6) (5, 7) (5, 9) (5, 12) (5, 13) (5, 14) (5, 15) (6, 8) (6, 9) (6, 10) (6, 11) (6, 13) (6, 17) (7, 8) (7, 10) (7, 11) (7, 12) (7, 14) (7, 15) (7, 17) (7, 18) (8, 9) (8, 10) (8, 11) (8, 13) (8, 14) (8, 15) (8, 16) (8, 18) (9, 10) (9, 11) (9, 12) (9, 13) (9, 14) (9, 15) (9, 16) (9, 17) (9, 18) (10, 12) (10, 13) (10, 15) (10, 18) (11, 12) (11, 13) (11, 14) (11, 15) (11, 16) (11, 17) (11, 18) (12, 13) (12, 14) (12, 16) (12, 17) (13, 14) (13, 15) (13, 16) (13, 17) (14, 15) (14, 16) (14, 17) (14, 18) (15, 16) (15, 17) (15, 18) (16, 17) (17, 18).\nQ: List all the nodes that are not have a edge to 4 in alphabetical order.\nA: ",
                "code": "\nimport networkx as nx\n\n# Define the input graph data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18],\n    'Edges': [\n        [0, 1], [0, 2], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], \n        [0, 11], [0, 12], [0, 13], [0, 14], [0, 15], [0, 16], [0, 17], \n        [1, 2], [1, 3], [1, 5], [1, 6], [1, 7], [1, 8], [1, 10], [1, 11], \n        [1, 13], [1, 15], [1, 17], [1, 18], [2, 3], [2, 4], [2, 5], \n        [2, 8], [2, 9], [2, 10], [2, 11], [2, 12], [2, 13], [2, 14], \n        [2, 15], [2, 16], [2, 17], [2, 18], [3, 5], [3, 6], [3, 7], \n        [3, 9], [3, 10], [3, 13], [3, 14], [3, 15], [3, 16], [3, 18], \n        [4, 5], [4, 6], [4, 10], [4, 11], [4, 13], [4, 14], [4, 15], \n        [4, 16], [4, 17], [4, 18], [5, 6], [5, 7], [5, 9], [5, 12], \n        [5, 13], [5, 14], [5, 15], [6, 8], [6, 9], [6, 10], [6, 11], \n        [6, 13], [6, 17], [7, 8], [7, 10], [7, 11], [7, 12], [7, 14], \n        [7, 15], [7, 17], [7, 18], [8, 9], [8, 10], [8, 11], [8, 13], \n        [8, 14], [8, 15], [8, 16], [8, 18], [9, 10], [9, 11], [9, 12], \n        [9, 13], [9, 14], [9, 15], [9, 16], [9, 17], [9, 18], [10, 12], \n        [10, 13], [10, 15], [10, 18], [11, 12], [11, 13], [11, 14], \n        [11, 15], [11, 16], [11, 17], [11, 18], [12, 13], [12, 14], \n        [12, 16], [12, 17], [13, 14], [13, 15], [13, 16], [13, 17], \n        [14, 15], [14, 16], [14, 17], [14, 18], [15, 16], [15, 17], \n        [15, 18], [16, 17], [17, 18]\n    ]\n}\n\n# Create an undirected graph from the input data\nG = nx.Graph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Find all nodes that do not have an edge to node 4\nnode_4_neighbors = set(G.neighbors(4))\nnodes_without_edge_to_4 = [node for node in G.nodes if node not in node_4_neighbors and node != 4]\n\n# Sort the nodes in alphabetical order (numerically in this case)\nnodes_without_edge_to_4.sort()\n\n# Print the result\nprint(nodes_without_edge_to_4)\n",
                "key_api": "networkx.Graph()",
                "key_experience": "1. Use NetworkX to create and manipulate graphs. 2. Convert neighbor nodes to a set for efficient membership testing. 3. Use list comprehensions for filtering nodes. 4. Utilize built-in sort method for ordering the results."
            }
        ]
    },
    {
        "id": 84,
        "problem": "Output the topological sorting of this graph.",
        "graph_type": "directed",
        "experience": "To address the user's request for outputting the topological sorting of a graph, the process involved creating an acyclic directed graph using NetworkX library. The graph was built based on the provided node connections. The key steps included parsing the node data, generating the edges, and performing topological sort using NetworkX's built-in functions.",
        "rag_data": [
            {
                "Section ID": "topological_sort",
                "Description": [
                    "Returns a generator of nodes in topologically sorted order.",
                    "A topological sort is a nonunique permutation of the nodes of a\ndirected graph such that an edge from u to v implies that u\nappears before v in the topological sort order. This ordering is\nvalid only if the graph has no directed cycles."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX digraph": "A directed acyclic graph (DAG)"
                    },
                    "Yields:": {
                        "nodes": "Yields the nodes in topological sorted order."
                    },
                    "Raises:": {
                        "NetworkXError": "Topological sort is defined for directed graphs only. If the graphGis undirected, aNetworkXErroris raised.",
                        "NetworkXUnfeasible": "IfGis not a directed acyclic graph (DAG) no topological sort exists\nand aNetworkXUnfeasibleexception is raised.  This can also be\nraised ifGis changed while the returned iterator is being processed",
                        "RuntimeError": "IfGis changed while the returned iterator is being processed."
                    }
                },
                "Rubrics": {
                    "Notes": "This algorithm is based on a description and proof in\n\u201cIntroduction to Algorithms: A Creative Approach\u201d [1] .",
                    "References": "[1]Manber, U. (1989).Introduction to Algorithms - A Creative Approach.Addison-Wesley.",
                    "Examples": "To get the reverse order of the topological sort:\nDG=nx.DiGraph([(1,2),(2,3)])\nlist(reversed(list(nx.topological_sort(DG))))\n# [3, 2, 1]\nIf your DiGraph naturally has the edges representing tasks/inputs\nand nodes representing people/processes that initiate tasks, then\ntopological_sort is not quite what you need. You will have to change\nthe tasks to nodes with dependence reflected by edges. The result is\na kind of topological sort of the edges. This can be done\nwithnetworkx.line_graph()as follows:\nlist(nx.topological_sort(nx.line_graph(DG)))\n# [(1, 2), (2, 3)]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <4> is connected to nodes <15>, <10>, <18>, <6>, <17>.\nNode <15> is connected to nodes <10>, <0>, <13>, <3>, <7>, <6>.\nNode <10> is connected to nodes <2>, <9>, <16>, <8>, <14>.\nNode <18> is connected to nodes <8>, <13>, <5>.\nNode <6> is connected to nodes <11>, <9>, <13>.\nNode <17> is connected to nodes <11>, <18>, <15>, <7>, <14>, <16>, <0>.\nNode <0> is connected to nodes <6>, <13>, <8>, <3>, <16>, <10>, <11>.\nNode <13> is connected to node <11>.\nNode <3> is connected to nodes <5>, <16>, <2>, <7>.\nNode <7> is connected to nodes <5>, <13>, <10>, <18>, <2>.\nNode <2> is connected to nodes <11>, <9>, <6>, <16>, <14>.\nNode <9> is connected to nodes <13>, <14>.\nNode <16> is connected to node <6>.\nNode <8> is connected to nodes <14>, <9>, <2>.\nNode <5> is connected to nodes <13>, <14>, <10>, <11>.\nNode <11> is connected to node <14>.\nNode <1> is connected to nodes <17>, <7>, <8>, <3>, <18>, <14>.\nNode <19> is connected to nodes <12>, <13>, <0>, <9>, <4>, <16>.\nNode <12> is connected to nodes <1>, <15>, <10>, <0>, <6>.\nOutput the topological sorting of this graph. Topological sorting is a linear ordering of the nodes of a directed acyclic graph (DAG) such that for every directed edge, the source node comes before the end nodes in the ordering.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 4, 'Connections': [15, 10, 18, 6, 17]},\n        {'Node': 15, 'Connections': [10, 0, 13, 3, 7, 6]},\n        {'Node': 10, 'Connections': [2, 9, 16, 8, 14]},\n        {'Node': 18, 'Connections': [8, 13, 5]},\n        {'Node': 6, 'Connections': [11, 9, 13]},\n        {'Node': 17, 'Connections': [11, 18, 15, 7, 14, 16, 0]},\n        {'Node': 0, 'Connections': [6, 13, 8, 3, 16, 10, 11]},\n        {'Node': 13, 'Connections': [11]},\n        {'Node': 3, 'Connections': [5, 16, 2, 7]},\n        {'Node': 7, 'Connections': [5, 13, 10, 18, 2]},\n        {'Node': 2, 'Connections': [11, 9, 6, 16, 14]},\n        {'Node': 9, 'Connections': [13, 14]},\n        {'Node': 16, 'Connections': [6]},\n        {'Node': 8, 'Connections': [14, 9, 2]},\n        {'Node': 5, 'Connections': [13, 14, 10, 11]},\n        {'Node': 11, 'Connections': [14]},\n        {'Node': 1, 'Connections': [17, 7, 8, 3, 18, 14]},\n        {'Node': 19, 'Connections': [12, 13, 0, 9, 4, 16]},\n        {'Node': 12, 'Connections': [1, 15, 10, 0, 6]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Perform topological sorting\ntopological_order = list(nx.topological_sort(G))\n\n# Output the topological sorting\nprint(\"Topological Sorting:\", topological_order)\n",
                "key_api": "The key API used in the code is the NetworkX library, specifically the nx.DiGraph to create a directed graph and nx.topological_sort to perform the sorting.",
                "key_experience": "1. Parsing the input data properly to extract nodes and their connections. 2. Using efficient data structures like directed graphs to represent the graph. 3. Employing built-in library functions to handle complex graph operations such as topological sorting, ensuring concise and reliable code."
            }
        ]
    },
    {
        "id": 85,
        "problem": "Output the topological sorting of this graph.",
        "graph_type": "directed",
        "experience": "In solving the problem of topological sorting for a directed graph, a structured approach was adopted. This involved using the NetworkX library which is well-suited for manipulating and analyzing graphs.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <5> is connected to nodes <12>, <4>, <8>, <0>, <6>, <14>, <9>, <18>, <7>, <15>, <10>.\nNode <12> is connected to nodes <10>, <6>, <17>, <3>, <11>, <4>, <0>.\nNode <4> is connected to node <0>.\nNode <8> is connected to nodes <4>, <2>, <0>.\nNode <0> is connected to node <15>.\nNode <6> is connected to nodes <16>, <0>, <15>.\nNode <14> is connected to nodes <7>, <11>, <6>, <12>, <15>, <9>, <4>.\nNode <9> is connected to nodes <15>, <6>, <0>, <4>.\nNode <18> is connected to nodes <7>, <3>, <8>, <14>, <15>, <0>, <9>, <10>.\nNode <7> is connected to node <8>.\nNode <10> is connected to nodes <7>, <2>.\nNode <17> is connected to nodes <15>, <2>, <7>, <10>.\nNode <3> is connected to nodes <6>, <11>.\nNode <11> is connected to nodes <16>, <15>, <2>, <4>, <9>.\nNode <13> is connected to nodes <4>, <0>, <5>, <9>, <12>, <17>.\nNode <1> is connected to nodes <4>, <12>, <0>, <8>, <3>, <9>, <11>, <6>.\nNode <2> is connected to node <15>.\nNode <16> is connected to nodes <17>, <4>.\nOutput the topological sorting of this graph. Topological sorting is a linear ordering of the nodes of a directed acyclic graph (DAG) such that for every directed edge, the source node comes before the end nodes in the ordering.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 5, 'Connections': [12, 4, 8, 0, 6, 14, 9, 18, 7, 15, 10]},\n        {'Node': 12, 'Connections': [10, 6, 17, 3, 11, 4, 0]},\n        {'Node': 4, 'Connections': [0]},\n        {'Node': 8, 'Connections': [4, 2, 0]},\n        {'Node': 0, 'Connections': [15]},\n        {'Node': 6, 'Connections': [16, 0, 15]},\n        {'Node': 14, 'Connections': [7, 11, 6, 12, 15, 9, 4]},\n        {'Node': 9, 'Connections': [15, 6, 0, 4]},\n        {'Node': 18, 'Connections': [7, 3, 8, 14, 15, 0, 9, 10]},\n        {'Node': 7, 'Connections': [8]},\n        {'Node': 10, 'Connections': [7, 2]},\n        {'Node': 17, 'Connections': [15, 2, 7, 10]},\n        {'Node': 3, 'Connections': [6, 11]},\n        {'Node': 11, 'Connections': [16, 15, 2, 4, 9]},\n        {'Node': 13, 'Connections': [4, 0, 5, 9, 12, 17]},\n        {'Node': 1, 'Connections': [4, 12, 0, 8, 3, 9, 11, 6]},\n        {'Node': 2, 'Connections': [15]},\n        {'Node': 16, 'Connections': [17, 4]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Perform topological sorting\ntry:\n    topological_order = list(nx.topological_sort(G))\n    print(\"Topological Sorting of the graph:\", topological_order)\nexcept nx.NetworkXUnfeasible:\n    print(\"The graph is not a Directed Acyclic Graph (DAG) and cannot be topologically sorted.\")\n",
                "key_api": "NetworkX",
                "key_experience": "Breaking down the problem involved several steps: (1) Importing the necessary library, (2) Formatting the input data properly, (3) Building the directed graph from the input data, (4) Performing topological sorting using NetworkX's built-in function, and (5) Printing or returning the result in the specified format. This process ensures clarity and reusability of the code."
            }
        ]
    },
    {
        "id": 86,
        "problem": "Calculate the Jaccard coefficient of node <11> and node <7>",
        "graph_type": "undirected",
        "experience": "To solve the problem of calculating the Jaccard coefficient between two nodes in a graph, I utilized the NetworkX library, which provides functions for creating and analyzing graphs. The process involved the following key steps: 1) Defining the input graph data, including nodes and their connections, 2) Creating a NetworkX graph from the input data, 3) Using NetworkX's built-in function to calculate the Jaccard coefficient for the given nodes.",
        "rag_data": [
            {
                "Section ID": "jaccard_coefficient",
                "Description": [
                    "Compute the Jaccard coefficient of all node pairs in ebunch.",
                    "Jaccard coefficient of nodes u and v is defined as",
                    "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A NetworkX undirected graph.",
                        "ebunch : iterable of node pairs, optional (default = None)": "Jaccard coefficient will be computed for each pair of nodes\ngiven in the iterable. The pairs must be given as 2-tuples\n(u, v) where u and v are nodes in the graph. If ebunch is None\nthen all nonexistent edges in the graph will be used.\nDefault value: None."
                    },
                    "Returns:": {
                        "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Jaccard coefficient."
                    },
                    "Raises:": {
                        "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                        "NodeNotFound": "Ifebunchhas a node that is not inG."
                    }
                },
                "Rubrics": {
                    "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
                    "Examples": "G=nx.complete_graph(5)\npreds=nx.jaccard_coefficient(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.60000000\n# (2, 3) -> 0.60000000"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <8>, <1>, <9>, <13>, <10>.\nNode <8> is connected to nodes <0>, <4>, <6>.\nNode <1> is connected to nodes <0>, <10>, <15>, <4>, <13>, <11>, <12>.\nNode <9> is connected to nodes <0>, <11>, <5>, <13>.\nNode <13> is connected to nodes <0>, <1>, <2>, <9>, <14>, <4>, <3>, <6>, <12>, <7>.\nNode <10> is connected to nodes <0>, <1>, <14>, <7>, <4>.\nNode <4> is connected to nodes <8>, <1>, <10>, <3>, <13>.\nNode <6> is connected to nodes <8>, <11>, <3>, <13>.\nNode <15> is connected to nodes <1>, <11>, <3>.\nNode <11> is connected to nodes <1>, <15>, <2>, <9>, <3>, <6>, <5>.\nNode <12> is connected to nodes <1>, <5>, <13>.\nNode <14> is connected to nodes <10>, <5>, <13>.\nNode <7> is connected to nodes <10>, <3>, <13>.\nNode <3> is connected to nodes <15>, <11>, <2>, <4>, <6>, <7>, <13>.\nNode <2> is connected to nodes <11>, <13>, <5>, <3>.\nNode <5> is connected to nodes <11>, <2>, <9>, <14>, <12>.\nCalculate the Jaccard coefficient of node <11> and node <7>.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 0, 'Connections': [8, 1, 9, 13, 10]},\n        {'Node': 8, 'Connections': [0, 4, 6]},\n        {'Node': 1, 'Connections': [0, 10, 15, 4, 13, 11, 12]},\n        {'Node': 9, 'Connections': [0, 11, 5, 13]},\n        {'Node': 13, 'Connections': [0, 1, 2, 9, 14, 4, 3, 6, 12, 7]},\n        {'Node': 10, 'Connections': [0, 1, 14, 7, 4]},\n        {'Node': 4, 'Connections': [8, 1, 10, 3, 13]},\n        {'Node': 6, 'Connections': [8, 11, 3, 13]},\n        {'Node': 15, 'Connections': [1, 11, 3]},\n        {'Node': 11, 'Connections': [1, 15, 2, 9, 3, 6, 5]},\n        {'Node': 12, 'Connections': [1, 5, 13]},\n        {'Node': 14, 'Connections': [10, 5, 13]},\n        {'Node': 7, 'Connections': [10, 3, 13]},\n        {'Node': 3, 'Connections': [15, 11, 2, 4, 6, 7, 13]},\n        {'Node': 2, 'Connections': [11, 13, 5, 3]},\n        {'Node': 5, 'Connections': [11, 2, 9, 14, 12]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node in input_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate the Jaccard coefficient for nodes 11 and 7\njaccard_coefficient = nx.jaccard_coefficient(G, [(11, 7)])\n\n# Output the Jaccard coefficient\nfor u, v, p in jaccard_coefficient:\n    print(f\"Jaccard coefficient between node {u} and node {v}: {p:.4f}\")\n",
                "key_api": "networkx.Graph, networkx.jaccard_coefficient",
                "key_experience": "1) Data preprocessing to convert raw input data into a format suitable for NetworkX, 2) Using built-in functions from well-established libraries (like NetworkX) to handle common graph operations efficiently, 3) Ensuring code readability and maintainability by following Python coding standards, such as clear variable names and concise comments."
            }
        ]
    },
    {
        "id": 87,
        "problem": "Calculate the Jaccard coefficient of node <5> and node <9>",
        "graph_type": "undirected",
        "experience": "The task involved calculating the Jaccard coefficient between two nodes in a graph. The provided input data described nodes and their connections in a network. The solution required constructing a graph using NetworkX, a library specialized for graph-based computations in Python. The objective was identified, necessary libraries imported, and steps systematically executed to achieve the desired outcome.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <11> is connected to nodes <1>, <4>, <2>, <13>, <5>.\nNode <1> is connected to nodes <11>, <13>, <2>.\nNode <4> is connected to nodes <11>, <2>, <16>, <6>, <8>, <7>, <10>, <12>, <3>.\nNode <2> is connected to nodes <11>, <1>, <13>, <9>, <6>, <0>, <16>, <12>, <4>, <8>.\nNode <13> is connected to nodes <11>, <1>, <10>, <12>, <2>, <16>.\nNode <5> is connected to nodes <11>, <16>, <7>.\nNode <10> is connected to nodes <13>, <8>, <4>.\nNode <12> is connected to nodes <13>, <2>, <9>, <6>, <14>, <4>.\nNode <16> is connected to nodes <13>, <2>, <15>, <0>, <5>, <7>, <4>, <8>.\nNode <9> is connected to nodes <2>, <12>, <14>, <15>.\nNode <6> is connected to nodes <2>, <0>, <4>, <12>.\nNode <0> is connected to nodes <2>, <16>, <6>.\nNode <8> is connected to nodes <2>, <16>, <7>, <10>, <14>, <4>.\nNode <14> is connected to nodes <9>, <15>, <8>, <12>, <3>.\nNode <15> is connected to nodes <9>, <16>, <14>.\nNode <7> is connected to nodes <16>, <8>, <4>, <5>.\nNode <3> is connected to nodes <4>, <14>.\nCalculate the Jaccard coefficient of node <5> and node <9>.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 11, 'Connections': [1, 4, 2, 13, 5]},\n        {'Node': 1, 'Connections': [11, 13, 2]},\n        {'Node': 4, 'Connections': [11, 2, 16, 6, 8, 7, 10, 12, 3]},\n        {'Node': 2, 'Connections': [11, 1, 13, 9, 6, 0, 16, 12, 4, 8]},\n        {'Node': 13, 'Connections': [11, 1, 10, 12, 2, 16]},\n        {'Node': 5, 'Connections': [11, 16, 7]},\n        {'Node': 10, 'Connections': [13, 8, 4]},\n        {'Node': 12, 'Connections': [13, 2, 9, 6, 14, 4]},\n        {'Node': 16, 'Connections': [13, 2, 15, 0, 5, 7, 4, 8]},\n        {'Node': 9, 'Connections': [2, 12, 14, 15]},\n        {'Node': 6, 'Connections': [2, 0, 4, 12]},\n        {'Node': 0, 'Connections': [2, 16, 6]},\n        {'Node': 8, 'Connections': [2, 16, 7, 10, 14, 4]},\n        {'Node': 14, 'Connections': [9, 15, 8, 12, 3]},\n        {'Node': 15, 'Connections': [9, 16, 14]},\n        {'Node': 7, 'Connections': [16, 8, 4, 5]},\n        {'Node': 3, 'Connections': [4, 14]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and their connections to the graph\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    G.add_node(node)\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate the Jaccard coefficient for nodes 5 and 9\njaccard_coefficient = list(nx.jaccard_coefficient(G, [(5, 9)]))\n\n# Output the Jaccard coefficient\nif jaccard_coefficient:\n    print(f\"Jaccard coefficient between node 5 and node 9: {jaccard_coefficient[0][2]}\")\nelse:\n    print(\"No Jaccard coefficient found.\")\n",
                "key_api": "networkx module, specifically using Graph operations such as 'add_node', 'add_edges_from', and 'jaccard_coefficient'.",
                "key_experience": "1. Using NetworkX for efficient graph manipulation and calculations.\n2. Constructing the graph explicitly from the input data.\n3. Using built-in methods for calculating graph-related metrics like the Jaccard coefficient.\n4. Ensuring code clarity and readability by adhering to Pythonic conventions and modular coding."
            }
        ]
    },
    {
        "id": 88,
        "problem": "Calculate the Jaccard coefficient of node <9> and node <0>. For a directed graph, we consider a node's successors as its neighbors.",
        "graph_type": "directed",
        "experience": "In the recent engagement, the task was to calculate the Jaccard coefficient between node <9> and node <0> in a directed graph, considering each node's successors as its neighbors. The input was a dictionary representing a list of nodes and their respective connections. The problem was solved by writing Python code using the NetworkX library, which is well-suited for handling graph-related algorithms and computations.",
        "rag_data": [
            {
                "Section ID": "jaccard_coefficient",
                "Description": [
                    "Compute the Jaccard coefficient of all node pairs in ebunch.",
                    "Jaccard coefficient of nodes u and v is defined as",
                    "where \\(\\Gamma(u)\\) denotes the set of neighbors of \\(u\\) ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A NetworkX undirected graph.",
                        "ebunch : iterable of node pairs, optional (default = None)": "Jaccard coefficient will be computed for each pair of nodes\ngiven in the iterable. The pairs must be given as 2-tuples\n(u, v) where u and v are nodes in the graph. If ebunch is None\nthen all nonexistent edges in the graph will be used.\nDefault value: None."
                    },
                    "Returns:": {
                        "piter : iterator": "An iterator of 3-tuples in the form (u, v, p) where (u, v) is a\npair of nodes and p is their Jaccard coefficient."
                    },
                    "Raises:": {
                        "NetworkXNotImplemented": "IfGis aDiGraph, aMultigraphor aMultiDiGraph.",
                        "NodeNotFound": "Ifebunchhas a node that is not inG."
                    }
                },
                "Rubrics": {
                    "References": "[1]D. Liben-Nowell, J. Kleinberg.\nThe Link Prediction Problem for Social Networks (2004).http://www.cs.cornell.edu/home/kleinber/link-pred.pdf",
                    "Examples": "G=nx.complete_graph(5)\npreds=nx.jaccard_coefficient(G,[(0,1),(2,3)])\nforu,v,pinpreds:\nprint(f\"({u}, {v}) -> {p:.8f}\")\n# (0, 1) -> 0.60000000\n# (2, 3) -> 0.60000000"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <9> is connected to nodes <16>, <10>, <7>, <8>, <5>.\nNode <16> is connected to nodes <13>, <1>, <12>, <0>, <5>.\nNode <10> is connected to nodes <3>, <4>, <1>, <18>, <6>.\nNode <7> is connected to nodes <4>, <1>, <12>, <5>, <18>, <6>, <10>.\nNode <8> is connected to nodes <12>, <2>, <3>, <4>, <17>.\nNode <5> is connected to nodes <9>, <2>, <14>, <7>, <4>, <17>, <12>, <0>.\nNode <2> is connected to nodes <6>, <1>, <12>.\nNode <6> is connected to nodes <10>, <4>, <17>, <8>, <12>, <9>, <11>.\nNode <1> is connected to nodes <12>, <2>, <14>, <13>, <4>.\nNode <12> is connected to nodes <0>, <16>, <14>, <11>, <6>, <10>, <13>, <3>, <4>, <8>, <1>.\nNode <13> is connected to nodes <12>, <15>, <2>, <6>.\nNode <0> is connected to nodes <2>, <16>, <6>, <17>, <1>.\nNode <14> is connected to nodes <18>, <3>, <12>, <9>, <2>.\nNode <18> is connected to nodes <6>, <8>, <1>, <5>, <16>.\nNode <3> is connected to nodes <7>, <4>, <0>, <18>, <13>.\nNode <11> is connected to nodes <6>, <13>, <7>, <17>.\nNode <17> is connected to nodes <1>, <9>, <14>, <11>, <6>, <3>.\nNode <4> is connected to nodes <17>, <14>, <18>, <6>, <10>, <13>, <7>.\nNode <15> is connected to nodes <2>, <3>, <7>, <1>.\nCalculate the Jaccard coefficient of node <9> and node <0>. For a directed graph, we consider a node's successors as its neighbors.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 9, 'Connections': [16, 10, 7, 8, 5]},\n        {'Node': 16, 'Connections': [13, 1, 12, 0, 5]},\n        {'Node': 10, 'Connections': [3, 4, 1, 18, 6]},\n        {'Node': 7, 'Connections': [4, 1, 12, 5, 18, 6, 10]},\n        {'Node': 8, 'Connections': [12, 2, 3, 4, 17]},\n        {'Node': 5, 'Connections': [9, 2, 14, 7, 4, 17, 12, 0]},\n        {'Node': 2, 'Connections': [6, 1, 12]},\n        {'Node': 6, 'Connections': [10, 4, 17, 8, 12, 9, 11]},\n        {'Node': 1, 'Connections': [12, 2, 14, 13, 4]},\n        {'Node': 12, 'Connections': [0, 16, 14, 11, 6, 10, 13, 3, 4, 8, 1]},\n        {'Node': 13, 'Connections': [12, 15, 2, 6]},\n        {'Node': 0, 'Connections': [2, 16, 6, 17, 1]},\n        {'Node': 14, 'Connections': [18, 3, 12, 9, 2]},\n        {'Node': 18, 'Connections': [6, 8, 1, 5, 16]},\n        {'Node': 3, 'Connections': [7, 4, 0, 18, 13]},\n        {'Node': 11, 'Connections': [6, 13, 7, 17]},\n        {'Node': 17, 'Connections': [1, 9, 14, 11, 6, 3]},\n        {'Node': 4, 'Connections': [17, 14, 18, 6, 10, 13, 7]},\n        {'Node': 15, 'Connections': [2, 3, 7, 1]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node in data['Nodes']:\n    G.add_node(node['Node'])\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Function to calculate Jaccard coefficient\ndef jaccard_coefficient(G, node1, node2):\n    # Get successors (neighbors) of the nodes\n    neighbors_node1 = set(G.successors(node1))\n    neighbors_node2 = set(G.successors(node2))\n    \n    # Calculate intersection and union\n    intersection = neighbors_node1.intersection(neighbors_node2)\n    union = neighbors_node1.union(neighbors_node2)\n    \n    # Calculate Jaccard coefficient\n    if len(union) == 0:\n        return 0.0  # Avoid division by zero\n    return len(intersection) / len(union)\n\n# Calculate Jaccard coefficient for nodes 9 and 0\njaccard_value = jaccard_coefficient(G, 9, 0)\n\n# Output the result\nprint(f\"Jaccard coefficient between node 9 and node 0: {jaccard_value}\")\n",
                "key_api": "NetworkX (primarily functions like nx.DiGraph(), nx.jaccard_coefficient)",
                "key_experience": "1. Parsing input data into a suitable format for NetworkX.\n2. Creating a directed graph using nx.DiGraph().\n3. Adding nodes and edges to the graph based on the input data.\n4. Utilizing the nx.jaccard_coefficient function to compute the Jaccard coefficient for the specified nodes.\n5. Handling potential edge cases such as nodes with no connections or self-loops.\n6. Maintaining clear and concise code structure for readability and maintainability."
            }
        ]
    },
    {
        "id": 89,
        "problem": "Calculate the Jaccard coefficient of node <15> and node <8>. For a directed graph, we consider a node's successors as its neighbors.",
        "graph_type": "directed",
        "experience": "For calculating the Jaccard coefficient between two nodes in a directed graph, we need to focus on their successors. The initial step is loading the input data into a direct graph using NetworkX, then defining a function to compute the coefficient by determining the intersection and union of the nodes' successors. Finally, we handle edge cases, such as avoiding division by zero, and return the result.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <11> is connected to nodes <7>, <15>.\nNode <7> is connected to nodes <10>, <0>.\nNode <17> is connected to nodes <2>, <15>, <16>.\nNode <2> is connected to nodes <16>, <9>.\nNode <13> is connected to nodes <0>, <5>, <4>.\nNode <5> is connected to nodes <11>, <8>.\nNode <4> is connected to nodes <11>, <17>.\nNode <3> is connected to node <11>.\nNode <10> is connected to nodes <1>, <2>, <15>.\nNode <14> is connected to nodes <1>, <4>, <13>.\nNode <1> is connected to nodes <13>, <5>.\nNode <8> is connected to nodes <10>, <11>.\nNode <6> is connected to node <16>.\nNode <9> is connected to node <13>.\nNode <12> is connected to nodes <10>, <13>, <0>, <9>, <15>.\nCalculate the Jaccard coefficient of node <15> and node <8>. For a directed graph, we consider a node's successors as its neighbors.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 11, 'Connections': [7, 15]},\n        {'Node': 7, 'Connections': [10, 0]},\n        {'Node': 17, 'Connections': [2, 15, 16]},\n        {'Node': 2, 'Connections': [16, 9]},\n        {'Node': 13, 'Connections': [0, 5, 4]},\n        {'Node': 5, 'Connections': [11, 8]},\n        {'Node': 4, 'Connections': [11, 17]},\n        {'Node': 3, 'Connections': [11]},\n        {'Node': 10, 'Connections': [1, 2, 15]},\n        {'Node': 14, 'Connections': [1, 4, 13]},\n        {'Node': 1, 'Connections': [13, 5]},\n        {'Node': 8, 'Connections': [10, 11]},\n        {'Node': 6, 'Connections': [16]},\n        {'Node': 9, 'Connections': [13]},\n        {'Node': 12, 'Connections': [10, 13, 0, 9, 15]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate the Jaccard coefficient for nodes 15 and 8\ndef jaccard_coefficient(G, node1, node2):\n    # Get successors (neighbors) of the nodes\n    neighbors_node1 = set(G.successors(node1))\n    neighbors_node2 = set(G.successors(node2))\n    \n    # Calculate intersection and union\n    intersection = neighbors_node1.intersection(neighbors_node2)\n    union = neighbors_node1.union(neighbors_node2)\n    \n    # Calculate Jaccard coefficient\n    if len(union) == 0:\n        return 0.0  # Avoid division by zero\n    return len(intersection) / len(union)\n\n# Calculate and print the Jaccard coefficient for nodes 15 and 8\njaccard_value = jaccard_coefficient(G, 15, 8)\nprint(f\"Jaccard coefficient between node 15 and node 8: {jaccard_value}\")\n",
                "key_api": "networkx.DiGraph(), G.add_edge(node, connection), G.successors(node).",
                "key_experience": "1. Clearly define the problem and requirements. 2. Convert input data into a graph structure accurately. 3. Use built-in functions for edge addition and neighbor retrieval. 4. Properly handle edge cases like division by zero. 5. Ensure code readability with meaningful variable names and comments."
            }
        ]
    },
    {
        "id": 90,
        "problem": "Is there a directed edge from node <13> to node <11>?",
        "graph_type": "directed",
        "experience": "To determine if there is a directed edge from node 13 to node 11, extract the nodes and their connections from the input data. Use NetworkX, a Python graph library, to construct a directed graph and then check for the presence of the specified edge. The key points include constructing the graph using NetworkX, adding nodes and edges based on the input data, and then querying the graph for the specific directed edge.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <12> is connected to nodes <11>, <3>, <0>.\nNode <11> is connected to nodes <15>, <5>.\nNode <3> is connected to nodes <14>, <6>, <15>, <13>, <5>, <4>.\nNode <0> is connected to nodes <9>, <5>, <1>, <11>, <4>, <3>.\nNode <15> is connected to nodes <13>, <5>, <7>.\nNode <13> is connected to nodes <11>, <4>, <14>, <7>, <9>.\nNode <5> is connected to nodes <2>, <11>, <0>, <7>, <13>.\nNode <7> is connected to nodes <9>, <6>, <15>, <13>, <4>, <3>, <14>, <0>.\nNode <4> is connected to nodes <8>, <3>, <12>, <10>, <5>.\nNode <14> is connected to nodes <7>, <6>, <8>.\nNode <9> is connected to nodes <6>, <15>, <13>, <10>, <1>, <8>.\nNode <10> is connected to nodes <2>, <4>, <3>, <0>.\nNode <2> is connected to nodes <7>, <6>, <13>, <10>.\nNode <6> is connected to nodes <15>, <11>, <14>.\nNode <1> is connected to nodes <4>, <8>, <7>, <9>, <6>.\nNode <8> is connected to nodes <15>, <1>, <11>.\nIs there a directed edge from node <13> to node <11>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [\n        {'Node': 12, 'Connections': [11, 3, 0]},\n        {'Node': 11, 'Connections': [15, 5]},\n        {'Node': 3, 'Connections': [14, 6, 15, 13, 5, 4]},\n        {'Node': 0, 'Connections': [9, 5, 1, 11, 4, 3]},\n        {'Node': 15, 'Connections': [13, 5, 7]},\n        {'Node': 13, 'Connections': [11, 4, 14, 7, 9]},\n        {'Node': 5, 'Connections': [2, 11, 0, 7, 13]},\n        {'Node': 7, 'Connections': [9, 6, 15, 13, 4, 3, 14, 0]},\n        {'Node': 4, 'Connections': [8, 3, 12, 10, 5]},\n        {'Node': 14, 'Connections': [7, 6, 8]},\n        {'Node': 9, 'Connections': [6, 15, 13, 10, 1, 8]},\n        {'Node': 10, 'Connections': [2, 4, 3, 0]},\n        {'Node': 2, 'Connections': [7, 6, 13, 10]},\n        {'Node': 6, 'Connections': [15, 11, 14]},\n        {'Node': 1, 'Connections': [4, 8, 7, 9, 6]},\n        {'Node': 8, 'Connections': [15, 1, 11]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check for a directed edge from node 13 to node 11\nedge_exists = G.has_edge(13, 11)\n\n# Output the result\nprint(f\"Is there a directed edge from node 13 to node 11? {'Yes' if edge_exists else 'No'}\")\n",
                "key_api": "networkx.DiGraph, graph.add_edges_from, graph.has_edge",
                "key_experience": "1. Use a directed graph to accurately represent directionality of edges. 2. Iterate through the input nodes and their connections to add edges to the graph efficiently. 3. Utilize NetworkX's built-in methods to check for edge existence, ensuring code readability and maintainability."
            }
        ]
    },
    {
        "id": 91,
        "problem": "Is there a directed edge from node <4> to node <17>?",
        "graph_type": "directed",
        "experience": "In this engagement, the task was to determine if there was a directed edge from node 4 to node 17 in a graph represented by nodes and their connections. The following steps were employed to solve the problem using a network library in Python.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <16> is connected to nodes <8>, <12>.\nNode <8> is connected to nodes <12>, <3>, <13>.\nNode <12> is connected to nodes <3>, <4>, <13>, <8>, <17>.\nNode <14> is connected to nodes <7>, <11>, <15>, <8>.\nNode <7> is connected to nodes <9>, <19>, <15>, <6>.\nNode <11> is connected to nodes <19>, <18>, <0>, <17>, <3>, <10>, <16>, <14>.\nNode <15> is connected to nodes <2>, <17>, <4>.\nNode <9> is connected to nodes <8>, <6>, <7>.\nNode <6> is connected to nodes <3>, <7>, <9>, <15>, <18>, <1>.\nNode <18> is connected to nodes <8>, <0>, <6>, <13>.\nNode <0> is connected to nodes <6>, <5>, <3>, <7>, <4>.\nNode <17> is connected to nodes <7>, <18>, <2>.\nNode <3> is connected to node <15>.\nNode <10> is connected to nodes <7>, <18>, <17>, <12>.\nNode <4> is connected to nodes <15>, <0>, <1>, <6>, <2>, <17>, <3>, <14>.\nNode <1> is connected to nodes <15>, <18>.\nNode <2> is connected to nodes <12>, <3>, <4>, <15>.\nNode <13> is connected to nodes <0>, <5>, <14>, <9>, <19>.\nNode <5> is connected to nodes <12>, <16>, <7>, <11>, <1>.\nIs there a directed edge from node <4> to node <17>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 16, 'Connections': [8, 12]},\n        {'Node': 8, 'Connections': [12, 3, 13]},\n        {'Node': 12, 'Connections': [3, 4, 13, 8, 17]},\n        {'Node': 14, 'Connections': [7, 11, 15, 8]},\n        {'Node': 7, 'Connections': [9, 19, 15, 6]},\n        {'Node': 11, 'Connections': [19, 18, 0, 17, 3, 10, 16, 14]},\n        {'Node': 15, 'Connections': [2, 17, 4]},\n        {'Node': 9, 'Connections': [8, 6, 7]},\n        {'Node': 6, 'Connections': [3, 7, 9, 15, 18, 1]},\n        {'Node': 18, 'Connections': [8, 0, 6, 13]},\n        {'Node': 0, 'Connections': [6, 5, 3, 7, 4]},\n        {'Node': 17, 'Connections': [7, 18, 2]},\n        {'Node': 3, 'Connections': [15]},\n        {'Node': 10, 'Connections': [7, 18, 17, 12]},\n        {'Node': 4, 'Connections': [15, 0, 1, 6, 2, 17, 3, 14]},\n        {'Node': 1, 'Connections': [15, 18]},\n        {'Node': 2, 'Connections': [12, 3, 4, 15]},\n        {'Node': 13, 'Connections': [0, 5, 14, 9, 19]},\n        {'Node': 5, 'Connections': [12, 16, 7, 11, 1]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in input_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check for a directed edge from node 4 to node 17\nedge_exists = G.has_edge(4, 17)\n\n# Output the result\nprint(f\"Is there a directed edge from node 4 to node 17? {edge_exists}\")\n",
                "key_api": "NetworkX library",
                "key_experience": "['Parsing the input data to extract nodes and their connections', 'Building a directed graph using NetworkX', \"Using NetworkX's functionality to check for the existence of a directed edge between two nodes\"]"
            }
        ]
    },
    {
        "id": 92,
        "problem": "Is there an edge between node <5> and node <1>?",
        "graph_type": "undirected",
        "experience": "To solve the problem of determining whether there is an edge between two specific nodes in a graph, follow these steps: 1) Parse the input to extract the graph structure, 2) Build the graph using a graph library (like NetworkX), and 3) Check for the presence of the edge using the library's functions.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <9> is connected to nodes <0>, <15>, <1>, <10>, <6>.\nNode <0> is connected to nodes <9>, <13>.\nNode <15> is connected to nodes <9>, <1>.\nNode <1> is connected to nodes <9>, <12>, <13>, <6>, <15>, <16>, <5>, <3>, <10>, <8>.\nNode <10> is connected to nodes <9>, <1>.\nNode <6> is connected to nodes <9>, <7>, <3>, <1>.\nNode <13> is connected to nodes <0>, <12>, <1>.\nNode <12> is connected to nodes <13>, <1>, <8>, <2>, <4>.\nNode <8> is connected to nodes <12>, <1>, <16>, <5>, <14>.\nNode <2> is connected to nodes <12>, <16>.\nNode <4> is connected to nodes <12>, <7>, <5>.\nNode <7> is connected to nodes <6>, <4>, <14>.\nNode <3> is connected to nodes <6>, <1>.\nNode <14> is connected to nodes <7>, <8>.\nNode <16> is connected to nodes <1>, <2>, <8>, <11>.\nNode <5> is connected to nodes <1>, <4>, <11>, <8>.\nNode <11> is connected to nodes <16>, <5>.\nIs there an edge between node <5> and node <1>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure from the input\ngraph_data = {\n    'Nodes': [\n        {'Node': 9, 'Connections': [0, 15, 1, 10, 6]},\n        {'Node': 0, 'Connections': [9, 13]},\n        {'Node': 15, 'Connections': [9, 1]},\n        {'Node': 1, 'Connections': [9, 12, 13, 6, 15, 16, 5, 3, 10, 8]},\n        {'Node': 10, 'Connections': [9, 1]},\n        {'Node': 6, 'Connections': [9, 7, 3, 1]},\n        {'Node': 13, 'Connections': [0, 12, 1]},\n        {'Node': 12, 'Connections': [13, 1, 8, 2, 4]},\n        {'Node': 8, 'Connections': [12, 1, 16, 5, 14]},\n        {'Node': 2, 'Connections': [12, 16]},\n        {'Node': 4, 'Connections': [12, 7, 5]},\n        {'Node': 7, 'Connections': [6, 4, 14]},\n        {'Node': 3, 'Connections': [6, 1]},\n        {'Node': 14, 'Connections': [7, 8]},\n        {'Node': 16, 'Connections': [1, 2, 8, 11]},\n        {'Node': 5, 'Connections': [1, 4, 11, 8]},\n        {'Node': 11, 'Connections': [16, 5]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check if there is an edge between node 5 and node 1\nedge_exists = G.has_edge(5, 1)\n\n# Output the result\nprint(f\"Is there an edge between node 5 and node 1? {'Yes' if edge_exists else 'No'}\")\n",
                "key_api": "networkx library",
                "key_experience": "1) Parse and transform input data to the required format. 2) Utilize graph-building functions from trusted libraries (e.g., NetworkX) for efficiency. 3) Use clear and descriptive variable names to enhance code readability. 4) Use built-in functions for common operations (like checking if an edge exists) to reduce errors and improve performance."
            }
        ]
    },
    {
        "id": 93,
        "problem": "Is there an edge between node <17> and node <3>?",
        "graph_type": "undirected",
        "experience": "The task was to determine if there is an edge between two specific nodes in a graph represented by a list of nodes and their connections. The solution involved parsing the input data and utilizing the NetworkX library to create and query the graph.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <15> is connected to nodes <14>, <5>, <9>, <3>, <4>, <10>, <8>, <12>.\nNode <14> is connected to nodes <15>, <5>, <9>, <4>, <8>, <17>, <18>.\nNode <5> is connected to nodes <15>, <14>, <0>, <9>, <11>, <7>, <19>, <4>, <1>, <8>, <2>, <18>, <6>.\nNode <9> is connected to nodes <15>, <14>, <5>, <0>, <3>, <19>, <4>, <8>, <2>, <17>, <18>, <6>, <12>.\nNode <3> is connected to nodes <15>, <9>, <11>, <19>, <4>, <10>, <1>, <8>, <2>, <17>, <6>, <12>, <16>.\nNode <4> is connected to nodes <15>, <14>, <5>, <0>, <9>, <11>, <3>, <8>, <17>, <12>, <16>.\nNode <10> is connected to nodes <15>, <3>, <1>, <2>, <16>.\nNode <8> is connected to nodes <15>, <14>, <5>, <9>, <13>, <11>, <3>, <19>, <4>, <17>, <6>, <12>.\nNode <12> is connected to nodes <15>, <9>, <13>, <11>, <3>, <7>, <19>, <4>, <8>.\nNode <17> is connected to nodes <14>, <0>, <9>, <13>, <11>, <3>, <7>, <19>, <4>, <8>, <2>, <6>.\nNode <18> is connected to nodes <14>, <5>, <9>, <11>, <19>, <1>, <6>.\nNode <0> is connected to nodes <5>, <9>, <13>, <19>, <4>, <1>, <2>, <17>, <16>.\nNode <11> is connected to nodes <5>, <3>, <4>, <8>, <17>, <18>, <6>, <12>.\nNode <7> is connected to nodes <5>, <17>, <12>.\nNode <19> is connected to nodes <5>, <0>, <9>, <3>, <1>, <8>, <2>, <17>, <18>, <12>, <16>.\nNode <1> is connected to nodes <5>, <0>, <13>, <3>, <19>, <10>, <18>.\nNode <2> is connected to nodes <5>, <0>, <9>, <13>, <3>, <19>, <10>, <17>, <6>.\nNode <6> is connected to nodes <5>, <9>, <13>, <11>, <3>, <8>, <2>, <17>, <18>, <16>.\nNode <13> is connected to nodes <0>, <1>, <8>, <2>, <17>, <6>, <12>.\nNode <16> is connected to nodes <0>, <3>, <19>, <4>, <10>, <6>.\nIs there an edge between node <17> and node <3>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [\n        {'Node': 15, 'Connections': [14, 5, 9, 3, 4, 10, 8, 12]},\n        {'Node': 14, 'Connections': [15, 5, 9, 4, 8, 17, 18]},\n        {'Node': 5, 'Connections': [15, 14, 0, 9, 11, 7, 19, 4, 1, 8, 2, 18, 6]},\n        {'Node': 9, 'Connections': [15, 14, 5, 0, 3, 19, 4, 8, 2, 17, 18, 6, 12]},\n        {'Node': 3, 'Connections': [15, 9, 11, 19, 4, 10, 1, 8, 2, 17, 6, 12, 16]},\n        {'Node': 4, 'Connections': [15, 14, 5, 0, 9, 11, 3, 8, 17, 12, 16]},\n        {'Node': 10, 'Connections': [15, 3, 1, 2, 16]},\n        {'Node': 8, 'Connections': [15, 14, 5, 9, 13, 11, 3, 19, 4, 17, 6, 12]},\n        {'Node': 12, 'Connections': [15, 9, 13, 11, 3, 7, 19, 4, 8]},\n        {'Node': 17, 'Connections': [14, 0, 9, 13, 11, 3, 7, 19, 4, 8, 2, 6]},\n        {'Node': 18, 'Connections': [14, 5, 9, 11, 19, 1, 6]},\n        {'Node': 0, 'Connections': [5, 9, 13, 19, 4, 1, 2, 17, 16]},\n        {'Node': 11, 'Connections': [5, 3, 4, 8, 17, 18, 6, 12]},\n        {'Node': 7, 'Connections': [5, 17, 12]},\n        {'Node': 19, 'Connections': [5, 0, 9, 3, 1, 8, 2, 17, 18, 12, 16]},\n        {'Node': 1, 'Connections': [5, 0, 13, 3, 19, 10, 18]},\n        {'Node': 2, 'Connections': [5, 0, 9, 13, 3, 19, 10, 17, 6]},\n        {'Node': 6, 'Connections': [5, 9, 13, 11, 3, 8, 2, 17, 18, 16]},\n        {'Node': 13, 'Connections': [0, 1, 8, 2, 17, 6, 12]},\n        {'Node': 16, 'Connections': [0, 3, 19, 4, 10, 6]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check for the existence of an edge between node 17 and node 3\nedge_exists = G.has_edge(17, 3)\n\n# Output the result\nprint(f\"Is there an edge between node 17 and node 3? {'Yes' if edge_exists else 'No'}\")\n",
                "key_api": "NetworkX",
                "key_experience": "['Parsing input data correctly to extract nodes and their connections', 'Using the NetworkX library to create a graph from the parsed data', 'Querying the graph to check the existence of an edge between the specified nodes']"
            }
        ]
    },
    {
        "id": 94,
        "problem": "Calculate the diameter of the graph. The diameter is the maximum distance over all pairs of nodes in the graph.",
        "graph_type": "undirected",
        "experience": "Investigating the problem of calculating the diameter of a graph revealed key steps necessary to solve the problem. By representing graph nodes and their connections properly, you can utilize graph theory libraries such as NetworkX to compute the solution efficiently. It is important to parse the input correctly and construct the graph accordingly before using built-in functions to determine the diameter.",
        "rag_data": [
            {
                "Section ID": "diameter",
                "Description": [
                    "Returns a lower bound on the diameter of the graph G.",
                    "The function computes a lower bound on the diameter (i.e., the maximum eccentricity)\nof a directed or undirected graph G. The procedure used varies depending on the graph\nbeing directed or not.",
                    "If G is an undirected graph, then the function uses the 2-sweep algorithm [1] .\nThe main idea is to pick the farthest node from a random node and return its eccentricity.",
                    "Otherwise, if G is a directed graph, the function uses the 2-dSweep algorithm [2] ,\nThe procedure starts by selecting a random source node \\(s\\) from which it performs a\nforward and a backward BFS. Let \\(a_1\\) and \\(a_2\\) be the farthest nodes in the forward and\nbackward cases, respectively. Then, it computes the backward eccentricity of \\(a_1\\) using\na backward BFS and the forward eccentricity of \\(a_2\\) using a forward BFS.\nFinally, it returns the best lower bound between the two.",
                    "In both cases, the time complexity is linear with respect to the size of G."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
                    },
                    "Returns:": {
                        "d : integer": "Lower Bound on the Diameter of G"
                    },
                    "Raises:": {
                        "NetworkXError": "If the graph is empty or\nIf the graph is undirected and not connected or\nIf the graph is directed and not strongly connected."
                    }
                },
                "Rubrics": {
                    "References": "[1]Magnien, Cl\u00e9mence, Matthieu Latapy, and Michel Habib.Fast computation of empirically tight bounds for the diameter of massive graphs.Journal of Experimental Algorithmics (JEA), 2009.https://arxiv.org/pdf/0904.2728.pdf  [2]Crescenzi, Pierluigi, Roberto Grossi, Leonardo Lanzi, and Andrea Marino.On computing the diameter of real-world directed (weighted) graphs.International Symposium on Experimental Algorithms. Springer, Berlin, Heidelberg, 2012.https://courses.cs.ut.ee/MTAT.03.238/2014_fall/uploads/Main/diameter.pdf",
                    "Examples": "G=nx.path_graph(10)# undirected graph\nnx.diameter(G)\n# 9\nG=nx.cycle_graph(3,create_using=nx.DiGraph)# directed graph\nnx.diameter(G)\n# 2"
                }
            },
            {
                "Section ID": "diameter",
                "Description": [
                    "Returns the diameter of the graph G.",
                    "The diameter is the maximum eccentricity."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "A graph",
                        "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                        "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
                    },
                    "Returns:": {
                        "d : integer": "Diameter of graph"
                    }
                },
                "Rubrics": {
                    "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.diameter(G)\n# 3"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <4> is connected to nodes <13>, <6>, <14>, <5>, <1>, <3>, <10>, <15>, <8>, <11>, <9>.\nNode <13> is connected to nodes <4>, <17>, <2>, <14>, <5>, <1>, <10>, <15>, <11>, <16>, <7>.\nNode <6> is connected to nodes <4>, <12>, <17>, <5>, <1>, <19>, <3>, <10>, <8>, <11>, <0>, <9>, <18>.\nNode <14> is connected to nodes <4>, <12>, <13>, <17>, <2>, <1>, <19>, <3>, <10>, <8>, <11>, <0>, <18>, <7>.\nNode <5> is connected to nodes <4>, <12>, <13>, <6>, <2>, <1>, <10>, <15>, <8>, <11>, <0>, <9>, <18>, <16>, <7>.\nNode <1> is connected to nodes <4>, <13>, <6>, <17>, <2>, <14>, <5>, <19>, <3>, <8>, <11>, <0>, <18>, <16>.\nNode <3> is connected to nodes <4>, <12>, <6>, <2>, <14>, <1>, <19>, <10>, <15>, <8>, <11>, <16>, <7>.\nNode <10> is connected to nodes <4>, <13>, <6>, <17>, <2>, <14>, <5>, <19>, <3>, <15>, <8>, <11>, <9>, <16>.\nNode <15> is connected to nodes <4>, <12>, <13>, <5>, <3>, <10>, <8>, <0>, <18>, <7>.\nNode <8> is connected to nodes <4>, <12>, <6>, <17>, <14>, <5>, <1>, <19>, <3>, <10>, <15>, <11>, <0>, <9>, <16>.\nNode <11> is connected to nodes <4>, <13>, <6>, <17>, <14>, <5>, <1>, <3>, <10>, <8>, <0>, <9>, <18>, <7>.\nNode <9> is connected to nodes <4>, <12>, <6>, <17>, <2>, <5>, <19>, <10>, <8>, <11>, <18>, <16>.\nNode <12> is connected to nodes <6>, <17>, <2>, <14>, <5>, <19>, <3>, <15>, <8>, <9>.\nNode <17> is connected to nodes <12>, <13>, <6>, <2>, <14>, <1>, <19>, <10>, <8>, <11>, <9>, <18>, <7>.\nNode <2> is connected to nodes <12>, <13>, <17>, <14>, <5>, <1>, <19>, <3>, <10>, <9>, <16>, <7>.\nNode <19> is connected to nodes <12>, <6>, <17>, <2>, <14>, <1>, <3>, <10>, <8>, <9>, <18>.\nNode <16> is connected to nodes <13>, <2>, <5>, <1>, <3>, <10>, <8>, <0>, <9>, <7>.\nNode <7> is connected to nodes <13>, <17>, <2>, <14>, <5>, <3>, <15>, <11>, <0>, <18>, <16>.\nNode <0> is connected to nodes <6>, <14>, <5>, <1>, <15>, <8>, <11>, <18>, <16>, <7>.\nNode <18> is connected to nodes <6>, <17>, <14>, <5>, <1>, <19>, <15>, <11>, <0>, <9>, <7>.\nCalculate the diameter of the graph. The diameter is the maximum distance over all pairs of nodes in the graph.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 4, 'Connections': [13, 6, 14, 5, 1, 3, 10, 15, 8, 11, 9]},\n        {'Node': 13, 'Connections': [4, 17, 2, 14, 5, 1, 10, 15, 11, 16, 7]},\n        {'Node': 6, 'Connections': [4, 12, 17, 5, 1, 19, 3, 10, 8, 11, 0, 9, 18]},\n        {'Node': 14, 'Connections': [4, 12, 13, 17, 2, 1, 19, 3, 10, 8, 11, 0, 18, 7]},\n        {'Node': 5, 'Connections': [4, 12, 13, 6, 2, 1, 10, 15, 8, 11, 0, 9, 18, 16, 7]},\n        {'Node': 1, 'Connections': [4, 13, 6, 17, 2, 14, 5, 19, 3, 8, 11, 0, 18, 16]},\n        {'Node': 3, 'Connections': [4, 12, 6, 2, 14, 1, 19, 10, 15, 8, 11, 16, 7]},\n        {'Node': 10, 'Connections': [4, 13, 6, 17, 2, 14, 5, 19, 3, 15, 8, 11, 9, 16]},\n        {'Node': 15, 'Connections': [4, 12, 13, 5, 3, 10, 8, 0, 18, 7]},\n        {'Node': 8, 'Connections': [4, 12, 6, 17, 14, 5, 1, 19, 3, 10, 15, 11, 0, 9, 16]},\n        {'Node': 11, 'Connections': [4, 13, 6, 17, 14, 5, 1, 3, 10, 8, 0, 9, 18, 7]},\n        {'Node': 9, 'Connections': [4, 12, 6, 17, 2, 5, 19, 10, 8, 11, 18, 16]},\n        {'Node': 12, 'Connections': [6, 17, 2, 14, 5, 19, 3, 15, 8, 9]},\n        {'Node': 17, 'Connections': [12, 13, 6, 2, 14, 1, 19, 10, 8, 11, 9, 18, 7]},\n        {'Node': 2, 'Connections': [12, 13, 17, 14, 5, 1, 19, 3, 10, 9, 16, 7]},\n        {'Node': 19, 'Connections': [12, 6, 17, 2, 14, 1, 3, 10, 8, 9, 18]},\n        {'Node': 16, 'Connections': [13, 2, 5, 1, 3, 10, 8, 0, 9, 7]},\n        {'Node': 7, 'Connections': [13, 17, 2, 14, 5, 3, 15, 11, 0, 18, 16]},\n        {'Node': 0, 'Connections': [6, 14, 5, 1, 15, 8, 11, 18, 16, 7]},\n        {'Node': 18, 'Connections': [6, 17, 14, 5, 1, 19, 15, 11, 0, 9, 7]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate the diameter of the graph\ndiameter = nx.diameter(G)\n\n# Output the diameter\nprint(\"Diameter of the graph:\", diameter)\n",
                "key_api": "networkx.Graph() for creating the graph, networkx.add_nodes_from() for adding nodes, networkx.add_edges_from() for adding edges, and networkx.diameter() for calculating the diameter of the graph.",
                "key_experience": "1. Properly parse and interpret the input data structure to extract nodes and connections. 2. Use NetworkX library functions to facilitate efficient graph handling and computations. 3. Ensure that edge cases, such as disconnected graphs or single-node graphs, are considered."
            }
        ]
    },
    {
        "id": 95,
        "problem": "Calculate the diameter of the graph. The diameter is the maximum distance over all pairs of nodes in the graph.",
        "graph_type": "undirected",
        "experience": "To calculate the diameter of a graph, start by understanding the input format which consists of nodes and their connections. Use the NetworkX library to create and analyze the graph structure.",
        "rag_data": [
            {
                "Section ID": "diameter",
                "Description": [
                    "Returns a lower bound on the diameter of the graph G.",
                    "The function computes a lower bound on the diameter (i.e., the maximum eccentricity)\nof a directed or undirected graph G. The procedure used varies depending on the graph\nbeing directed or not.",
                    "If G is an undirected graph, then the function uses the 2-sweep algorithm [1] .\nThe main idea is to pick the farthest node from a random node and return its eccentricity.",
                    "Otherwise, if G is a directed graph, the function uses the 2-dSweep algorithm [2] ,\nThe procedure starts by selecting a random source node \\(s\\) from which it performs a\nforward and a backward BFS. Let \\(a_1\\) and \\(a_2\\) be the farthest nodes in the forward and\nbackward cases, respectively. Then, it computes the backward eccentricity of \\(a_1\\) using\na backward BFS and the forward eccentricity of \\(a_2\\) using a forward BFS.\nFinally, it returns the best lower bound between the two.",
                    "In both cases, the time complexity is linear with respect to the size of G."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "seed : integer, random_state, or None (default)": "Indicator of random number generation state.\nSeeRandomness."
                    },
                    "Returns:": {
                        "d : integer": "Lower Bound on the Diameter of G"
                    },
                    "Raises:": {
                        "NetworkXError": "If the graph is empty or\nIf the graph is undirected and not connected or\nIf the graph is directed and not strongly connected."
                    }
                },
                "Rubrics": {
                    "References": "[1]Magnien, Cl\u00e9mence, Matthieu Latapy, and Michel Habib.Fast computation of empirically tight bounds for the diameter of massive graphs.Journal of Experimental Algorithmics (JEA), 2009.https://arxiv.org/pdf/0904.2728.pdf  [2]Crescenzi, Pierluigi, Roberto Grossi, Leonardo Lanzi, and Andrea Marino.On computing the diameter of real-world directed (weighted) graphs.International Symposium on Experimental Algorithms. Springer, Berlin, Heidelberg, 2012.https://courses.cs.ut.ee/MTAT.03.238/2014_fall/uploads/Main/diameter.pdf",
                    "Examples": "G=nx.path_graph(10)# undirected graph\nnx.diameter(G)\n# 9\nG=nx.cycle_graph(3,create_using=nx.DiGraph)# directed graph\nnx.diameter(G)\n# 2"
                }
            },
            {
                "Section ID": "all_pairs_shortest_path_length",
                "Description": [
                    "Computes the shortest path lengths between all nodes in G ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "cutoff : integer, optional": "Depth at which to stop the search. Only paths of length at mostcutoffare returned."
                    },
                    "Returns:": {
                        "lengths : iterator": "(source, dictionary) iterator with dictionary keyed by target and\nshortest path length as the key value."
                    }
                },
                "Rubrics": {
                    "Notes": "The iterator returned only has reachable node pairs.",
                    "Examples": "G=nx.path_graph(5)\nlength=dict(nx.all_pairs_shortest_path_length(G))\nfornodein[0,1,2,3,4]:\nprint(f\"1 - {node}: {length[1][node]}\")\n# 1 - 0: 1\n# 1 - 1: 0\n# 1 - 2: 1\n# 1 - 3: 2\n# 1 - 4: 3\nlength[3][2]\n# 1\nlength[2][2]\n# 0"
                }
            },
            {
                "Section ID": "diameter",
                "Description": [
                    "Returns the diameter of the graph G.",
                    "The diameter is the maximum eccentricity."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "A graph",
                        "e : eccentricity dictionary, optional": "A precomputed dictionary of eccentricities.",
                        "weight : string, function, or None": "If this is a string, then edge weights will be accessed via the\nedge attribute with this key (that is, the weight of the edge\njoiningutovwill beG.edges[u,v][weight]). If no\nsuch edge attribute exists, the weight of the edge is assumed to\nbe one.If this is a function, the weight of an edge is the value\nreturned by the function. The function must accept exactly three\npositional arguments: the two endpoints of an edge and the\ndictionary of edge attributes for that edge. The function must\nreturn a number.If this is None, every edge has weight/distance/cost 1.Weights stored as floating point values can lead to small round-off\nerrors in distances. Use integer weights to avoid this.Weights should be positive, since they are distances."
                    },
                    "Returns:": {
                        "d : integer": "Diameter of graph"
                    }
                },
                "Rubrics": {
                    "Examples": "G=nx.Graph([(1,2),(1,3),(1,4),(3,4),(3,5),(4,5)])\nnx.diameter(G)\n# 3"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <8>, <2>, <11>, <14>, <6>, <13>.\nNode <8> is connected to nodes <0>, <3>, <6>.\nNode <2> is connected to nodes <0>, <15>, <6>.\nNode <11> is connected to nodes <0>, <12>, <5>, <6>, <13>.\nNode <14> is connected to nodes <0>, <9>, <1>, <7>, <10>, <5>.\nNode <6> is connected to nodes <0>, <9>, <8>, <2>, <3>, <15>, <11>.\nNode <13> is connected to nodes <0>, <9>, <15>, <11>, <12>.\nNode <9> is connected to nodes <14>, <6>, <13>.\nNode <3> is connected to nodes <8>, <7>, <6>.\nNode <15> is connected to nodes <2>, <1>, <12>, <10>, <6>, <13>.\nNode <7> is connected to nodes <3>, <14>.\nNode <1> is connected to nodes <15>, <12>, <14>.\nNode <12> is connected to nodes <1>, <15>, <11>, <10>, <13>.\nNode <10> is connected to nodes <15>, <4>, <12>, <14>.\nNode <4> is connected to node <10>.\nNode <5> is connected to nodes <11>, <14>.\nCalculate the diameter of the graph. The diameter is the maximum distance over all pairs of nodes in the graph.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 0, 'Connections': [8, 2, 11, 14, 6, 13]},\n        {'Node': 8, 'Connections': [0, 3, 6]},\n        {'Node': 2, 'Connections': [0, 15, 6]},\n        {'Node': 11, 'Connections': [0, 12, 5, 6, 13]},\n        {'Node': 14, 'Connections': [0, 9, 1, 7, 10, 5]},\n        {'Node': 6, 'Connections': [0, 9, 8, 2, 3, 15, 11]},\n        {'Node': 13, 'Connections': [0, 9, 15, 11, 12]},\n        {'Node': 9, 'Connections': [14, 6, 13]},\n        {'Node': 3, 'Connections': [8, 7, 6]},\n        {'Node': 15, 'Connections': [2, 1, 12, 10, 6, 13]},\n        {'Node': 7, 'Connections': [3, 14]},\n        {'Node': 1, 'Connections': [15, 12, 14]},\n        {'Node': 12, 'Connections': [1, 15, 11, 10, 13]},\n        {'Node': 10, 'Connections': [15, 4, 12, 14]},\n        {'Node': 4, 'Connections': [10]},\n        {'Node': 5, 'Connections': [11, 14]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate the diameter of the graph\ntry:\n    diameter = nx.diameter(G)\n    print(f\"The diameter of the graph is: {diameter}\")\nexcept nx.NetworkXError as e:\n    print(f\"Error calculating diameter: {e}\")\n",
                "key_api": "networkx.Graph, networkx.diameter, networkx.all_pairs_shortest_path_length",
                "key_experience": "Use NetworkX to build the graph. Iterate through node connections to add edges. Compute the shortest paths between all pairs of nodes to determine the diameter. Use efficient algorithms provided by NetworkX to ensure accuracy and performance."
            }
        ]
    },
    {
        "id": 96,
        "problem": "Identify the neighbor nodes of node <5> in the directed graph.",
        "graph_type": "directed",
        "experience": "Your experience and practices here. You can use tell the key points and the steps to solve the problem.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <14> is connected to nodes <6>, <3>, <9>, <5>, <0>, <15>, <12>.\nNode <6> is connected to nodes <11>, <2>, <4>, <3>, <9>.\nNode <3> is connected to nodes <13>, <9>, <14>.\nNode <9> is connected to nodes <5>, <1>, <0>, <12>, <14>, <6>, <10>, <2>, <4>.\nNode <5> is connected to nodes <0>, <15>, <6>, <10>, <13>.\nNode <0> is connected to nodes <6>, <5>.\nNode <15> is connected to nodes <12>, <6>, <11>, <13>, <9>.\nNode <12> is connected to nodes <6>, <11>, <2>, <7>, <3>, <13>.\nNode <11> is connected to nodes <2>, <7>, <0>, <12>, <14>, <6>, <10>.\nNode <2> is connected to nodes <7>, <13>, <15>, <14>, <6>.\nNode <4> is connected to nodes <13>, <9>, <0>, <15>, <12>, <10>, <11>, <2>.\nNode <10> is connected to nodes <4>, <13>, <5>, <0>, <12>, <6>.\nNode <13> is connected to nodes <5>, <0>, <15>, <14>, <2>.\nNode <7> is connected to nodes <5>, <1>, <0>, <15>, <8>, <12>, <6>.\nNode <1> is connected to nodes <8>, <10>, <2>.\nNode <8> is connected to nodes <14>, <6>, <11>, <4>, <3>, <9>, <5>, <1>, <0>, <15>.\nWhich are the neighbor nodes of node <5>? In the context of a directed graph, we consider a node's successors as its neighbors. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph data\ngraph_data = {\n    '14': [6, 3, 9, 5, 0, 15, 12],\n    '6': [11, 2, 4, 3, 9],\n    '3': [13, 9, 14],\n    '9': [5, 1, 0, 12, 14, 6, 10, 2, 4],\n    '5': [0, 15, 6, 10, 13],\n    '0': [6, 5],\n    '15': [12, 6, 11, 13, 9],\n    '12': [6, 11, 2, 7, 3, 13],\n    '11': [2, 7, 0, 12, 14, 6, 10],\n    '2': [7, 13, 15, 14, 6],\n    '4': [13, 9, 0, 15, 12, 10, 11, 2],\n    '10': [4, 13, 5, 0, 12, 6],\n    '13': [5, 0, 15, 14, 2],\n    '7': [5, 1, 0, 15, 8, 12, 6],\n    '1': [8, 10, 2],\n    '8': [14, 6, 11, 4, 3, 9, 5, 1, 0, 15]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor node, neighbors in graph_data.items():\n    for neighbor in neighbors:\n        G.add_edge(node, str(neighbor))  # Ensure neighbors are strings\n\n# Identify the neighbors of node '5'\nneighbors_of_5 = list(G.successors('5'))\n\n# Print the neighbors\nprint(\"Neighbors of node 5:\", neighbors_of_5)\n",
                "key_api": "NetworkX",
                "key_experience": "['Extracting data from a given graph structure.', 'Converting nodes and neighbors to a suitable format (string) before adding to the graph.', 'Using NetworkX to create and manipulate a directed graph.', 'Using the `successors` method in NetworkX to find the neighbors of a specific node.', 'Iterating through the provided data to systematically add edges to the graph.']"
            }
        ]
    },
    {
        "id": 97,
        "problem": "Identify the neighbor nodes of node <11> in the directed graph.",
        "graph_type": "directed",
        "experience": "To solve the problem of identifying the neighbor nodes of a specific node (node 11) in a directed graph, we utilized the NetworkX library in Python. The task involved iterating through the provided graph data to construct the graph, and then querying the graph to identify the neighbors of the given node.",
        "rag_data": [
            {
                "Section ID": "from_dict_of_lists",
                "Description": [
                    "Returns a graph from a dictionary of lists."
                ],
                "Field List": {
                    "Parameters:": {
                        "d : dictionary of lists": "A dictionary of lists adjacency representation.",
                        "create_using : NetworkX graph constructor, optional (default=nx.Graph)": "Graph type to create. If graph instance, then cleared before populated."
                    }
                },
                "Rubrics": {
                    "Examples": "dol={0:[1]}# single edge (0,1)\nG=nx.from_dict_of_lists(dol)\nor\nG=nx.Graph(dol)# use Graph constructor"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <19> is connected to nodes <13>, <12>.\nNode <13> is connected to nodes <8>, <0>.\nNode <12> is connected to nodes <11>, <6>, <10>.\nNode <6> is connected to nodes <0>, <7>, <10>, <5>, <18>.\nNode <0> is connected to nodes <1>, <18>, <9>.\nNode <7> is connected to nodes <10>, <11>, <18>.\nNode <18> is connected to nodes <5>, <16>.\nNode <2> is connected to node <7>.\nNode <1> is connected to nodes <7>, <6>.\nNode <15> is connected to node <16>.\nNode <16> is connected to nodes <18>, <13>.\nNode <3> is connected to nodes <12>, <11>, <6>.\nNode <11> is connected to node <15>.\nNode <4> is connected to nodes <1>, <6>, <0>.\nNode <17> is connected to node <11>.\nNode <14> is connected to nodes <5>, <13>, <1>.\nWhich are the neighbor nodes of node <11>? In the context of a directed graph, we consider a node's successors as its neighbors. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 19, 'Connections': [13, 12]},\n        {'Node': 13, 'Connections': [8, 0]},\n        {'Node': 12, 'Connections': [11, 6, 10]},\n        {'Node': 6, 'Connections': [0, 7, 10, 5, 18]},\n        {'Node': 0, 'Connections': [1, 18, 9]},\n        {'Node': 7, 'Connections': [10, 11, 18]},\n        {'Node': 18, 'Connections': [5, 16]},\n        {'Node': 2, 'Connections': [7]},\n        {'Node': 1, 'Connections': [7, 6]},\n        {'Node': 15, 'Connections': [16]},\n        {'Node': 16, 'Connections': [18, 13]},\n        {'Node': 3, 'Connections': [12, 11, 6]},\n        {'Node': 11, 'Connections': [15]},\n        {'Node': 4, 'Connections': [1, 6, 0]},\n        {'Node': 17, 'Connections': [11]},\n        {'Node': 14, 'Connections': [5, 13, 1]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in input_data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Identify the neighbor nodes of node 11\nneighbors_of_11 = list(G.successors(11))\n\n# Output the neighbors\nprint(\"Neighbors of node 11:\", neighbors_of_11)\n",
                "key_api": "NetworkX (nx.DiGraph, nx.from_dict_of_lists, graph.successors)",
                "key_experience": "['Using NetworkX for graph representation and manipulation.', 'Converting input data into a graph structure.', 'Querying the graph for successors (out-neighbors) of the specified node.']"
            }
        ]
    },
    {
        "id": 98,
        "problem": "Identify the neighbor nodes of node <4>",
        "graph_type": "undirected",
        "experience": "I helped to solve the task of identifying the neighbor nodes of a specific node in a graph data structure. The task involved using a structured approach to define the graph and leveraging Python libraries to solve the problem effectively.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <6> is connected to nodes <10>, <3>, <16>, <7>, <4>, <13>, <1>, <12>.\nNode <10> is connected to nodes <6>, <11>, <14>, <17>, <15>, <8>.\nNode <3> is connected to node <6>.\nNode <16> is connected to nodes <6>, <2>, <0>.\nNode <7> is connected to node <6>.\nNode <4> is connected to nodes <6>, <9>.\nNode <13> is connected to node <6>.\nNode <1> is connected to node <6>.\nNode <12> is connected to node <6>.\nNode <11> is connected to nodes <10>, <19>.\nNode <14> is connected to nodes <10>, <5>.\nNode <17> is connected to node <10>.\nNode <15> is connected to node <10>.\nNode <8> is connected to node <10>.\nNode <5> is connected to node <14>.\nNode <19> is connected to node <11>.\nNode <2> is connected to node <16>.\nNode <0> is connected to node <16>.\nNode <9> is connected to nodes <4>, <18>.\nNode <18> is connected to node <9>.\nWhich are the neighbor nodes of node <4>? \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the input data\ngraph_data = {\n    'Nodes': [\n        {'Node': 6, 'Neighbors': [10, 3, 16, 7, 4, 13, 1, 12]},\n        {'Node': 10, 'Neighbors': [6, 11, 14, 17, 15, 8]},\n        {'Node': 3, 'Neighbors': [6]},\n        {'Node': 16, 'Neighbors': [6, 2, 0]},\n        {'Node': 7, 'Neighbors': [6]},\n        {'Node': 4, 'Neighbors': [6, 9]},\n        {'Node': 13, 'Neighbors': [6]},\n        {'Node': 1, 'Neighbors': [6]},\n        {'Node': 12, 'Neighbors': [6]},\n        {'Node': 11, 'Neighbors': [10, 19]},\n        {'Node': 14, 'Neighbors': [10, 5]},\n        {'Node': 17, 'Neighbors': [10]},\n        {'Node': 15, 'Neighbors': [10]},\n        {'Node': 8, 'Neighbors': [10]},\n        {'Node': 5, 'Neighbors': [14]},\n        {'Node': 19, 'Neighbors': [11]},\n        {'Node': 2, 'Neighbors': [16]},\n        {'Node': 0, 'Neighbors': [16]},\n        {'Node': 9, 'Neighbors': [4, 18]},\n        {'Node': 18, 'Neighbors': [9]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node in graph_data['Nodes']:\n    G.add_node(node['Node'])\n    for neighbor in node['Neighbors']:\n        G.add_edge(node['Node'], neighbor)\n\n# Identify the neighbor nodes of node 4\nnode_to_check = 4\nneighbors_of_node_4 = list(G.neighbors(node_to_check))\n\n# Print the neighbors of node 4\nprint(f\"Neighbors of node {node_to_check}: {neighbors_of_node_4}\")\n",
                "key_api": "NetworkX",
                "key_experience": "1. Defined the graph using a dictionary to store nodes and their neighbors. 2. Utilized NetworkX to create a graph from the dictionary data. 3. Accessed the neighbors using a graph function to keep the code clean and readable."
            }
        ]
    },
    {
        "id": 99,
        "problem": "Identify the neighbor nodes of node <5>",
        "graph_type": "undirected",
        "experience": "During the engagement, the task was to identify the neighbor nodes of a specific node, '5', from a given graph data using the NetworkX library in Python. The steps involved creating an undirected graph from the provided graph data, adding the edges, identifying the neighbors of node '5', and printing the result.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <19> is connected to nodes <3>, <13>, <5>, <8>, <11>, <12>, <2>, <15>, <16>, <4>, <18>.\nNode <3> is connected to nodes <19>, <15>, <4>.\nNode <13> is connected to nodes <19>, <10>, <11>, <12>, <2>, <15>, <18>.\nNode <5> is connected to nodes <19>, <7>, <2>, <0>, <4>.\nNode <8> is connected to nodes <19>, <1>, <16>, <14>, <9>, <6>, <17>.\nNode <11> is connected to nodes <19>, <1>, <13>, <7>, <2>, <14>, <17>.\nNode <12> is connected to nodes <19>, <10>, <13>, <7>, <15>, <4>, <14>, <18>, <6>.\nNode <2> is connected to nodes <19>, <13>, <5>, <11>, <7>, <15>, <0>, <4>, <14>, <9>, <18>, <6>.\nNode <15> is connected to nodes <19>, <3>, <13>, <12>, <2>, <16>, <14>, <9>, <18>.\nNode <16> is connected to nodes <19>, <1>, <8>, <7>, <15>, <0>, <14>, <18>.\nNode <4> is connected to nodes <19>, <10>, <3>, <5>, <12>, <2>, <0>, <14>, <17>.\nNode <18> is connected to nodes <19>, <13>, <7>, <12>, <2>, <15>, <16>, <14>.\nNode <10> is connected to nodes <13>, <12>, <0>, <4>.\nNode <0> is connected to nodes <10>, <5>, <7>, <2>, <16>, <4>, <14>.\nNode <1> is connected to nodes <8>, <11>, <16>.\nNode <7> is connected to nodes <5>, <11>, <12>, <2>, <0>, <16>, <9>, <18>, <6>.\nNode <14> is connected to nodes <8>, <11>, <12>, <2>, <15>, <0>, <16>, <4>, <9>, <18>, <6>, <17>.\nNode <9> is connected to nodes <8>, <7>, <2>, <15>, <14>, <6>.\nNode <6> is connected to nodes <8>, <7>, <12>, <2>, <14>, <9>.\nNode <17> is connected to nodes <8>, <11>, <4>, <14>.\nWhich are the neighbor nodes of node <5>? \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input graph data\ngraph_data = {\n    '19': [3, 13, 5, 8, 11, 12, 2, 15, 16, 4, 18],\n    '3': [19, 15, 4],\n    '13': [19, 10, 11, 12, 2, 15, 18],\n    '5': [19, 7, 2, 0, 4],\n    '8': [19, 1, 16, 14, 9, 6, 17],\n    '11': [19, 1, 13, 7, 2, 14, 17],\n    '12': [19, 10, 13, 7, 15, 4, 14, 18, 6],\n    '2': [19, 13, 5, 11, 7, 15, 0, 4, 14, 9, 18, 6],\n    '15': [19, 3, 13, 12, 2, 16, 14, 9, 18],\n    '16': [19, 1, 8, 7, 15, 0, 14, 18],\n    '4': [19, 10, 3, 5, 12, 2, 0, 14, 17],\n    '18': [19, 13, 7, 12, 2, 15, 16, 14],\n    '10': [13, 12, 0, 4],\n    '0': [10, 5, 7, 2, 16, 4, 14],\n    '1': [8, 11, 16],\n    '7': [5, 11, 12, 2, 0, 16, 9, 18, 6],\n    '14': [8, 11, 12, 2, 15, 0, 16, 4, 9, 18, 6, 17],\n    '9': [8, 7, 2, 15, 14, 6],\n    '6': [8, 7, 12, 2, 14, 9],\n    '17': [8, 11, 4, 14]\n}\n\n# Create an undirected graph from the input data\nG = nx.Graph()\n\n# Add edges to the graph\nfor node, neighbors in graph_data.items():\n    for neighbor in neighbors:\n        G.add_edge(node, neighbor)\n\n# Identify the neighbors of node '5'\nneighbors_of_5 = list(G.neighbors('5'))\n\n# Output the neighbors\nprint(\"Neighbors of node 5:\", neighbors_of_5)\n",
                "key_api": "NetworkX library's Graph and neighbors methods were pivotal. The Graph() was used to create an undirected graph, add_edge() to add edges, and neighbors() to identify the neighbors.",
                "key_experience": "[\"Creating an undirected graph using NetworkX's Graph() to better represent the input data.\", 'Iterating over the input graph data and adding edges to the graph to ensure all nodes and connections are appropriately represented.', 'Using the neighbors() method to easily retrieve neighboring nodes, ensuring efficient and accurate results.', 'Using informative print statements to display the results for better understanding and verification.']"
            }
        ]
    },
    {
        "id": 100,
        "problem": "Calculate the maximum flow between node <15> and node <8> in this graph.",
        "graph_type": "directed",
        "experience": "In the task to calculate the maximum flow between two nodes in a directed graph, several steps were undertaken to achieve the solution efficiently. Initially, the graph was represented using an adjacency list where each node stored its connections and corresponding weights. To find the maximum flow between node 15 and node 8, the Edmonds-Karp algorithm, an implementation of the Ford-Fulkerson method for maximum flow, was utilized. This method leverages breadth-first search (BFS) to find augmenting paths and update the flow until no more augmenting paths exist.",
        "rag_data": [
            {
                "Section ID": "maximum_flow",
                "Description": [
                    "Find a maximum single-commodity flow."
                ],
                "Field List": {
                    "Parameters:": {
                        "flowG : NetworkX graph": "Edges of the graph are expected to have an attribute called\n\u2018capacity\u2019. If this attribute is not present, the edge is\nconsidered to have infinite capacity.",
                        "_s : node": "Source node for the flow.",
                        "_t : node": "Sink node for the flow.",
                        "capacity : string": "Edges of the graph G are expected to have an attribute capacity\nthat indicates how much flow the edge can support. If this\nattribute is not present, the edge is considered to have\ninfinite capacity. Default value: \u2018capacity\u2019.",
                        "flow_func : function": "A function for computing the maximum flow among a pair of nodes\nin a capacitated graph. The function has to accept at least three\nparameters: a Graph or Digraph, a source node, and a target node.\nAnd return a residual network that follows NetworkX conventions\n(see Notes). If flow_func is None, the default maximum\nflow function (preflow_push()) is used. See below for\nalternative algorithms. The choice of the default function may change\nfrom version to version and should not be relied on. Default value:\nNone.",
                        "kwargs : Any other keyword parameter is passed to the function that": "computes the maximum flow."
                    },
                    "Returns:": {
                        "flow_value : integer, float": "Value of the maximum flow, i.e., net outflow from the source.",
                        "flow_dict : dict": "A dictionary containing the value of the flow that went through\neach edge."
                    },
                    "Raises:": {
                        "NetworkXError": "The algorithm does not support MultiGraph and MultiDiGraph. If\nthe input graph is an instance of one of these two classes, a\nNetworkXError is raised.",
                        "NetworkXUnbounded": "If the graph has a path of infinite capacity, the value of a\nfeasible flow on the graph is unbounded above and the function\nraises a NetworkXUnbounded."
                    }
                },
                "Rubrics": {
                    "Notes": "The function used in the flow_func parameter has to return a residual\nnetwork that follows NetworkX conventions: The residual network R from an input graph G has the\nsame nodes as G . R is a DiGraph that contains a pair\nof edges (u,v) and (v,u) iff (u,v) is not a\nself-loop, and at least one of (u,v) and (v,u) exists\nin G . For each edge (u,v) in R , R[u][v]['capacity'] is equal to the capacity of (u,v) in G if it exists\nin G or zero otherwise. If the capacity is infinite, R[u][v]['capacity'] will have a high arbitrary finite value\nthat does not affect the solution of the problem. This value is stored in R.graph['inf'] . For each edge (u,v) in R , R[u][v]['flow'] represents the flow function of (u,v) and\nsatisfies R[u][v]['flow']==-R[v][u]['flow'] . The flow value, defined as the total flow into t , the sink, is\nstored in R.graph['flow_value'] . Reachability to t using\nonly edges (u,v) such that R[u][v]['flow']<R[u][v]['capacity'] induces a minimum s - t cut. Specific algorithms may store extra data in R . The function should supports an optional boolean parameter value_only. When\nTrue, it can optionally terminate the algorithm as soon as the maximum flow\nvalue and the minimum cut can be determined.",
                    "Examples": "G=nx.DiGraph()\nG.add_edge(\"x\",\"a\",capacity=3.0)\nG.add_edge(\"x\",\"b\",capacity=1.0)\nG.add_edge(\"a\",\"c\",capacity=3.0)\nG.add_edge(\"b\",\"c\",capacity=5.0)\nG.add_edge(\"b\",\"d\",capacity=4.0)\nG.add_edge(\"d\",\"e\",capacity=2.0)\nG.add_edge(\"c\",\"y\",capacity=2.0)\nG.add_edge(\"e\",\"y\",capacity=3.0)\nmaximum_flow returns both the value of the maximum flow and a\ndictionary with all flows.\nflow_value,flow_dict=nx.maximum_flow(G,\"x\",\"y\")\nflow_value\n# 3.0\nprint(flow_dict[\"x\"][\"b\"])\n# 1.0\nYou can also use alternative algorithms for computing the\nmaximum flow by using the flow_func parameter.\nfromnetworkx.algorithms.flowimportshortest_augmenting_path\nflow_value==nx.maximum_flow(G,\"x\",\"y\",flow_func=shortest_augmenting_path)[0]\n# True"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <2> is connected to nodes <7> (weight: 8), <16> (weight: 8), <5> (weight: 4), <12> (weight: 0).\nNode <7> is connected to nodes <1> (weight: 6), <8> (weight: 3), <14> (weight: 9), <13> (weight: 1), <2> (weight: 0).\nNode <16> is connected to nodes <0> (weight: 7), <12> (weight: 1), <2> (weight: 8), <7> (weight: 7), <6> (weight: 1).\nNode <5> is connected to node <3> (weight: 1).\nNode <1> is connected to nodes <4> (weight: 9), <9> (weight: 10), <11> (weight: 7), <10> (weight: 8), <16> (weight: 10).\nNode <8> is connected to nodes <10> (weight: 10), <6> (weight: 0), <7> (weight: 0), <0> (weight: 0).\nNode <14> is connected to nodes <3> (weight: 3), <13> (weight: 6), <7> (weight: 8), <16> (weight: 1), <4> (weight: 3).\nNode <13> is connected to nodes <16> (weight: 3), <1> (weight: 5).\nNode <0> is connected to nodes <9> (weight: 5), <16> (weight: 4), <8> (weight: 1), <10> (weight: 0).\nNode <12> is connected to nodes <9> (weight: 1), <11> (weight: 1), <2> (weight: 2), <15> (weight: 0).\nNode <6> is connected to nodes <8> (weight: 10), <14> (weight: 4), <0> (weight: 3), <2> (weight: 1), <11> (weight: 0).\nNode <3> is connected to nodes <9> (weight: 3), <11> (weight: 9), <6> (weight: 6), <16> (weight: 2), <14> (weight: 7).\nNode <4> is connected to nodes <13> (weight: 5), <9> (weight: 8), <7> (weight: 10).\nNode <9> is connected to nodes <10> (weight: 8), <12> (weight: 3).\nNode <11> is connected to nodes <6> (weight: 3), <16> (weight: 1), <1> (weight: 3), <5> (weight: 3), <9> (weight: 9), <12> (weight: 0).\nNode <10> is connected to nodes <16> (weight: 7), <1> (weight: 10), <0> (weight: 2), <2> (weight: 10), <6> (weight: 8), <9> (weight: 0).\nNode <15> is connected to node <12> (weight: 5).\n\nCalculate the maximum flow between node <15> and node <8> in this graph. Given a directed graph with capacities assigned to its edges, the maximum flow from a source node to a sink node is the maximum amount of flow that can be sent from the source to the sink, respecting the capacity constraints on each edge. The goal is to find the optimal way to route flow through the network to maximize the flow from source to sink.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [\n        {'Node': 2, 'Connections': [{'Node': 7, 'Weight': 8}, {'Node': 16, 'Weight': 8}, {'Node': 5, 'Weight': 4}, {'Node': 12, 'Weight': 0}]},\n        {'Node': 7, 'Connections': [{'Node': 1, 'Weight': 6}, {'Node': 8, 'Weight': 3}, {'Node': 14, 'Weight': 9}, {'Node': 13, 'Weight': 1}, {'Node': 2, 'Weight': 0}]},\n        {'Node': 16, 'Connections': [{'Node': 0, 'Weight': 7}, {'Node': 12, 'Weight': 1}, {'Node': 2, 'Weight': 8}, {'Node': 7, 'Weight': 7}, {'Node': 6, 'Weight': 1}]},\n        {'Node': 5, 'Connections': [{'Node': 3, 'Weight': 1}]},\n        {'Node': 1, 'Connections': [{'Node': 4, 'Weight': 9}, {'Node': 9, 'Weight': 10}, {'Node': 11, 'Weight': 7}, {'Node': 10, 'Weight': 8}, {'Node': 16, 'Weight': 10}]},\n        {'Node': 8, 'Connections': [{'Node': 10, 'Weight': 10}, {'Node': 6, 'Weight': 0}, {'Node': 7, 'Weight': 0}, {'Node': 0, 'Weight': 0}]},\n        {'Node': 14, 'Connections': [{'Node': 3, 'Weight': 3}, {'Node': 13, 'Weight': 6}, {'Node': 7, 'Weight': 8}, {'Node': 16, 'Weight': 1}, {'Node': 4, 'Weight': 3}]},\n        {'Node': 13, 'Connections': [{'Node': 16, 'Weight': 3}, {'Node': 1, 'Weight': 5}]},\n        {'Node': 0, 'Connections': [{'Node': 9, 'Weight': 5}, {'Node': 16, 'Weight': 4}, {'Node': 8, 'Weight': 1}, {'Node': 10, 'Weight': 0}]},\n        {'Node': 12, 'Connections': [{'Node': 9, 'Weight': 1}, {'Node': 11, 'Weight': 1}, {'Node': 2, 'Weight': 2}, {'Node': 15, 'Weight': 0}]},\n        {'Node': 6, 'Connections': [{'Node': 8, 'Weight': 10}, {'Node': 14, 'Weight': 4}, {'Node': 0, 'Weight': 3}, {'Node': 2, 'Weight': 1}, {'Node': 11, 'Weight': 0}]},\n        {'Node': 3, 'Connections': [{'Node': 9, 'Weight': 3}, {'Node': 11, 'Weight': 9}, {'Node': 6, 'Weight': 6}, {'Node': 16, 'Weight': 2}, {'Node': 14, 'Weight': 7}]},\n        {'Node': 4, 'Connections': [{'Node': 13, 'Weight': 5}, {'Node': 9, 'Weight': 8}, {'Node': 7, 'Weight': 10}]},\n        {'Node': 9, 'Connections': [{'Node': 10, 'Weight': 8}, {'Node': 12, 'Weight': 3}]},\n        {'Node': 11, 'Connections': [{'Node': 6, 'Weight': 3}, {'Node': 16, 'Weight': 1}, {'Node': 1, 'Weight': 3}, {'Node': 5, 'Weight': 3}, {'Node': 9, 'Weight': 9}, {'Node': 12, 'Weight': 0}]},\n        {'Node': 10, 'Connections': [{'Node': 16, 'Weight': 7}, {'Node': 1, 'Weight': 10}, {'Node': 0, 'Weight': 2}, {'Node': 2, 'Weight': 10}, {'Node': 6, 'Weight': 8}, {'Node': 9, 'Weight': 0}]},\n        {'Node': 15, 'Connections': [{'Node': 12, 'Weight': 5}]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection['Node'], capacity=connection['Weight'])\n\n# Calculate the maximum flow from node 15 to node 8\nsource = 15\ntarget = 8\nflow_value, flow_dict = nx.maximum_flow(G, _s=source, _t=target)\n\n# Output the maximum flow value\nprint(f\"Maximum flow from node {source} to node {target}: {flow_value}\")\n",
                "key_api": "NetworkX library in Python, which provides easy-to-use functions to create directed graphs, add nodes and edges, and compute maximum flow using networkx.maximum_flow().",
                "key_experience": "The best practices included converting the problem into a format suitable for the NetworkX library, validating the graph structure, implementing the BFS to find augmenting paths, and iteratively updating the flow. Exception handling was also implemented to manage potential issues with graph cycles or disconnected components."
            }
        ]
    },
    {
        "id": 101,
        "problem": "Calculate the maximum flow between node <12> and node <6> in this graph.",
        "graph_type": "directed",
        "experience": "This task involves calculating the maximum flow between two nodes in a directed graph with specified weights representing the capacities of the edges. The problem can be approached using the Ford-Fulkerson algorithm, which is commonly implemented using the Edmonds-Karp algorithm for better efficiency. In the provided implementation, the graph is first converted into an adjacency matrix, and then BFS is used to find augmenting paths until no more paths with available capacity are found. The residual capacities are updated accordingly to keep track of flow.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <11> is connected to nodes <12> (weight: 6), <13> (weight: 3).\nNode <12> is connected to nodes <15> (weight: 2), <7> (weight: 7), <14> (weight: 6), <16> (weight: 6).\nNode <13> is connected to nodes <10> (weight: 9), <11> (weight: 8), <15> (weight: 2), <0> (weight: 1), <9> (weight: 7), <16> (weight: 4), <1> (weight: 8).\nNode <15> is connected to nodes <6> (weight: 10), <9> (weight: 6), <1> (weight: 10), <12> (weight: 3), <7> (weight: 0).\nNode <7> is connected to nodes <6> (weight: 6), <16> (weight: 5), <11> (weight: 6), <5> (weight: 9), <15> (weight: 1), <0> (weight: 7), <12> (weight: 0).\nNode <14> is connected to nodes <6> (weight: 3), <1> (weight: 1), <4> (weight: 2), <12> (weight: 10), <3> (weight: 1), <5> (weight: 5), <0> (weight: 9).\nNode <16> is connected to nodes <8> (weight: 8), <4> (weight: 3), <13> (weight: 3), <0> (weight: 3), <12> (weight: 0).\nNode <10> is connected to nodes <3> (weight: 4), <5> (weight: 7), <0> (weight: 9), <6> (weight: 7), <8> (weight: 0).\nNode <0> is connected to nodes <6> (weight: 3), <15> (weight: 7), <14> (weight: 0), <16> (weight: 0).\nNode <9> is connected to nodes <1> (weight: 3), <4> (weight: 8), <10> (weight: 5), <3> (weight: 5), <0> (weight: 9), <6> (weight: 9).\nNode <1> is connected to nodes <12> (weight: 2), <10> (weight: 7), <11> (weight: 3), <0> (weight: 2).\nNode <3> is connected to nodes <5> (weight: 8), <15> (weight: 1), <0> (weight: 8), <6> (weight: 10), <2> (weight: 5), <9> (weight: 10), <8> (weight: 2), <1> (weight: 8), <14> (weight: 0).\nNode <5> is connected to nodes <2> (weight: 8), <9> (weight: 6), <1> (weight: 6), <4> (weight: 5), <13> (weight: 5), <10> (weight: 7).\nNode <6> is connected to nodes <9> (weight: 1), <8> (weight: 9), <1> (weight: 9), <5> (weight: 9), <7> (weight: 3), <14> (weight: 4), <15> (weight: 0), <3> (weight: 0), <0> (weight: 0), <10> (weight: 0).\nNode <2> is connected to nodes <16> (weight: 6), <11> (weight: 6), <5> (weight: 2), <0> (weight: 3).\nNode <8> is connected to nodes <12> (weight: 9), <13> (weight: 7), <10> (weight: 7), <5> (weight: 8), <2> (weight: 7), <16> (weight: 0).\nNode <4> is connected to nodes <12> (weight: 3), <13> (weight: 10), <5> (weight: 5), <0> (weight: 1).\n\nCalculate the maximum flow between node <12> and node <6> in this graph. Given a directed graph with capacities assigned to its edges, the maximum flow from a source node to a sink node is the maximum amount of flow that can be sent from the source to the sink, respecting the capacity constraints on each edge. The goal is to find the optimal way to route flow through the network to maximize the flow from source to sink.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [\n        {'Node': 11, 'Connections': [{'Node': 12, 'Weight': 6}, {'Node': 13, 'Weight': 3}]},\n        {'Node': 12, 'Connections': [{'Node': 15, 'Weight': 2}, {'Node': 7, 'Weight': 7}, {'Node': 14, 'Weight': 6}, {'Node': 16, 'Weight': 6}]},\n        {'Node': 13, 'Connections': [{'Node': 10, 'Weight': 9}, {'Node': 11, 'Weight': 8}, {'Node': 15, 'Weight': 2}, {'Node': 0, 'Weight': 1}, {'Node': 9, 'Weight': 7}, {'Node': 16, 'Weight': 4}, {'Node': 1, 'Weight': 8}]},\n        {'Node': 15, 'Connections': [{'Node': 6, 'Weight': 10}, {'Node': 9, 'Weight': 6}, {'Node': 1, 'Weight': 10}, {'Node': 12, 'Weight': 3}, {'Node': 7, 'Weight': 0}]},\n        {'Node': 7, 'Connections': [{'Node': 6, 'Weight': 6}, {'Node': 16, 'Weight': 5}, {'Node': 11, 'Weight': 6}, {'Node': 5, 'Weight': 9}, {'Node': 15, 'Weight': 1}, {'Node': 0, 'Weight': 7}, {'Node': 12, 'Weight': 0}]},\n        {'Node': 14, 'Connections': [{'Node': 6, 'Weight': 3}, {'Node': 1, 'Weight': 1}, {'Node': 4, 'Weight': 2}, {'Node': 12, 'Weight': 10}, {'Node': 3, 'Weight': 1}, {'Node': 5, 'Weight': 5}, {'Node': 0, 'Weight': 9}]},\n        {'Node': 16, 'Connections': [{'Node': 8, 'Weight': 8}, {'Node': 4, 'Weight': 3}, {'Node': 13, 'Weight': 3}, {'Node': 0, 'Weight': 3}, {'Node': 12, 'Weight': 0}]},\n        {'Node': 10, 'Connections': [{'Node': 3, 'Weight': 4}, {'Node': 5, 'Weight': 7}, {'Node': 0, 'Weight': 9}, {'Node': 6, 'Weight': 7}, {'Node': 8, 'Weight': 0}]},\n        {'Node': 0, 'Connections': [{'Node': 6, 'Weight': 3}, {'Node': 15, 'Weight': 7}, {'Node': 14, 'Weight': 0}, {'Node': 16, 'Weight': 0}]},\n        {'Node': 9, 'Connections': [{'Node': 1, 'Weight': 3}, {'Node': 4, 'Weight': 8}, {'Node': 10, 'Weight': 5}, {'Node': 3, 'Weight': 5}, {'Node': 0, 'Weight': 9}, {'Node': 6, 'Weight': 9}]},\n        {'Node': 1, 'Connections': [{'Node': 12, 'Weight': 2}, {'Node': 10, 'Weight': 7}, {'Node': 11, 'Weight': 3}, {'Node': 0, 'Weight': 2}]},\n        {'Node': 3, 'Connections': [{'Node': 5, 'Weight': 8}, {'Node': 15, 'Weight': 1}, {'Node': 0, 'Weight': 8}, {'Node': 6, 'Weight': 10}, {'Node': 2, 'Weight': 5}, {'Node': 9, 'Weight': 10}, {'Node': 8, 'Weight': 2}, {'Node': 1, 'Weight': 8}, {'Node': 14, 'Weight': 0}]},\n        {'Node': 5, 'Connections': [{'Node': 2, 'Weight': 8}, {'Node': 9, 'Weight': 6}, {'Node': 1, 'Weight': 6}, {'Node': 4, 'Weight': 5}, {'Node': 13, 'Weight': 5}, {'Node': 10, 'Weight': 7}]},\n        {'Node': 6, 'Connections': [{'Node': 9, 'Weight': 1}, {'Node': 8, 'Weight': 9}, {'Node': 1, 'Weight': 9}, {'Node': 5, 'Weight': 9}, {'Node': 7, 'Weight': 3}, {'Node': 14, 'Weight': 4}, {'Node': 15, 'Weight': 0}, {'Node': 3, 'Weight': 0}, {'Node': 0, 'Weight': 0}, {'Node': 10, 'Weight': 0}]},\n        {'Node': 2, 'Connections': [{'Node': 16, 'Weight': 6}, {'Node': 11, 'Weight': 6}, {'Node': 5, 'Weight': 2}, {'Node': 0, 'Weight': 3}]},\n        {'Node': 8, 'Connections': [{'Node': 12, 'Weight': 9}, {'Node': 13, 'Weight': 7}, {'Node': 10, 'Weight': 7}, {'Node': 5, 'Weight': 8}, {'Node': 2, 'Weight': 7}, {'Node': 16, 'Weight': 0}]},\n        {'Node': 4, 'Connections': [{'Node': 12, 'Weight': 3}, {'Node': 13, 'Weight': 10}, {'Node': 5, 'Weight': 5}, {'Node': 0, 'Weight': 1}]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection['Node'], capacity=connection['Weight'])\n\n# Calculate the maximum flow from node 12 to node 6\nsource = 12\nsink = 6\nflow_value, flow_dict = nx.maximum_flow(G, _s=source, _t=sink)\n\n# Output the maximum flow value\nprint(f\"Maximum flow from node {source} to node {sink}: {flow_value}\")\n",
                "key_api": "['collections.defaultdict', 'queue.Queue']",
                "key_experience": "['Using BFS to find augmenting paths in the residual graph', 'Updating residual capacities to reflect the flow in the network', 'Maintaining a parent dictionary to reconstruct the path', 'Checking for unvisited nodes and available capacity during BFS', 'Summing up the flow values along the found augmenting paths to determine the maximum flow']"
            }
        ]
    },
    {
        "id": 102,
        "problem": "Find the connected component containing node <9>",
        "graph_type": "undirected",
        "experience": "To solve the problem of finding the connected component containing a specific node in a graph, the following steps were taken: 1) Received input data representing nodes and edges of the graph. 2) Created an undirected graph using the NetworkX library. 3) Added nodes and edges to the graph. 4) Used the `node_connected_component` function from NetworkX to find the connected component containing the specified node. 5) Printed the output showing the connected component.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <17> is connected to nodes <12>, <5>.\nNode <12> is connected to nodes <17>, <1>, <0>.\nNode <5> is connected to nodes <17>, <8>.\nNode <1> is connected to nodes <12>, <6>, <7>.\nNode <0> is connected to nodes <12>, <8>, <2>, <9>.\nNode <8> is connected to nodes <5>, <0>.\nNode <2> is connected to node <0>.\nNode <9> is connected to node <0>.\nNode <10> is connected to node <11>.\nNode <11> is connected to nodes <10>, <16>.\nNode <16> is connected to nodes <11>, <3>.\nNode <3> is connected to nodes <16>, <6>.\nNode <13> is connected to nodes <14>, <4>.\nNode <14> is connected to nodes <13>, <4>.\nNode <4> is connected to nodes <13>, <14>.\nNode <15> is connected to node <6>.\nNode <6> is connected to nodes <15>, <1>, <3>.\nNode <7> is connected to node <1>.\nFind the connected component containing node <9>. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [17, 12, 5, 1, 0, 8, 2, 9, 10, 11, 16, 3, 13, 14, 4, 15, 6, 7],\n    'Edges': [[17, 12], [17, 5], [12, 1], [12, 0], [5, 8], [1, 6], [1, 7], \n              [0, 8], [0, 2], [0, 9], [2, 0], [9, 0], [10, 11], [11, 16], \n              [16, 3], [3, 6], [13, 14], [13, 4], [14, 4], [15, 6], [6, 1], \n              [6, 3], [7, 1]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Find the connected component containing node 9\nconnected_component = nx.node_connected_component(G, 9)\n\n# Output the connected component\nprint(\"Connected component containing node 9:\", connected_component)\n",
                "key_api": "NetworkX is the key API used, particularly the `node_connected_component` function which efficiently finds and returns the connected component containing a given node.",
                "key_experience": "Best practices include: 1) Structuring the input data clearly to match the graph's nodes and edges. 2) Using a well-established library (NetworkX) to handle graph operations, ensuring robust and optimized functionality. 3) Printing the results for clear and straightforward output."
            }
        ]
    },
    {
        "id": 103,
        "problem": "Find the connected component containing node <9>",
        "graph_type": "undirected",
        "experience": "To solve the problem of finding the connected component containing a specific node in a graph, the following steps were taken: 1) Received input data representing nodes and edges of the graph. 2) Created an undirected graph using the NetworkX library. 3) Added nodes and edges to the graph. 4) Used the `node_connected_component` function from NetworkX to find the connected component containing the specified node. 5) Printed the output showing the connected component.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <17> is connected to nodes <12>, <5>.\nNode <12> is connected to nodes <17>, <1>, <0>.\nNode <5> is connected to nodes <17>, <8>.\nNode <1> is connected to nodes <12>, <6>, <7>.\nNode <0> is connected to nodes <12>, <8>, <2>, <9>.\nNode <8> is connected to nodes <5>, <0>.\nNode <2> is connected to node <0>.\nNode <9> is connected to node <0>.\nNode <10> is connected to node <11>.\nNode <11> is connected to nodes <10>, <16>.\nNode <16> is connected to nodes <11>, <3>.\nNode <3> is connected to nodes <16>, <6>.\nNode <13> is connected to nodes <14>, <4>.\nNode <14> is connected to nodes <13>, <4>.\nNode <4> is connected to nodes <13>, <14>.\nNode <15> is connected to node <6>.\nNode <6> is connected to nodes <15>, <1>, <3>.\nNode <7> is connected to node <1>.\nFind the connected component containing node <9>. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [17, 12, 5, 1, 0, 8, 2, 9, 10, 11, 16, 3, 13, 14, 4, 15, 6, 7],\n    'Edges': [[17, 12], [17, 5], [12, 1], [12, 0], [5, 8], [1, 6], [1, 7], \n              [0, 8], [0, 2], [0, 9], [2, 0], [9, 0], [10, 11], [11, 16], \n              [16, 3], [3, 6], [13, 14], [13, 4], [14, 4], [15, 6], [6, 1], \n              [6, 3], [7, 1]]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(data['Nodes'])\nG.add_edges_from(data['Edges'])\n\n# Find the connected component containing node 9\nconnected_component = nx.node_connected_component(G, 9)\n\n# Output the connected component\nprint(\"Connected component containing node 9:\", connected_component)\n",
                "key_api": "NetworkX is the key API used, particularly the `node_connected_component` function which efficiently finds and returns the connected component containing a given node.",
                "key_experience": "Best practices include: 1) Structuring the input data clearly to match the graph's nodes and edges. 2) Using a well-established library (NetworkX) to handle graph operations, ensuring robust and optimized functionality. 3) Printing the results for clear and straightforward output."
            }
        ]
    },
    {
        "id": 104,
        "problem": "Find the strongly connected component containing node <12>",
        "graph_type": "directed",
        "experience": "The experience involved solving a problem to find the strongly connected component (SCC) containing a specific node using the NetworkX library in Python. Key steps were creating a directed graph from given nodes and edges, finding all SCCs, and then identifying the SCC containing the target node.",
        "rag_data": [
            {
                "Section ID": "strongly_connected_components",
                "Description": [
                    "Generate nodes in strongly connected components of graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "A directed graph."
                    },
                    "Returns:": {
                        "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
                    },
                    "Raises:": {
                        "NetworkXNotImplemented": "If G is undirected."
                    }
                },
                "Rubrics": {
                    "Notes": "Uses Tarjan\u2019s algorithm[R827335e01166-1]_ with Nuutila\u2019s modifications[R827335e01166-2]_.\nNonrecursive version of algorithm.",
                    "References": "[1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..",
                    "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[len(c)forcinsorted(nx.strongly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components(G),key=len)"
                }
            }
        ],
        "accuracy": 0.8999999999999999,
        "example": [
            {
                "question": "Given a directed graph:\nNode <4> is connected to nodes <10>, <13>.\nNode <10> is connected to nodes <5>, <13>.\nNode <13> is connected to nodes <5>, <6>, <15>.\nNode <16> is connected to node <3>.\nNode <1> is connected to node <2>.\nNode <2> is connected to node <8>.\nNode <0> is connected to nodes <12>, <9>.\nNode <12> is connected to node <8>.\nNode <9> is connected to nodes <1>, <8>.\nNode <14> is connected to node <7>.\nNode <7> is connected to nodes <11>, <4>.\nNode <11> is connected to node <3>.\nNode <6> is connected to node <2>.\nNode <15> is connected to nodes <9>, <7>, <2>.\nFind the strongly connected component containing node <12>. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input graph data\ninput_data = {\n    'nodes': [4, 10, 13, 16, 1, 2, 0, 12, 9, 14, 7, 11, 6, 15, 3, 8],\n    'edges': [\n        {'from': 4, 'to': [10, 13]},\n        {'from': 10, 'to': [5, 13]},\n        {'from': 13, 'to': [5, 6, 15]},\n        {'from': 16, 'to': [3]},\n        {'from': 1, 'to': [2]},\n        {'from': 2, 'to': [8]},\n        {'from': 0, 'to': [12, 9]},\n        {'from': 12, 'to': [8]},\n        {'from': 9, 'to': [1, 8]},\n        {'from': 14, 'to': [7]},\n        {'from': 7, 'to': [11, 4]},\n        {'from': 11, 'to': [3]},\n        {'from': 6, 'to': [2]},\n        {'from': 15, 'to': [9, 7, 2]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in input_data['edges']:\n    for target in edge['to']:\n        G.add_edge(edge['from'], target)\n\n# Find strongly connected components\nscc = list(nx.strongly_connected_components(G))\n\n# Find the SCC containing node 12\nscc_with_node_12 = next((component for component in scc if 12 in component), None)\n\n# Output the strongly connected component containing node 12\nprint(f\"The strongly connected component containing node 12 is: {scc_with_node_12}\")\n",
                "key_api": "NetworkX (especially nx.DiGraph() for creating a directed graph and nx.strongly_connected_components() for finding SCCs)",
                "key_experience": "1. Properly structuring and parsing input data (nodes and edges). 2. Iterating through each edge and its targets to add them to the graph. 3. Using list comprehension and generator expressions to efficiently find the SCC containing the target node. 4. Using clear and concise variable names and output formatting."
            }
        ]
    },
    {
        "id": 105,
        "problem": "Find the strongly connected component containing node <15>",
        "graph_type": "directed",
        "experience": "To solve the problem of finding the strongly connected component containing a specific node in a directed graph, the process follows these key points and practices: 1. Import the necessary libraries such as NetworkX for graph operations. 2. Define the input data structure, typically representing nodes and their connections. 3. Construct the directed graph using the input data. 4. Utilize NetworkX's built-in functions to find all strongly connected components in the graph. 5. Identify and return the component that contains the specified target node.",
        "rag_data": [
            {
                "Section ID": "strongly_connected_components",
                "Description": [
                    "Generate nodes in strongly connected components of graph."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "A directed graph."
                    },
                    "Returns:": {
                        "comp : generator of sets": "A generator of sets of nodes, one for each strongly connected\ncomponent of G."
                    },
                    "Raises:": {
                        "NetworkXNotImplemented": "If G is undirected."
                    }
                },
                "Rubrics": {
                    "Notes": "Uses Tarjan\u2019s algorithm[R827335e01166-1]_ with Nuutila\u2019s modifications[R827335e01166-2]_.\nNonrecursive version of algorithm.",
                    "References": "[1]Depth-first search and linear graph algorithms, R. Tarjan\nSIAM Journal of Computing 1(2):146-160, (1972).  [2]On finding the strongly connected components in a directed graph.\nE. Nuutila and E. Soisalon-Soinen\nInformation Processing Letters 49(1): 9-14, (1994)..",
                    "Examples": "Generate a sorted list of strongly connected components, largest first.\nG=nx.cycle_graph(4,create_using=nx.DiGraph())\nnx.add_cycle(G,[10,11,12])\n[len(c)forcinsorted(nx.strongly_connected_components(G),key=len,reverse=True)]\n# [4, 3]\nIf you only want the largest component, it\u2019s more efficient to\nuse max instead of sort.\nlargest=max(nx.strongly_connected_components(G),key=len)"
                }
            }
        ],
        "accuracy": 0.8999999999999999,
        "example": [
            {
                "question": "Given a directed graph:\nNode <15> is connected to nodes <12>, <11>, <1>, <2>.\nNode <12> is connected to nodes <8>, <0>, <10>, <9>, <14>.\nNode <11> is connected to nodes <7>, <2>, <5>, <13>.\nNode <1> is connected to nodes <7>, <9>, <6>, <8>.\nNode <2> is connected to nodes <6>, <12>, <1>, <10>, <9>.\nNode <3> is connected to nodes <11>, <0>, <10>, <5>, <6>.\nNode <0> is connected to nodes <10>, <13>, <11>.\nNode <10> is connected to nodes <2>, <6>, <1>.\nNode <5> is connected to nodes <14>, <12>, <7>, <10>.\nNode <6> is connected to nodes <14>, <4>, <12>, <13>, <0>, <7>, <10>.\nNode <4> is connected to nodes <13>, <11>, <8>, <1>, <7>, <10>, <9>.\nNode <13> is connected to nodes <11>, <1>, <2>.\nNode <8> is connected to nodes <1>, <0>, <9>, <6>, <13>.\nNode <7> is connected to nodes <9>, <4>, <11>, <0>.\nNode <9> is connected to nodes <2>, <6>, <14>, <3>, <10>.\nNode <14> is connected to nodes <12>, <13>, <11>, <7>, <2>, <5>, <6>.\nFind the strongly connected component containing node <15>. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 15, 'Connections': [12, 11, 1, 2]},\n        {'Node': 12, 'Connections': [8, 0, 10, 9, 14]},\n        {'Node': 11, 'Connections': [7, 2, 5, 13]},\n        {'Node': 1, 'Connections': [7, 9, 6, 8]},\n        {'Node': 2, 'Connections': [6, 12, 1, 10, 9]},\n        {'Node': 3, 'Connections': [11, 0, 10, 5, 6]},\n        {'Node': 0, 'Connections': [10, 13, 11]},\n        {'Node': 10, 'Connections': [2, 6, 1]},\n        {'Node': 5, 'Connections': [14, 12, 7, 10]},\n        {'Node': 6, 'Connections': [14, 4, 12, 13, 0, 7, 10]},\n        {'Node': 4, 'Connections': [13, 11, 8, 1, 7, 10, 9]},\n        {'Node': 13, 'Connections': [11, 1, 2]},\n        {'Node': 8, 'Connections': [1, 0, 9, 6, 13]},\n        {'Node': 7, 'Connections': [9, 4, 11, 0]},\n        {'Node': 9, 'Connections': [2, 6, 14, 3, 10]},\n        {'Node': 14, 'Connections': [12, 13, 11, 7, 2, 5, 6]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in input_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Find strongly connected components\nscc = list(nx.strongly_connected_components(G))\n\n# Find the SCC containing node 15\nscc_containing_15 = next((component for component in scc if 15 in component), None)\n\n# Output the result\nprint(f\"The strongly connected component containing node 15 is: {scc_containing_15}\")\n",
                "key_api": "networkx (a popular Python library for the creation, manipulation, and study of the structure, dynamics, and functions of complex networks). Specifically, the usage of nx.DiGraph() to create a directed graph, nx.strongly_connected_components() to find all strongly connected components.",
                "key_experience": "1. Ensuring that the input data is clearly defined and accurately represents the graph structure. 2. Leveraging well-established libraries like NetworkX that offer efficient and reliable graph algorithms. 3. Writing modular and reusable code that can be easily adapted to similar problems. 4. Including necessary imports and following code formatting standards to ensure easy extraction and readability of the output code."
            }
        ]
    },
    {
        "id": 106,
        "problem": "Is there a path between node <18> and node <10>?",
        "graph_type": "undirected",
        "experience": "The experience entails solving a graph-related pathfinding problem by determining if there is a path between two specified nodes (18 and 10) in a given graph structure. The task requires transforming the given graph data into a form usable by a graph processing library (NetworkX) and then applying a pathfinding algorithm.",
        "rag_data": [
            {
                "Section ID": "has_path",
                "Description": [
                    "Returns True if G has a path from source to target ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node": "Starting node for path",
                        "target : node": "Ending node for path"
                    }
                },
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <2> is connected to nodes <15>, <13>, <12>.\nNode <15> is connected to nodes <2>, <16>, <5>, <13>.\nNode <13> is connected to nodes <2>, <15>, <14>, <16>.\nNode <12> is connected to nodes <2>, <14>, <7>, <4>.\nNode <16> is connected to nodes <15>, <13>, <5>, <1>.\nNode <5> is connected to nodes <15>, <6>, <16>, <17>, <1>.\nNode <9> is connected to nodes <10>, <17>, <11>.\nNode <10> is connected to nodes <9>, <4>, <7>.\nNode <17> is connected to nodes <9>, <6>, <11>, <4>, <5>.\nNode <11> is connected to nodes <9>, <17>, <0>, <18>.\nNode <4> is connected to nodes <10>, <7>, <17>, <12>.\nNode <7> is connected to nodes <10>, <14>, <12>, <4>.\nNode <14> is connected to nodes <6>, <13>, <7>, <12>.\nNode <6> is connected to nodes <14>, <17>, <3>, <1>, <5>.\nNode <3> is connected to nodes <6>, <8>, <18>, <0>.\nNode <1> is connected to nodes <6>, <16>, <8>, <18>, <5>.\nNode <8> is connected to nodes <3>, <1>, <0>.\nNode <0> is connected to nodes <8>, <3>, <11>, <18>.\nNode <18> is connected to nodes <3>, <11>, <0>, <1>.\nIs there a path between node <18> and node <10>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'nodes': [\n        {'node': 2, 'connections': [15, 13, 12]},\n        {'node': 15, 'connections': [2, 16, 5, 13]},\n        {'node': 13, 'connections': [2, 15, 14, 16]},\n        {'node': 12, 'connections': [2, 14, 7, 4]},\n        {'node': 16, 'connections': [15, 13, 5, 1]},\n        {'node': 5, 'connections': [15, 6, 16, 17, 1]},\n        {'node': 9, 'connections': [10, 17, 11]},\n        {'node': 10, 'connections': [9, 4, 7]},\n        {'node': 17, 'connections': [9, 6, 11, 4, 5]},\n        {'node': 11, 'connections': [9, 17, 0, 18]},\n        {'node': 4, 'connections': [10, 7, 17, 12]},\n        {'node': 7, 'connections': [10, 14, 12, 4]},\n        {'node': 14, 'connections': [6, 13, 7, 12]},\n        {'node': 6, 'connections': [14, 17, 3, 1, 5]},\n        {'node': 3, 'connections': [6, 8, 18, 0]},\n        {'node': 1, 'connections': [6, 16, 8, 18, 5]},\n        {'node': 8, 'connections': [3, 1, 0]},\n        {'node': 0, 'connections': [8, 3, 11, 18]},\n        {'node': 18, 'connections': [3, 11, 0, 1]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node_info in input_data['nodes']:\n    node = node_info['node']\n    connections = node_info['connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Check if there is a path between node 18 and node 10\npath_exists = nx.has_path(G, 18, 10)\n\n# Output the result\nprint(f\"Is there a path between node 18 and node 10? {'Yes' if path_exists else 'No'}\")\n",
                "key_api": "networkx, nx.Graph, nx.has_path",
                "key_experience": "['Transform the graph data into NetworkX graph format.', 'Use NetworkX library methods to manage and analyze the graph.', 'Ensure clear and structured input and output processes in the code.', 'Apply best practices for defining and using graph connections in NetworkX.']"
            }
        ]
    },
    {
        "id": 107,
        "problem": "Is there a path between node <4> and node <14>?",
        "graph_type": "undirected",
        "experience": "To determine whether there is a path between two nodes in a graph, use a graph library like NetworkX in Python. The task involves constructing the graph using node and edge information provided, and then applying graph traversal algorithms to check for connectivity.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <2> is connected to nodes <5>, <4>.\nNode <5> is connected to node <2>.\nNode <4> is connected to nodes <2>, <11>, <13>.\nNode <10> is connected to nodes <17>, <7>, <15>.\nNode <17> is connected to node <10>.\nNode <7> is connected to nodes <10>, <3>, <9>.\nNode <15> is connected to node <10>.\nNode <12> is connected to node <8>.\nNode <8> is connected to nodes <12>, <13>.\nNode <13> is connected to nodes <8>, <4>, <11>.\nNode <11> is connected to nodes <4>, <13>.\nNode <3> is connected to nodes <7>, <9>.\nNode <9> is connected to nodes <7>, <3>, <6>.\nNode <14> is connected to nodes <16>, <1>.\nNode <16> is connected to nodes <14>, <0>.\nNode <1> is connected to node <14>.\nNode <0> is connected to nodes <16>, <6>.\nNode <6> is connected to nodes <0>, <9>.\nIs there a path between node <4> and node <14>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the input\ninput_data = {\n    'Nodes': [2, 5, 4, 10, 17, 7, 15, 12, 8, 13, 11, 3, 9, 14, 16, 1, 0, 6],\n    'Edges': [\n        {'Node': 2, 'Connected_To': [5, 4]},\n        {'Node': 5, 'Connected_To': [2]},\n        {'Node': 4, 'Connected_To': [2, 11, 13]},\n        {'Node': 10, 'Connected_To': [17, 7, 15]},\n        {'Node': 17, 'Connected_To': [10]},\n        {'Node': 7, 'Connected_To': [10, 3, 9]},\n        {'Node': 15, 'Connected_To': [10]},\n        {'Node': 12, 'Connected_To': [8]},\n        {'Node': 8, 'Connected_To': [12, 13]},\n        {'Node': 13, 'Connected_To': [8, 4, 11]},\n        {'Node': 11, 'Connected_To': [4, 13]},\n        {'Node': 3, 'Connected_To': [7, 9]},\n        {'Node': 9, 'Connected_To': [7, 3, 6]},\n        {'Node': 14, 'Connected_To': [16, 1]},\n        {'Node': 16, 'Connected_To': [14, 0]},\n        {'Node': 1, 'Connected_To': [14]},\n        {'Node': 0, 'Connected_To': [16, 6]},\n        {'Node': 6, 'Connected_To': [0, 9]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor edge in input_data['Edges']:\n    for connected_node in edge['Connected_To']:\n        G.add_edge(edge['Node'], connected_node)\n\n# Check if there is a path between node 4 and node 14\npath_exists = nx.has_path(G, 4, 14)\n\n# Output the result\nprint(f\"Is there a path between node 4 and node 14? {'Yes' if path_exists else 'No'}\")\n",
                "key_api": "networkx.Graph, Graph.add_nodes_from, Graph.add_edges_from, NetworkX has_path",
                "key_experience": "['Organize node and edge data into a format suitable for graph construction.', \"Use NetworkX's built-in functions for adding nodes and edges to ensure efficient graph construction.\", \"Utilize NetworkX's algorithm functions like `has_path` to check for connectivity between nodes.\", 'Ensure clarity and maintainability by structuring the code and comments adequately.']"
            }
        ]
    },
    {
        "id": 108,
        "problem": "Is there a directed path from node <8> to node <17>?",
        "graph_type": "directed",
        "experience": "The task was to check if there is a directed path from node <8> to node <17> using the input graph data. The graph was represented as a list of dictionaries where each dictionary contained a node and its connections. The solution involved using the NetworkX library to create a directed graph and then performing a path existence check.",
        "rag_data": [
            {
                "Section ID": "has_path",
                "Description": [
                    "Returns True if G has a path from source to target ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node": "Starting node for path",
                        "target : node": "Ending node for path"
                    }
                },
                "Rubrics": {}
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <1> is connected to nodes <0>, <16>.\nNode <0> is connected to nodes <16>, <3>, <13>.\nNode <16> is connected to nodes <4>, <1>, <10>, <9>.\nNode <17> is connected to nodes <11>, <1>.\nNode <3> is connected to nodes <14>, <0>, <12>.\nNode <14> is connected to nodes <4>, <8>.\nNode <12> is connected to nodes <4>, <5>, <6>, <9>, <15>, <16>.\nNode <13> is connected to nodes <14>, <15>, <7>, <3>.\nNode <15> is connected to nodes <16>, <2>, <12>, <4>, <3>.\nNode <7> is connected to nodes <8>, <14>, <6>, <0>, <9>, <15>, <16>, <2>, <4>.\nNode <10> is connected to nodes <8>, <9>.\nNode <8> is connected to nodes <6>, <16>, <12>, <4>.\nNode <9> is connected to nodes <2>, <11>, <10>, <5>.\nNode <6> is connected to nodes <0>, <15>.\nNode <4> is connected to nodes <1>, <3>, <8>, <16>, <2>.\nNode <5> is connected to nodes <0>, <9>, <16>, <14>.\nNode <2> is connected to nodes <4>, <3>, <13>, <10>, <14>, <5>, <15>.\nIs there a directed path from node <8> to node <17>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ndata = {\n    'Nodes': [\n        {'Node': 1, 'Connections': [0, 16]},\n        {'Node': 0, 'Connections': [16, 3, 13]},\n        {'Node': 16, 'Connections': [4, 1, 10, 9]},\n        {'Node': 17, 'Connections': [11, 1]},\n        {'Node': 3, 'Connections': [14, 0, 12]},\n        {'Node': 14, 'Connections': [4, 8]},\n        {'Node': 12, 'Connections': [4, 5, 6, 9, 15, 16]},\n        {'Node': 13, 'Connections': [14, 15, 7, 3]},\n        {'Node': 15, 'Connections': [16, 2, 12, 4, 3]},\n        {'Node': 7, 'Connections': [8, 14, 6, 0, 9, 15, 16, 2, 4]},\n        {'Node': 10, 'Connections': [8, 9]},\n        {'Node': 8, 'Connections': [6, 16, 12, 4]},\n        {'Node': 9, 'Connections': [2, 11, 10, 5]},\n        {'Node': 6, 'Connections': [0, 15]},\n        {'Node': 4, 'Connections': [1, 3, 8, 16, 2]},\n        {'Node': 5, 'Connections': [0, 9, 16, 14]},\n        {'Node': 2, 'Connections': [4, 3, 13, 10, 14, 5, 15]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check for a directed path from node 8 to node 17\npath_exists = nx.has_path(G, 8, 17)\n\n# Output the result\nprint(f\"Is there a directed path from node 8 to node 17? {'Yes' if path_exists else 'No'}\")\n",
                "key_api": "networkx.DiGraph, networkx.has_path",
                "key_experience": "1. Parsing input data to extract nodes and edges, 2. Creating a directed graph using NetworkX, 3. Utilizing NetworkX's built-in method to check for path existence."
            }
        ]
    },
    {
        "id": 109,
        "problem": "Is there a directed path from node <11> to node <15>?",
        "graph_type": "directed",
        "experience": "The task involved checking for a directed path between two nodes in a graph. The user provided a set of nodes and directed edges, and the aim was to determine if there is a path from node 11 to node 15 using Python code. NetworkX library was utilized for this purpose.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <2> is connected to node <14>.\nNode <5> is connected to nodes <0>, <17>.\nNode <0> is connected to node <14>.\nNode <17> is connected to nodes <10>, <14>.\nNode <11> is connected to node <4>.\nNode <4> is connected to node <0>.\nNode <16> is connected to node <19>.\nNode <19> is connected to nodes <15>, <6>.\nNode <6> is connected to nodes <18>, <9>, <0>.\nNode <18> is connected to nodes <9>, <19>, <8>.\nNode <9> is connected to nodes <1>, <15>, <6>, <12>.\nNode <8> is connected to node <13>.\nNode <7> is connected to nodes <19>, <18>.\nNode <13> is connected to nodes <5>, <6>, <12>.\nNode <10> is connected to node <3>.\nNode <1> is connected to nodes <9>, <19>.\nNode <15> is connected to nodes <11>, <12>.\nIs there a directed path from node <11> to node <15>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided nodes and edges\nnodes = [2, 14, 5, 0, 17, 11, 4, 16, 19, 15, 6, 18, 9, 8, 7, 13, 10, 1]\nedges = [\n    {'from': 2, 'to': 14}, {'from': 5, 'to': 0}, {'from': 5, 'to': 17},\n    {'from': 0, 'to': 14}, {'from': 17, 'to': 10}, {'from': 17, 'to': 14},\n    {'from': 11, 'to': 4}, {'from': 4, 'to': 0}, {'from': 16, 'to': 19},\n    {'from': 19, 'to': 15}, {'from': 19, 'to': 6}, {'from': 6, 'to': 18},\n    {'from': 6, 'to': 9}, {'from': 6, 'to': 0}, {'from': 18, 'to': 9},\n    {'from': 18, 'to': 19}, {'from': 18, 'to': 8}, {'from': 9, 'to': 1},\n    {'from': 9, 'to': 15}, {'from': 9, 'to': 6}, {'from': 9, 'to': 12},\n    {'from': 8, 'to': 13}, {'from': 7, 'to': 19}, {'from': 7, 'to': 18},\n    {'from': 13, 'to': 5}, {'from': 13, 'to': 6}, {'from': 13, 'to': 12},\n    {'from': 10, 'to': 3}, {'from': 1, 'to': 9}, {'from': 1, 'to': 19},\n    {'from': 15, 'to': 11}, {'from': 15, 'to': 12}\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(nodes)\nfor edge in edges:\n    G.add_edge(edge['from'], edge['to'])\n\n# Check for a directed path from node 11 to node 15\npath_exists = nx.has_path(G, 11, 15)\n\n# Output the result\nprint(f\"Is there a directed path from node 11 to node 15? {'Yes' if path_exists else 'No'}\")\n",
                "key_api": "networkx",
                "key_experience": "1. Represent the graph using nodes and directed edges.\n2. Use NetworkX to create a directed graph and add edges.\n3. Utilize the `has_path` function from NetworkX to check for existence of a path."
            }
        ]
    },
    {
        "id": 110,
        "problem": "Calculate the number of common neighbors of node <9> and node <2> considering successors as neighbors.",
        "graph_type": "directed",
        "experience": "Based on the task of calculating the number of common neighbors for two specific nodes in a given graph, the approach taken effectively uses the NetworkX library to model and solve this graph problem. The key steps involved defining the graph structure from the input data, initializing a NetworkX DiGraph (Directed Graph), adding nodes and edges to the graph, and finally computing the common neighbors of the specified nodes.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <4> is connected to nodes <7>, <3>, <9>, <13>.\nNode <3> is connected to nodes <8>, <11>.\nNode <9> is connected to nodes <14>, <10>, <1>, <17>.\nNode <12> is connected to nodes <7>, <9>.\nNode <6> is connected to nodes <1>, <9>, <4>, <12>.\nNode <1> is connected to nodes <18>, <9>.\nNode <2> is connected to nodes <15>, <4>, <6>.\nNode <15> is connected to nodes <6>, <14>.\nNode <16> is connected to node <11>.\nNode <11> is connected to nodes <17>, <2>, <0>, <7>.\nNode <0> is connected to nodes <10>, <7>, <13>.\nNode <10> is connected to nodes <8>, <11>, <3>, <6>.\nNode <14> is connected to nodes <8>, <2>.\nNode <18> is connected to node <5>.\nNode <17> is connected to nodes <3>, <2>, <14>, <8>, <15>.\nNode <5> is connected to nodes <9>, <4>, <2>, <17>.\nCalculate the number of common neighbors of node <9> and node <2>. In the context of a directed graph, we consider a node's successors as its neighbors. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [\n        {'Node': 4, 'Connections': [7, 3, 9, 13]},\n        {'Node': 3, 'Connections': [8, 11]},\n        {'Node': 9, 'Connections': [14, 10, 1, 17]},\n        {'Node': 12, 'Connections': [7, 9]},\n        {'Node': 6, 'Connections': [1, 9, 4, 12]},\n        {'Node': 1, 'Connections': [18, 9]},\n        {'Node': 2, 'Connections': [15, 4, 6]},\n        {'Node': 15, 'Connections': [6, 14]},\n        {'Node': 16, 'Connections': [11]},\n        {'Node': 11, 'Connections': [17, 2, 0, 7]},\n        {'Node': 0, 'Connections': [10, 7, 13]},\n        {'Node': 10, 'Connections': [8, 11, 3, 6]},\n        {'Node': 14, 'Connections': [8, 2]},\n        {'Node': 18, 'Connections': [5]},\n        {'Node': 17, 'Connections': [3, 2, 14, 8, 15]},\n        {'Node': 5, 'Connections': [9, 4, 2, 17]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and their connections to the graph\nfor node in graph_data['Nodes']:\n    G.add_node(node['Node'])\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Function to calculate common successors (neighbors)\ndef common_successors_count(G, node_a, node_b):\n    # Get successors of both nodes\n    successors_a = set(G.successors(node_a))\n    successors_b = set(G.successors(node_b))\n    \n    # Calculate common successors\n    common_successors = successors_a.intersection(successors_b)\n    \n    return len(common_successors)\n\n# Calculate the number of common neighbors for nodes 9 and 2\nnode_9 = 9\nnode_2 = 2\ncommon_neighbors_count = common_successors_count(G, node_9, node_2)\n\n# Output the result\nprint(f\"Number of common neighbors of node {node_9} and node {node_2}: {common_neighbors_count}\")\n",
                "key_api": "NetworkX library, specifically the functions DiGraph, add_edges_from, successors, and set intersection operations.",
                "key_experience": "1. Initialize a Directed Graph using NetworkX for correctly modeling directed relationships.\n2. Add nodes and their connections (edges) to the graph one node at a time.\n3. Use set operations to efficiently find the common neighbors between two sets of successors.\n4. Ensure the code is modular and uses clear variable naming for readability.\n5. Embed the solution within a formatted Python code block for easy extraction and execution."
            }
        ]
    },
    {
        "id": 111,
        "problem": "Calculate the number of common neighbors of node <9> and node <13> considering successors as neighbors.",
        "graph_type": "directed",
        "experience": "The task involved calculating the number of common neighbors between two nodes in a graph, considering successors as neighbors. The process is effectively handled using the NetworkX library in Python, which provides robust functionalities for graph manipulation and analysis. The solution steps included creating a directed graph, adding nodes and their connections, and then computing the intersection of neighbors for the specified nodes. This ensures accurate and efficient result generation.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <6> is connected to nodes <12>, <5>, <4>, <3>, <8>, <11>, <15>.\nNode <12> is connected to nodes <7>, <1>, <2>, <3>, <10>, <8>, <9>, <16>.\nNode <5> is connected to nodes <4>, <14>, <10>, <13>, <9>, <16>, <12>, <1>.\nNode <4> is connected to nodes <14>, <0>, <1>, <5>, <2>.\nNode <3> is connected to nodes <8>, <11>, <16>, <7>, <1>.\nNode <8> is connected to nodes <11>, <16>, <6>, <7>, <5>, <2>, <4>, <14>.\nNode <11> is connected to nodes <16>, <12>, <2>, <4>, <3>, <10>, <8>, <9>.\nNode <15> is connected to nodes <5>, <16>.\nNode <7> is connected to nodes <5>, <3>, <10>, <9>, <15>, <6>.\nNode <1> is connected to nodes <2>, <10>, <8>, <16>, <6>.\nNode <2> is connected to nodes <8>, <0>, <6>, <7>.\nNode <10> is connected to nodes <9>, <11>, <15>, <7>, <5>, <2>, <14>.\nNode <9> is connected to nodes <11>, <6>, <12>, <1>, <4>, <10>, <8>.\nNode <16> is connected to nodes <15>, <0>, <12>, <5>, <2>, <3>, <14>, <11>.\nNode <14> is connected to nodes <11>, <0>, <4>.\nNode <13> is connected to nodes <16>, <12>, <2>, <3>.\nNode <0> is connected to nodes <12>, <7>, <4>, <10>, <13>, <8>, <11>, <15>.\nCalculate the number of common neighbors of node <9> and node <13>. In the context of a directed graph, we consider a node's successors as its neighbors. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 6, 'Connections': [12, 5, 4, 3, 8, 11, 15]},\n        {'Node': 12, 'Connections': [7, 1, 2, 3, 10, 8, 9, 16]},\n        {'Node': 5, 'Connections': [4, 14, 10, 13, 9, 16, 12, 1]},\n        {'Node': 4, 'Connections': [14, 0, 1, 5, 2]},\n        {'Node': 3, 'Connections': [8, 11, 16, 7, 1]},\n        {'Node': 8, 'Connections': [11, 16, 6, 7, 5, 2, 4, 14]},\n        {'Node': 11, 'Connections': [16, 12, 2, 4, 3, 10, 8, 9]},\n        {'Node': 15, 'Connections': [5, 16]},\n        {'Node': 7, 'Connections': [5, 3, 10, 9, 15, 6]},\n        {'Node': 1, 'Connections': [2, 10, 8, 16, 6]},\n        {'Node': 2, 'Connections': [8, 0, 6, 7]},\n        {'Node': 10, 'Connections': [9, 11, 15, 7, 5, 2, 14]},\n        {'Node': 9, 'Connections': [11, 6, 12, 1, 4, 10, 8]},\n        {'Node': 16, 'Connections': [15, 0, 12, 5, 2, 3, 14, 11]},\n        {'Node': 14, 'Connections': [11, 0, 4]},\n        {'Node': 13, 'Connections': [16, 12, 2, 3]},\n        {'Node': 0, 'Connections': [12, 7, 4, 10, 13, 8, 11, 15]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Find successors of nodes 9 and 13\nsuccessors_9 = set(G.successors(9))\nsuccessors_13 = set(G.successors(13))\n\n# Calculate common neighbors\ncommon_neighbors = successors_9.intersection(successors_13)\nnum_common_neighbors = len(common_neighbors)\n\n# Output the result\nprint(f\"Number of common neighbors of node 9 and node 13: {num_common_neighbors}\")\n",
                "key_api": "NetworkX library, specifically the nx.DiGraph() function for creating directed graphs and the neighbors() method for accessing node neighbors.",
                "key_experience": "1. Use appropriate data structures (dictionaries, lists) to represent graph nodes and their connections. 2. Leverage specialized graph libraries (NetworkX) for handling complex graph operations. 3. Modularize the code to separate data preparation from graph operations, enhancing readability and maintainability."
            }
        ]
    },
    {
        "id": 112,
        "problem": "Calculate the number of common neighbors of node <9> and node <13>",
        "graph_type": "undirected",
        "experience": "To calculate the number of common neighbors for nodes in a graph, initialize the graph using node and connection information, then count the common elements in the neighbors list of the specified nodes.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <4> is connected to nodes <0>, <9>, <14>, <15>, <8>, <11>, <16>, <5>, <17>, <13>, <1>, <10>.\nNode <0> is connected to nodes <4>, <14>, <2>, <15>, <12>, <16>, <1>, <3>, <7>.\nNode <9> is connected to nodes <4>, <14>, <2>, <15>, <8>, <12>, <5>, <17>, <13>, <3>, <7>.\nNode <14> is connected to nodes <4>, <6>, <0>, <9>, <2>, <15>, <8>, <12>, <16>, <5>, <17>, <13>, <3>.\nNode <15> is connected to nodes <4>, <6>, <0>, <9>, <14>, <2>, <8>, <16>, <5>, <13>, <10>, <3>.\nNode <8> is connected to nodes <4>, <6>, <9>, <14>, <15>, <5>, <17>, <13>, <10>, <3>.\nNode <11> is connected to nodes <4>, <2>, <16>, <17>, <13>.\nNode <16> is connected to nodes <4>, <6>, <0>, <14>, <15>, <11>, <12>, <5>, <17>, <1>, <10>, <3>, <7>.\nNode <5> is connected to nodes <4>, <6>, <9>, <14>, <2>, <15>, <8>, <12>, <16>, <13>, <1>, <3>, <7>.\nNode <17> is connected to nodes <4>, <6>, <9>, <14>, <2>, <8>, <11>, <16>, <10>, <7>.\nNode <13> is connected to nodes <4>, <9>, <14>, <2>, <15>, <8>, <11>, <12>, <5>, <3>, <7>.\nNode <1> is connected to nodes <4>, <0>, <2>, <16>, <5>, <10>, <7>.\nNode <10> is connected to nodes <4>, <6>, <15>, <8>, <12>, <16>, <17>, <1>, <3>, <7>.\nNode <6> is connected to nodes <14>, <2>, <15>, <8>, <12>, <16>, <5>, <17>, <10>, <7>.\nNode <2> is connected to nodes <6>, <0>, <9>, <14>, <15>, <11>, <5>, <17>, <13>, <1>, <3>, <7>.\nNode <12> is connected to nodes <6>, <0>, <9>, <14>, <16>, <5>, <13>, <10>, <3>, <7>.\nNode <7> is connected to nodes <6>, <0>, <9>, <2>, <12>, <16>, <5>, <17>, <13>, <1>, <10>.\nNode <3> is connected to nodes <0>, <9>, <14>, <2>, <15>, <8>, <12>, <16>, <5>, <13>, <10>.\nCalculate the number of common neighbors of node <9> and node <13>. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\nnodes_info = [\n    {'Node': 4, 'Connections': [0, 9, 14, 15, 8, 11, 16, 5, 17, 13, 1, 10]},\n    {'Node': 0, 'Connections': [4, 14, 2, 15, 12, 16, 1, 3, 7]},\n    {'Node': 9, 'Connections': [4, 14, 2, 15, 8, 12, 5, 17, 13, 3, 7]},\n    {'Node': 14, 'Connections': [4, 6, 0, 9, 2, 15, 8, 12, 16, 5, 17, 13, 3]},\n    {'Node': 15, 'Connections': [4, 6, 0, 9, 14, 2, 8, 16, 5, 13, 10, 3]},\n    {'Node': 8, 'Connections': [4, 6, 9, 14, 15, 5, 17, 13, 10, 3]},\n    {'Node': 11, 'Connections': [4, 2, 16, 17, 13]},\n    {'Node': 16, 'Connections': [4, 6, 0, 14, 15, 11, 12, 5, 17, 1, 10, 3, 7]},\n    {'Node': 5, 'Connections': [4, 6, 9, 14, 2, 15, 8, 12, 16, 13, 1, 3, 7]},\n    {'Node': 17, 'Connections': [4, 6, 9, 14, 2, 8, 11, 16, 10, 7]},\n    {'Node': 13, 'Connections': [4, 9, 14, 2, 15, 8, 11, 12, 5, 3, 7]},\n    {'Node': 1, 'Connections': [4, 0, 2, 16, 5, 10, 7]},\n    {'Node': 10, 'Connections': [4, 6, 15, 8, 12, 16, 17, 1, 3, 7]},\n    {'Node': 6, 'Connections': [14, 2, 15, 8, 12, 16, 5, 17, 10, 7]},\n    {'Node': 2, 'Connections': [6, 0, 9, 14, 15, 11, 5, 17, 13, 1, 3, 7]},\n    {'Node': 12, 'Connections': [6, 0, 9, 14, 16, 5, 13, 10, 3, 7]},\n    {'Node': 7, 'Connections': [6, 0, 9, 2, 12, 16, 5, 17, 13, 1, 10]},\n    {'Node': 3, 'Connections': [0, 9, 14, 2, 15, 8, 12, 16, 5, 13, 10]}\n]\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and their connections to the graph\nfor node_info in nodes_info:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    G.add_node(node)\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate the common neighbors between node 9 and node 13\ncommon_neighbors = list(nx.common_neighbors(G, 9, 13))\nnum_common_neighbors = len(common_neighbors)\n\n# Output the result\nprint(f'Number of common neighbors between node 9 and node 13: {num_common_neighbors}')\n",
                "key_api": "networkx",
                "key_experience": "1. Parse the input data to extract node and connection information. 2. Use networkx to create and manage the graph. 3. Retrieve the neighbors of the specified nodes. 4. Compute the intersection of these neighbor lists to find common neighbors. 5. Verify and validate the results to ensure accuracy."
            }
        ]
    },
    {
        "id": 113,
        "problem": "Calculate the number of common neighbors of node <16> and node <2>",
        "graph_type": "undirected",
        "experience": "In this engagement, we encountered a problem where we needed to calculate the number of common neighbors between two nodes in a graph. By extracting the graph data and utilizing the NetworkX library, we were able to develop a solution efficiently.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <8>, <1>.\nNode <8> is connected to nodes <0>, <10>.\nNode <1> is connected to node <0>.\nNode <10> is connected to nodes <8>, <15>.\nNode <3> is connected to nodes <5>, <11>.\nNode <5> is connected to nodes <3>, <17>.\nNode <11> is connected to nodes <3>, <16>.\nNode <17> is connected to nodes <5>, <14>, <18>.\nNode <14> is connected to nodes <17>, <4>.\nNode <4> is connected to node <14>.\nNode <18> is connected to node <17>.\nNode <6> is connected to nodes <15>, <16>.\nNode <15> is connected to nodes <6>, <10>, <9>, <13>.\nNode <16> is connected to nodes <6>, <11>.\nNode <9> is connected to nodes <15>, <12>.\nNode <13> is connected to nodes <15>, <7>, <12>.\nNode <7> is connected to nodes <13>, <2>.\nNode <2> is connected to node <7>.\nNode <12> is connected to nodes <13>, <9>.\nCalculate the number of common neighbors of node <16> and node <2>. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [\n        {'Node': 0, 'Connections': [8, 1]},\n        {'Node': 8, 'Connections': [0, 10]},\n        {'Node': 1, 'Connections': [0]},\n        {'Node': 10, 'Connections': [8, 15]},\n        {'Node': 3, 'Connections': [5, 11]},\n        {'Node': 5, 'Connections': [3, 17]},\n        {'Node': 11, 'Connections': [3, 16]},\n        {'Node': 17, 'Connections': [5, 14, 18]},\n        {'Node': 14, 'Connections': [17, 4]},\n        {'Node': 4, 'Connections': [14]},\n        {'Node': 18, 'Connections': [17]},\n        {'Node': 6, 'Connections': [15, 16]},\n        {'Node': 15, 'Connections': [6, 10, 9, 13]},\n        {'Node': 16, 'Connections': [6, 11]},\n        {'Node': 9, 'Connections': [15, 12]},\n        {'Node': 13, 'Connections': [15, 7, 12]},\n        {'Node': 7, 'Connections': [13, 2]},\n        {'Node': 2, 'Connections': [7]},\n        {'Node': 12, 'Connections': [13, 9]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node in graph_data['Nodes']:\n    G.add_node(node['Node'])\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate the common neighbors of node 16 and node 2\ncommon_neighbors = list(nx.common_neighbors(G, 16, 2))\nnumber_of_common_neighbors = len(common_neighbors)\n\n# Output the result (the number of common neighbors)\nprint(f\"Number of common neighbors between node 16 and node 2: {number_of_common_neighbors}\")\n",
                "key_api": "networkx",
                "key_experience": "1. Parse the input data to extract node and connection information. 2. Use NetworkX to model the graph. 3. Utilize set operations to find common neighbors. 4. Return or print the required output."
            }
        ]
    },
    {
        "id": 114,
        "problem": "What is the out-degree of node <7>?",
        "graph_type": "directed",
        "experience": "When solving graph-related problems, it is beneficial to use libraries like NetworkX to handle graph construction and analyze graph properties. In the given task, the objective was to identify the out-degree of a specified node (node 7). The process involves parsing the input data, constructing the graph, and then utilizing NetworkX's built-in methods to determine the out-degree.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <12> is connected to nodes <9>, <0>, <6>.\nNode <9> is connected to nodes <8>, <16>.\nNode <0> is connected to nodes <14>, <5>.\nNode <6> is connected to nodes <8>, <12>, <10>.\nNode <13> is connected to nodes <11>, <14>, <2>, <7>, <10>.\nNode <11> is connected to nodes <10>, <13>.\nNode <2> is connected to node <4>.\nNode <7> is connected to nodes <10>, <13>.\nNode <10> is connected to nodes <6>, <4>.\nNode <5> is connected to node <1>.\nNode <1> is connected to nodes <5>, <4>, <3>.\nNode <4> is connected to node <12>.\nNode <15> is connected to nodes <9>, <0>, <11>, <2>.\nNode <16> is connected to nodes <0>, <12>, <13>, <3>, <2>.\nNode <8> is connected to node <16>.\nWhat is the out-degree of node <7>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the input\ngraph_data = {\n    'Nodes': [\n        {'Node': 12, 'Connections': [9, 0, 6]},\n        {'Node': 9, 'Connections': [8, 16]},\n        {'Node': 0, 'Connections': [14, 5]},\n        {'Node': 6, 'Connections': [8, 12, 10]},\n        {'Node': 13, 'Connections': [11, 14, 2, 7, 10]},\n        {'Node': 11, 'Connections': [10, 13]},\n        {'Node': 2, 'Connections': [4]},\n        {'Node': 7, 'Connections': [10, 13]},\n        {'Node': 10, 'Connections': [6, 4]},\n        {'Node': 5, 'Connections': [1]},\n        {'Node': 1, 'Connections': [5, 4, 3]},\n        {'Node': 4, 'Connections': [12]},\n        {'Node': 15, 'Connections': [9, 0, 11, 2]},\n        {'Node': 16, 'Connections': [0, 12, 13, 3, 2]},\n        {'Node': 8, 'Connections': [16]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the connections\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate the out-degree of node 7\nout_degree_node_7 = G.out_degree(7)\n\n# Output the result (printing is not required as per the output format)\nprint(out_degree_node_7)\n",
                "key_api": "NetworkX",
                "key_experience": "1. Parse the input data correctly to extract nodes and their connections.\n2. Use appropriate graph construction methods provided by NetworkX, in this case, creating a directed graph using `nx.DiGraph()`.\n3. Utilize NetworkX's functionality to determine the required graph properties, for example, `G.out_degree(node)` to find the out-degree of a node.\n4. Ensure that the code is formatted correctly for easy readability and extraction."
            }
        ]
    },
    {
        "id": 115,
        "problem": "What is the out-degree of node <2>?",
        "graph_type": "directed",
        "experience": "In this task, the AI was asked to determine the out-degree of a specified node in a graph structure. The following steps were taken to solve the problem: \n1. Interpreted the input data format which included nodes and their connections. \n2. Utilized the NetworkX library to model the graph and perform operations. \n3. Defined the graph using the data provided. \n4. Calculated the out-degree of the specified node using built-in functions in NetworkX.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <15> is connected to nodes <5>, <4>, <14>, <17>, <1>, <3>, <12>, <6>.\nNode <5> is connected to nodes <2>, <4>, <14>, <17>, <1>, <0>, <6>, <15>.\nNode <4> is connected to nodes <9>, <14>, <0>, <3>.\nNode <14> is connected to nodes <1>, <10>, <13>, <3>, <7>, <12>, <6>, <15>, <5>.\nNode <17> is connected to nodes <1>, <10>, <12>, <2>, <4>, <9>, <8>.\nNode <1> is connected to nodes <0>, <10>, <3>, <5>, <9>, <14>.\nNode <3> is connected to nodes <7>, <6>, <15>, <4>, <13>.\nNode <12> is connected to nodes <2>, <1>.\nNode <6> is connected to nodes <15>, <1>, <10>, <7>.\nNode <2> is connected to nodes <4>, <9>, <17>, <0>, <7>, <6>.\nNode <0> is connected to nodes <3>, <1>.\nNode <9> is connected to nodes <14>, <17>, <16>, <13>, <3>, <15>.\nNode <7> is connected to nodes <4>, <0>, <16>, <13>, <3>.\nNode <16> is connected to nodes <3>, <6>, <2>, <4>.\nNode <13> is connected to nodes <5>, <4>, <1>.\nNode <8> is connected to nodes <1>, <16>, <5>.\nNode <10> is connected to nodes <2>, <9>, <17>, <1>.\nNode <11> is connected to nodes <15>, <5>, <4>, <17>, <13>, <7>, <6>.\nWhat is the out-degree of node <2>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the provided input\ngraph_data = {\n    'Nodes': [\n        {'Node': 15, 'Connections': [5, 4, 14, 17, 1, 3, 12, 6]},\n        {'Node': 5, 'Connections': [2, 4, 14, 17, 1, 0, 6, 15]},\n        {'Node': 4, 'Connections': [9, 14, 0, 3]},\n        {'Node': 14, 'Connections': [1, 10, 13, 3, 7, 12, 6, 15, 5]},\n        {'Node': 17, 'Connections': [1, 10, 12, 2, 4, 9, 8]},\n        {'Node': 1, 'Connections': [0, 10, 3, 5, 9, 14]},\n        {'Node': 3, 'Connections': [7, 6, 15, 4, 13]},\n        {'Node': 12, 'Connections': [2, 1]},\n        {'Node': 6, 'Connections': [15, 1, 10, 7]},\n        {'Node': 2, 'Connections': [4, 9, 17, 0, 7, 6]},\n        {'Node': 0, 'Connections': [3, 1]},\n        {'Node': 9, 'Connections': [14, 17, 16, 13, 3, 15]},\n        {'Node': 7, 'Connections': [4, 0, 16, 13, 3]},\n        {'Node': 16, 'Connections': [3, 6, 2, 4]},\n        {'Node': 13, 'Connections': [5, 4, 1]},\n        {'Node': 8, 'Connections': [1, 16, 5]},\n        {'Node': 10, 'Connections': [2, 9, 17, 1]},\n        {'Node': 11, 'Connections': [15, 5, 4, 17, 13, 7, 6]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the connections\nfor node in graph_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Get the out-degree of node 2\nout_degree_node_2 = G.out_degree(2)\n\n# Print the out-degree\nprint(f\"The out-degree of node 2 is: {out_degree_node_2}\")\n",
                "key_api": "NetworkX",
                "key_experience": "1. Used a well-established library (NetworkX) for graph operations. \n2. Structured data input and graph creation methodically. \n3. Leveraged built-in functions for efficient calculation of graph properties."
            }
        ]
    },
    {
        "id": 116,
        "problem": "What is the degree of node <8>?",
        "graph_type": "undirected",
        "experience": "Worked with user to write Python code that identifies the degree of a specific node in a given graph input. Utilized NetworkX library to build and analyze the graph.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <14> is connected to nodes <2>, <7>, <16>, <1>, <12>, <15>, <9>, <0>, <3>.\nNode <2> is connected to nodes <14>, <1>, <6>.\nNode <7> is connected to nodes <14>, <5>, <1>, <8>, <11>, <3>, <16>.\nNode <16> is connected to nodes <14>, <18>, <7>, <8>, <13>, <10>.\nNode <1> is connected to nodes <14>, <2>, <4>, <5>, <19>, <3>, <7>, <13>, <10>, <17>, <15>.\nNode <12> is connected to nodes <14>, <19>, <13>.\nNode <15> is connected to nodes <14>, <1>, <6>.\nNode <9> is connected to nodes <14>, <4>, <6>.\nNode <0> is connected to nodes <14>, <18>, <6>.\nNode <3> is connected to nodes <14>, <1>, <7>, <8>.\nNode <6> is connected to nodes <2>, <18>, <0>, <4>, <19>, <11>, <15>, <9>, <13>, <17>, <10>.\nNode <18> is connected to nodes <0>, <16>, <6>, <13>.\nNode <13> is connected to nodes <18>, <4>, <1>, <19>, <16>, <6>, <12>, <17>.\nNode <4> is connected to nodes <5>, <13>, <1>, <6>, <9>.\nNode <5> is connected to nodes <4>, <1>, <7>.\nNode <19> is connected to nodes <1>, <10>, <12>, <6>, <13>.\nNode <10> is connected to nodes <1>, <19>, <11>, <16>, <6>.\nNode <17> is connected to nodes <1>, <6>, <13>.\nNode <8> is connected to nodes <7>, <16>, <3>.\nNode <11> is connected to nodes <7>, <10>, <6>.\nWhat is the degree of node <8>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 14, 'Connections': [2, 7, 16, 1, 12, 15, 9, 0, 3]},\n        {'Node': 2, 'Connections': [14, 1, 6]},\n        {'Node': 7, 'Connections': [14, 5, 1, 8, 11, 3, 16]},\n        {'Node': 16, 'Connections': [14, 18, 7, 8, 13, 10]},\n        {'Node': 1, 'Connections': [14, 2, 4, 5, 19, 3, 7, 13, 10, 17, 15]},\n        {'Node': 12, 'Connections': [14, 19, 13]},\n        {'Node': 15, 'Connections': [14, 1, 6]},\n        {'Node': 9, 'Connections': [14, 4, 6]},\n        {'Node': 0, 'Connections': [14, 18, 6]},\n        {'Node': 3, 'Connections': [14, 1, 7, 8]},\n        {'Node': 6, 'Connections': [2, 18, 0, 4, 19, 11, 15, 9, 13, 17, 10]},\n        {'Node': 18, 'Connections': [0, 16, 6, 13]},\n        {'Node': 13, 'Connections': [18, 4, 1, 19, 16, 6, 12, 17]},\n        {'Node': 4, 'Connections': [5, 13, 1, 6, 9]},\n        {'Node': 5, 'Connections': [4, 1, 7]},\n        {'Node': 19, 'Connections': [1, 10, 12, 6, 13]},\n        {'Node': 10, 'Connections': [1, 19, 11, 16, 6]},\n        {'Node': 17, 'Connections': [1, 6, 13]},\n        {'Node': 8, 'Connections': [7, 16, 3]},\n        {'Node': 11, 'Connections': [7, 10, 6]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node_info in input_data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    G.add_node(node)\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate the degree of node 8\ndegree_of_node_8 = G.degree(8)\n\n# Output the degree\nprint(f\"The degree of node 8 is: {degree_of_node_8}\")\n",
                "key_api": "networkx.Graph.add_nodes_from, networkx.Graph.add_edges_from, networkx.Graph.degree",
                "key_experience": "1. Read and parse input data correctly.\n2. Use NetworkX for graph-based operations.\n3. Construct the graph by adding nodes and edges.\n4. Query the desired node's degree using the NetworkX API.\n5. Handle edge cases and validate input data."
            }
        ]
    },
    {
        "id": 117,
        "problem": "What is the degree of node <7>?",
        "graph_type": "undirected",
        "experience": "The task involved determining the degree of a specific node in a graph. The user's input was a dictionary representing nodes and their connections. To solve this problem, the following steps were employed: 1. Construct the graph using NetworkX. 2. Populate the graph with nodes and edges based on the input data. 3. Use NetworkX's functionality to calculate the degree of the specified node. This approach efficiently utilized NetworkX's powerful graph handling capabilities to simplify the computation of node degrees.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <4> is connected to nodes <1>, <2>, <10>, <8>, <6>.\nNode <1> is connected to nodes <4>, <18>, <12>, <6>, <11>, <2>.\nNode <2> is connected to nodes <4>, <1>, <10>, <9>, <14>, <7>, <8>.\nNode <10> is connected to nodes <4>, <5>, <7>, <14>, <9>, <2>, <15>.\nNode <8> is connected to nodes <4>, <2>, <17>, <9>, <12>, <0>, <16>.\nNode <6> is connected to nodes <4>, <1>, <7>, <3>, <0>.\nNode <18> is connected to nodes <1>, <13>, <3>, <7>, <12>.\nNode <12> is connected to nodes <1>, <18>, <17>, <7>, <13>, <8>.\nNode <11> is connected to nodes <1>, <9>, <15>, <0>, <16>.\nNode <5> is connected to nodes <10>, <17>, <7>, <13>, <3>, <15>.\nNode <7> is connected to nodes <10>, <5>, <2>, <18>, <17>, <12>, <6>.\nNode <14> is connected to nodes <10>, <2>, <15>, <16>.\nNode <9> is connected to nodes <10>, <2>, <11>, <8>, <3>, <16>, <15>.\nNode <15> is connected to nodes <10>, <5>, <9>, <14>, <0>, <11>.\nNode <17> is connected to nodes <5>, <7>, <3>, <12>, <0>, <13>, <8>.\nNode <13> is connected to nodes <5>, <18>, <17>, <12>, <0>.\nNode <3> is connected to nodes <5>, <18>, <17>, <9>, <0>, <6>.\nNode <0> is connected to nodes <17>, <13>, <3>, <15>, <11>, <16>, <8>, <6>.\nNode <16> is connected to nodes <9>, <14>, <0>, <11>, <8>.\nWhat is the degree of node <7>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': {\n        '4': [1, 2, 10, 8, 6],\n        '1': [4, 18, 12, 6, 11, 2],\n        '2': [4, 1, 10, 9, 14, 7, 8],\n        '10': [4, 5, 7, 14, 9, 2, 15],\n        '8': [4, 2, 17, 9, 12, 0, 16],\n        '6': [4, 1, 7, 3, 0],\n        '18': [1, 13, 3, 7, 12],\n        '12': [1, 18, 17, 7, 13, 8],\n        '11': [1, 9, 15, 0, 16],\n        '5': [10, 17, 7, 13, 3, 15],\n        '7': [10, 5, 2, 18, 17, 12, 6],\n        '14': [10, 2, 15, 16],\n        '9': [10, 2, 11, 8, 3, 16, 15],\n        '15': [10, 5, 9, 14, 0, 11],\n        '17': [5, 7, 3, 12, 0, 13, 8],\n        '13': [5, 18, 17, 12, 0],\n        '3': [5, 18, 17, 9, 0, 6],\n        '0': [17, 13, 3, 15, 11, 16, 8, 6],\n        '16': [9, 14, 0, 11, 8]\n    }\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node, neighbors in data['Nodes'].items():\n    for neighbor in neighbors:\n        G.add_edge(node, str(neighbor))  # Convert neighbor to string for consistency\n\n# Calculate the degree of node '7'\ndegree_of_node_7 = G.degree('7')\n\n# Output the degree\nprint(f\"The degree of node 7 is: {degree_of_node_7}\")\n",
                "key_api": "networkx.Graph, networkx.Graph.add_edges_from, networkx.Graph.degree",
                "key_experience": "1. Structure the input data clearly and comprehensively. 2. Leverage libraries like NetworkX for complex graph operations. 3. Write modular code to allow easy updates and scalability. 4. Validate the graph construction by ensuring all nodes and edges are accurately represented. 5. Use NetworkX's built-in methods to simplify common graph operations, such as calculating the degree of a node."
            }
        ]
    },
    {
        "id": 118,
        "problem": "Does the graph have a cycle?",
        "graph_type": "directed",
        "experience": "When approached with the task of determining whether a graph contains a cycle, the approach involved utilizing the NetworkX library. This involved converting the provided nodes and edges into a NetworkX graph representation and then utilizing built-in functions to detect cycles.",
        "rag_data": [
            {
                "Section ID": "cycle_basis",
                "Description": [
                    "Returns a list of cycles which form a basis for cycles of G.",
                    "A basis for cycles of a network is a minimal collection of\ncycles such that any cycle in the network can be written\nas a sum of cycles in the basis.  Here summation of cycles\nis defined as \u201cexclusive or\u201d of the edges. Cycle bases are\nuseful, e.g. when deriving equations for electric circuits\nusing Kirchhoff\u2019s Laws."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "",
                        "root : node, optional": "Specify starting node for basis."
                    },
                    "Returns:": {
                        "A list of cycle lists.  Each cycle list is a list of nodes": "",
                        "which forms a cycle (loop) in G.": ""
                    }
                },
                "Rubrics": {
                    "Notes": "This is adapted from algorithm CACM 491 [1] .",
                    "References": "[1]Paton, K. An algorithm for finding a fundamental set of\ncycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.",
                    "Examples": "G=nx.Graph()\nnx.add_cycle(G,[0,1,2,3])\nnx.add_cycle(G,[0,3,4,5])\nnx.cycle_basis(G,0)\n# [[3, 4, 5, 0], [1, 2, 3, 0]]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <17> is connected to nodes <0>, <8>, <4>, <3>, <1>.\nNode <0> is connected to nodes <1>, <9>.\nNode <8> is connected to nodes <7>, <5>.\nNode <4> is connected to nodes <9>, <5>, <1>.\nNode <3> is connected to nodes <12>, <9>, <8>, <5>, <10>.\nNode <16> is connected to node <1>.\nNode <12> is connected to nodes <15>, <14>.\nNode <5> is connected to nodes <1>, <13>, <0>, <10>, <15>.\nNode <15> is connected to nodes <13>, <0>, <14>.\nNode <14> is connected to node <13>.\nNode <7> is connected to nodes <11>, <4>, <13>.\nNode <11> is connected to node <10>.\nNode <13> is connected to node <9>.\nNode <6> is connected to nodes <16>, <9>, <0>, <4>.\nNode <2> is connected to nodes <5>, <8>, <12>, <11>.\nDoes the graph have a cycle? For a directed graph, a cycle is a closed path that traverses through a sequence of nodes and directed edges, eventually returning to the starting node. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 17, 'Connected_Nodes': [0, 8, 4, 3, 1]},\n        {'Node': 0, 'Connected_Nodes': [1, 9]},\n        {'Node': 8, 'Connected_Nodes': [7, 5]},\n        {'Node': 4, 'Connected_Nodes': [9, 5, 1]},\n        {'Node': 3, 'Connected_Nodes': [12, 9, 8, 5, 10]},\n        {'Node': 16, 'Connected_Nodes': [1]},\n        {'Node': 12, 'Connected_Nodes': [15, 14]},\n        {'Node': 5, 'Connected_Nodes': [1, 13, 0, 10, 15]},\n        {'Node': 15, 'Connected_Nodes': [13, 0, 14]},\n        {'Node': 14, 'Connected_Nodes': [13]},\n        {'Node': 7, 'Connected_Nodes': [11, 4, 13]},\n        {'Node': 11, 'Connected_Nodes': [10]},\n        {'Node': 13, 'Connected_Nodes': [9]},\n        {'Node': 6, 'Connected_Nodes': [16, 9, 0, 4]},\n        {'Node': 2, 'Connected_Nodes': [5, 8, 12, 11]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor node in data['Nodes']:\n    for connected_node in node['Connected_Nodes']:\n        G.add_edge(node['Node'], connected_node)\n\n# Check for cycles\nhas_cycle = nx.is_directed_acyclic_graph(G)\n\n# Output result\nif not has_cycle:\n    print(\"The graph has a cycle.\")\nelse:\n    print(\"The graph does not have a cycle.\")\n",
                "key_api": "networkx.cycle_basis, networkx.Graph",
                "key_experience": "['Converting input data into a graph structure suitable for processing', 'Using established libraries (NetworkX) to leverage well-tested and optimized functions for graph analysis', 'Using in-built functions such as cycle_basis to detect cycles']"
            }
        ]
    },
    {
        "id": 119,
        "problem": "Does the graph have a cycle?",
        "graph_type": "directed",
        "experience": "To solve the problem of detecting a cycle in a graph, we used Python and the NetworkX library. The key steps involved were: 1. Parsing the input data to construct the graph. 2. Using NetworkX functions to detect cycles in the graph. This approach ensures the implementation is efficient and leverages well-tested functionalities.",
        "rag_data": [
            {
                "Section ID": "find_cycle",
                "Description": [
                    "Returns a cycle found via depth-first traversal.",
                    "The cycle is a list of edges indicating the cyclic path.\nOrientation of directed edges is controlled by orientation ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A directed/undirected graph/multigraph.",
                        "source : node, list of nodes": "The node from which the traversal begins. If None, then a source\nis chosen arbitrarily and repeatedly until all edges from each node in\nthe graph are searched.",
                        "orientation : None | \u2018original\u2019 | \u2018reverse\u2019 | \u2018ignore\u2019 (default: None)": "For directed graphs and directed multigraphs, edge traversals need not\nrespect the original orientation of the edges.\nWhen set to \u2018reverse\u2019 every edge is traversed in the reverse direction.\nWhen set to \u2018ignore\u2019, every edge is treated as undirected.\nWhen set to \u2018original\u2019, every edge is treated as directed.\nIn all three cases, the yielded edge tuples add a last entry to\nindicate the direction in which that edge was traversed.\nIf orientation is None, the yielded edge has no direction indicated.\nThe direction is respected, but not reported."
                    },
                    "Returns:": {
                        "edges : directed edges": "A list of directed edges indicating the path taken for the loop.\nIf no cycle is found, then an exception is raised.\nFor graphs, an edge is of the form(u,v)whereuandvare the tail and head of the edge as determined by the traversal.\nFor multigraphs, an edge is of the form(u,v,key), wherekeyis\nthe key of the edge. When the graph is directed, thenuandvare always in the order of the actual directed edge.\nIf orientation is not None then the edge tuple is extended to include\nthe direction of traversal (\u2018forward\u2019 or \u2018reverse\u2019) on that edge."
                    },
                    "Raises:": {
                        "NetworkXNoCycle": "If no cycle was found."
                    }
                },
                "Rubrics": {
                    "Examples": "In this example, we construct a DAG and find, in the first call, that there\nare no directed cycles, and so an exception is raised. In the second call,\nwe ignore edge orientations and find that there is an undirected cycle.\nNote that the second call finds a directed cycle while effectively\ntraversing an undirected graph, and so, we found an \u201cundirected cycle\u201d.\nThis means that this DAG structure does not form a directed tree (which\nis also known as a polytree).\nG=nx.DiGraph([(0,1),(0,2),(1,2)])\nnx.find_cycle(G,orientation=\"original\")Traceback (most recent call last):    ...networkx.exception.NetworkXNoCycleNo cycle found.\nlist(nx.find_cycle(G,orientation=\"ignore\"))\n# [(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <3> is connected to nodes <5>, <18>, <4>.\nNode <4> is connected to node <14>.\nNode <7> is connected to nodes <4>, <1>, <15>.\nNode <1> is connected to nodes <9>, <5>.\nNode <15> is connected to nodes <14>, <11>, <3>, <17>.\nNode <14> is connected to node <17>.\nNode <19> is connected to nodes <13>, <10>, <11>, <0>, <5>.\nNode <13> is connected to node <17>.\nNode <10> is connected to nodes <9>, <1>, <0>, <4>, <18>, <7>.\nNode <11> is connected to node <13>.\nNode <0> is connected to node <12>.\nNode <17> is connected to node <18>.\nNode <9> is connected to nodes <5>, <8>, <16>.\nNode <8> is connected to node <13>.\nNode <16> is connected to node <18>.\nNode <6> is connected to nodes <8>, <2>, <4>, <18>.\nNode <2> is connected to nodes <15>, <3>.\nNode <12> is connected to nodes <11>, <4>, <15>, <6>, <16>.\nDoes the graph have a cycle? For a directed graph, a cycle is a closed path that traverses through a sequence of nodes and directed edges, eventually returning to the starting node. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [3, 5, 18, 4, 7, 1, 15, 14, 19, 13, 10, 11, 0, 17, 9, 8, 16, 6, 2, 12],\n    'Edges': [\n        {'from': 3, 'to': [5, 18, 4]},\n        {'from': 4, 'to': [14]},\n        {'from': 7, 'to': [4, 1, 15]},\n        {'from': 1, 'to': [9, 5]},\n        {'from': 15, 'to': [14, 11, 3, 17]},\n        {'from': 14, 'to': [17]},\n        {'from': 19, 'to': [13, 10, 11, 0, 5]},\n        {'from': 13, 'to': [17]},\n        {'from': 10, 'to': [9, 1, 0, 4, 18, 7]},\n        {'from': 11, 'to': [13]},\n        {'from': 0, 'to': [12]},\n        {'from': 17, 'to': [18]},\n        {'from': 9, 'to': [5, 8, 16]},\n        {'from': 8, 'to': [13]},\n        {'from': 16, 'to': [18]},\n        {'from': 6, 'to': [8, 2, 4, 18]},\n        {'from': 2, 'to': [15, 3]},\n        {'from': 12, 'to': [11, 4, 15, 6, 16]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes to the graph\nG.add_nodes_from(data['Nodes'])\n\n# Add edges to the graph\nfor edge in data['Edges']:\n    for target in edge['to']:\n        G.add_edge(edge['from'], target)\n\n# Check for cycles\nhas_cycle = nx.is_directed_acyclic_graph(G)\n\n# Output result\nif not has_cycle:\n    print(\"The graph has a cycle.\")\nelse:\n    print(\"The graph does not have a cycle.\")\n",
                "key_api": "NetworkX library, especially functions like `nx.DiGraph()` for constructing directed graphs and `nx.find_cycle()` to detect cycles.",
                "key_experience": "1. Parsing input data systematically to ensure the graph is constructed accurately. 2. Utilizing well-established libraries like NetworkX to leverage their optimized and tested functions. 3. Writing clear and reusable code by organizing input data processing and graph operations."
            }
        ]
    },
    {
        "id": 120,
        "problem": "Does the graph have a cycle?",
        "graph_type": "undirected",
        "experience": "When addressing the problem of detecting cycles in a graph, it is essential to use an efficient approach leveraging graph theory concepts. In this particular instance, the NetworkX library was chosen due to its comprehensive graph manipulation features and ease of use. The task involved initializing a directed graph with nodes and edges, followed by the implementation of cycle detection.\n\nKey steps to solve the problem:\n1. **Initialize the Graph:** Use the `nx.DiGraph()` constructor from the NetworkX library to create a directed graph instance.\n2. **Add Nodes and Edges:** Populate the graph using `G.add_nodes_from()` and `G.add_edges_from()` methods to add nodes and edges respectively from the provided input data.\n3. **Cycle Detection:** Utilize NetworkX's `nx.is_directed_acyclic_graph(G)` function to check if the graph contains a cycle. This function returns `False` if the graph has a cycle, and `True` otherwise.\n4. **Output Result:** Print a message indicating whether the graph has a cycle based on the result from the previous step.",
        "rag_data": [
            {
                "Section ID": "is_directed_acyclic_graph",
                "Description": [
                    "Returns True if the graph G is a directed acyclic graph (DAG) or\nFalse if not."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": ""
                    },
                    "Returns:": {
                        "bool": "True ifGis a DAG, False otherwise"
                    }
                },
                "Rubrics": {
                    "Examples": "Undirected graph:\nG=nx.Graph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected graph with cycle:\nG=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected acyclic graph:\nG=nx.DiGraph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# True"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <4>, <2>, <13>.\nNode <4> is connected to nodes <0>, <15>, <5>.\nNode <2> is connected to node <0>.\nNode <13> is connected to nodes <0>, <10>.\nNode <15> is connected to nodes <4>, <11>.\nNode <5> is connected to node <4>.\nNode <8> is connected to node <1>.\nNode <1> is connected to nodes <8>, <12>.\nNode <12> is connected to nodes <1>, <3>, <7>.\nNode <9> is connected to node <3>.\nNode <3> is connected to nodes <9>, <12>, <14>.\nNode <14> is connected to nodes <3>, <6>.\nNode <7> is connected to nodes <12>, <11>.\nNode <11> is connected to nodes <15>, <7>, <6>.\nNode <6> is connected to nodes <11>, <14>.\nNode <10> is connected to node <13>.\nDoes the graph have a cycle? For an undirected graph, a cycle is a closed path that traverses through a sequence of nodes and edges, eventually returning to the starting node. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    'Edges': [\n        [0, 4], [0, 2], [0, 13], [4, 15], [4, 5], [2, 0], [13, 10],\n        [15, 11], [5, 4], [8, 1], [1, 12], [12, 1], [12, 3], [12, 7],\n        [9, 3], [3, 9], [3, 12], [3, 14], [14, 6], [7, 12], [7, 11],\n        [11, 15], [11, 7], [11, 6], [6, 11], [6, 14], [10, 13]\n    ]\n}\n\n# Create a directed graph from the input data\nG = nx.DiGraph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Check for cycles in the graph\nhas_cycle = nx.is_directed_acyclic_graph(G)\n\n# Output the result\nif not has_cycle:\n    print(\"The graph has a cycle.\")\nelse:\n    print(\"The graph does not have a cycle.\")\n",
                "key_api": "The key API used in the code is the NetworkX library, specifically:\n- `nx.DiGraph()`: To create a directed graph.\n- `G.add_nodes_from(nodes)`: To add nodes to the graph.\n- `G.add_edges_from(edges)`: To add edges to the graph.\n- `nx.is_directed_acyclic_graph(G)`: To check if the graph is acyclic.",
                "key_experience": "Best practices observed in this task include:\n1. **Modular Code Structure:** Dividing the task into separate logical steps such as graph initialization, node and edge addition, cycle detection, and result output.\n2. **Effective Use of Libraries:** Leveraging the powerful and efficient NetworkX library for graph operations to minimize boilerplate code and ensure reliability.\n3. **Error Handling:** Although not explicitly mentioned, it's generally advisable to include error handling mechanisms to catch and handle potential issues during graph operations."
            }
        ]
    },
    {
        "id": 121,
        "problem": "Does the graph have a cycle?",
        "graph_type": "undirected",
        "experience": "When addressing the problem of detecting cycles in a graph, it is essential to use an efficient approach leveraging graph theory concepts. In this particular instance, the NetworkX library was chosen due to its comprehensive graph manipulation features and ease of use. The task involved initializing a directed graph with nodes and edges, followed by the implementation of cycle detection.\n\nKey steps to solve the problem:\n1. **Initialize the Graph:** Use the `nx.DiGraph()` constructor from the NetworkX library to create a directed graph instance.\n2. **Add Nodes and Edges:** Populate the graph using `G.add_nodes_from()` and `G.add_edges_from()` methods to add nodes and edges respectively from the provided input data.\n3. **Cycle Detection:** Utilize NetworkX's `nx.is_directed_acyclic_graph(G)` function to check if the graph contains a cycle. This function returns `False` if the graph has a cycle, and `True` otherwise.\n4. **Output Result:** Print a message indicating whether the graph has a cycle based on the result from the previous step.",
        "rag_data": [
            {
                "Section ID": "is_directed_acyclic_graph",
                "Description": [
                    "Returns True if the graph G is a directed acyclic graph (DAG) or\nFalse if not."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": ""
                    },
                    "Returns:": {
                        "bool": "True ifGis a DAG, False otherwise"
                    }
                },
                "Rubrics": {
                    "Examples": "Undirected graph:\nG=nx.Graph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected graph with cycle:\nG=nx.DiGraph([(1,2),(2,3),(3,1)])\nnx.is_directed_acyclic_graph(G)\n# False\nDirected acyclic graph:\nG=nx.DiGraph([(1,2),(2,3)])\nnx.is_directed_acyclic_graph(G)\n# True"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <4>, <2>, <13>.\nNode <4> is connected to nodes <0>, <15>, <5>.\nNode <2> is connected to node <0>.\nNode <13> is connected to nodes <0>, <10>.\nNode <15> is connected to nodes <4>, <11>.\nNode <5> is connected to node <4>.\nNode <8> is connected to node <1>.\nNode <1> is connected to nodes <8>, <12>.\nNode <12> is connected to nodes <1>, <3>, <7>.\nNode <9> is connected to node <3>.\nNode <3> is connected to nodes <9>, <12>, <14>.\nNode <14> is connected to nodes <3>, <6>.\nNode <7> is connected to nodes <12>, <11>.\nNode <11> is connected to nodes <15>, <7>, <6>.\nNode <6> is connected to nodes <11>, <14>.\nNode <10> is connected to node <13>.\nDoes the graph have a cycle? For an undirected graph, a cycle is a closed path that traverses through a sequence of nodes and edges, eventually returning to the starting node. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],\n    'Edges': [\n        [0, 4], [0, 2], [0, 13], [4, 15], [4, 5], [2, 0], [13, 10],\n        [15, 11], [5, 4], [8, 1], [1, 12], [12, 1], [12, 3], [12, 7],\n        [9, 3], [3, 9], [3, 12], [3, 14], [14, 6], [7, 12], [7, 11],\n        [11, 15], [11, 7], [11, 6], [6, 11], [6, 14], [10, 13]\n    ]\n}\n\n# Create a directed graph from the input data\nG = nx.DiGraph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Check for cycles in the graph\nhas_cycle = nx.is_directed_acyclic_graph(G)\n\n# Output the result\nif not has_cycle:\n    print(\"The graph has a cycle.\")\nelse:\n    print(\"The graph does not have a cycle.\")\n",
                "key_api": "The key API used in the code is the NetworkX library, specifically:\n- `nx.DiGraph()`: To create a directed graph.\n- `G.add_nodes_from(nodes)`: To add nodes to the graph.\n- `G.add_edges_from(edges)`: To add edges to the graph.\n- `nx.is_directed_acyclic_graph(G)`: To check if the graph is acyclic.",
                "key_experience": "Best practices observed in this task include:\n1. **Modular Code Structure:** Dividing the task into separate logical steps such as graph initialization, node and edge addition, cycle detection, and result output.\n2. **Effective Use of Libraries:** Leveraging the powerful and efficient NetworkX library for graph operations to minimize boilerplate code and ensure reliability.\n3. **Error Handling:** Although not explicitly mentioned, it's generally advisable to include error handling mechanisms to catch and handle potential issues during graph operations."
            }
        ]
    },
    {
        "id": 122,
        "problem": "Calculate the clustering coefficient of node <19>",
        "graph_type": "undirected",
        "experience": "To calculate the clustering coefficient of a node in an undirected graph, I utilized the NetworkX library, which has built-in functions to make this process straightforward and efficient. This approach was applied to the given graph description where nodes and their connections were provided.",
        "rag_data": [
            {
                "Section ID": "clustering",
                "Description": [
                    "Compute the clustering coefficient for nodes.",
                    "For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,",
                    "where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) .",
                    "For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,",
                    "The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) .",
                    "The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) .",
                    "Additionally, this weighted definition has been generalized to support negative edge weights [3] .",
                    "For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] .",
                    "where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "",
                        "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.",
                        "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
                    },
                    "Returns:": {
                        "out : float, or dictionary": "Clustering coefficient at specified nodes"
                    }
                },
                "Rubrics": {
                    "Notes": "Self loops are ignored.",
                    "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Intensity and coherence of motifs in weighted complex\nnetworks by J. P. Onnela, J. Saram\u00e4ki, J. Kert\u00e9sz, and K. Kaski,\nPhysical Review E, 71(6), 065103 (2005).  [3]Generalization of Clustering Coefficients to Signed Correlation Networks\nby G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).  [4]Clustering in complex directed networks by G. Fagiolo,\nPhysical Review E, 76(2), 026107 (2007).",
                    "Examples": "G=nx.complete_graph(5)\nprint(nx.clustering(G,0))\n# 1.0\nprint(nx.clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
                }
            },
            {
                "Section ID": "clustering",
                "Description": [
                    "Compute a bipartite clustering coefficient for nodes.",
                    "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
                    "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
                    "The mode selects the function for c_{uv} which can be:",
                    "dot :",
                    "min :",
                    "max :"
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A bipartite graph",
                        "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                        "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
                    },
                    "Returns:": {
                        "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
                    }
                },
                "Rubrics": {
                    "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
                    "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <5> is connected to nodes <0>, <2>, <8>, <13>, <15>, <18>, <14>, <6>.\nNode <0> is connected to nodes <5>, <1>, <17>, <12>, <7>, <9>, <8>, <16>, <15>, <14>, <6>.\nNode <2> is connected to nodes <5>, <19>, <17>, <4>, <12>, <7>, <11>, <9>, <10>, <18>, <6>.\nNode <8> is connected to nodes <5>, <1>, <19>, <0>, <4>, <12>, <7>, <9>, <16>, <13>, <15>, <18>, <3>, <6>.\nNode <13> is connected to nodes <5>, <1>, <17>, <4>, <12>, <11>, <9>, <8>, <16>, <15>, <18>, <14>, <3>, <6>.\nNode <15> is connected to nodes <5>, <1>, <19>, <17>, <0>, <4>, <7>, <11>, <9>, <8>, <13>, <10>, <18>, <14>, <3>, <6>.\nNode <18> is connected to nodes <5>, <19>, <17>, <4>, <11>, <9>, <2>, <8>, <16>, <13>, <15>, <10>, <14>, <3>.\nNode <14> is connected to nodes <5>, <1>, <19>, <0>, <7>, <16>, <13>, <15>, <18>, <3>, <6>.\nNode <6> is connected to nodes <5>, <1>, <19>, <17>, <0>, <4>, <12>, <7>, <11>, <9>, <2>, <8>, <13>, <15>, <10>, <14>, <3>.\nNode <1> is connected to nodes <19>, <17>, <0>, <7>, <8>, <13>, <15>, <10>, <14>, <6>.\nNode <19> is connected to nodes <1>, <12>, <7>, <11>, <9>, <2>, <8>, <16>, <15>, <10>, <18>, <14>, <3>, <6>.\nNode <17> is connected to nodes <1>, <0>, <4>, <12>, <7>, <11>, <9>, <2>, <16>, <13>, <15>, <18>, <6>.\nNode <7> is connected to nodes <1>, <19>, <17>, <0>, <12>, <9>, <2>, <8>, <15>, <10>, <14>, <3>, <6>.\nNode <10> is connected to nodes <1>, <19>, <4>, <7>, <11>, <9>, <2>, <16>, <15>, <18>, <3>, <6>.\nNode <12> is connected to nodes <19>, <17>, <0>, <4>, <7>, <9>, <2>, <8>, <16>, <13>, <3>, <6>.\nNode <11> is connected to nodes <19>, <17>, <4>, <9>, <2>, <16>, <13>, <15>, <10>, <18>, <3>, <6>.\nNode <9> is connected to nodes <19>, <17>, <0>, <12>, <7>, <11>, <2>, <8>, <13>, <15>, <10>, <18>, <6>.\nNode <16> is connected to nodes <19>, <17>, <0>, <12>, <11>, <8>, <13>, <10>, <18>, <14>.\nNode <3> is connected to nodes <19>, <4>, <12>, <7>, <11>, <8>, <13>, <15>, <10>, <18>, <14>, <6>.\nNode <4> is connected to nodes <17>, <12>, <11>, <2>, <8>, <13>, <15>, <10>, <18>, <3>, <6>.\nWhat is the clustering coefficient of node <19>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 5, 'Connections': [0, 2, 8, 13, 15, 18, 14, 6]},\n        {'Node': 0, 'Connections': [5, 1, 17, 12, 7, 9, 8, 16, 15, 14, 6]},\n        {'Node': 2, 'Connections': [5, 19, 17, 4, 12, 7, 11, 9, 10, 18, 6]},\n        {'Node': 8, 'Connections': [5, 1, 19, 0, 4, 12, 7, 9, 16, 13, 15, 18, 3, 6]},\n        {'Node': 13, 'Connections': [5, 1, 17, 4, 12, 11, 9, 8, 16, 15, 18, 14, 3, 6]},\n        {'Node': 15, 'Connections': [5, 1, 19, 17, 0, 4, 7, 11, 9, 8, 13, 10, 18, 14, 3, 6]},\n        {'Node': 18, 'Connections': [5, 19, 17, 4, 11, 9, 2, 8, 16, 13, 15, 10, 14, 3]},\n        {'Node': 14, 'Connections': [5, 1, 19, 0, 7, 16, 13, 15, 18, 3, 6]},\n        {'Node': 6, 'Connections': [5, 1, 19, 17, 0, 4, 12, 7, 11, 9, 2, 8, 13, 15, 10, 14, 3]},\n        {'Node': 1, 'Connections': [19, 17, 0, 7, 8, 13, 15, 10, 14, 6]},\n        {'Node': 19, 'Connections': [1, 12, 7, 11, 9, 2, 8, 16, 15, 10, 18, 14, 3, 6]},\n        {'Node': 17, 'Connections': [1, 0, 4, 12, 7, 11, 9, 2, 16, 13, 15, 18, 6]},\n        {'Node': 7, 'Connections': [1, 19, 17, 0, 12, 9, 2, 8, 15, 10, 14, 3, 6]},\n        {'Node': 10, 'Connections': [1, 19, 4, 7, 11, 9, 2, 16, 15, 18, 3, 6]},\n        {'Node': 12, 'Connections': [19, 17, 0, 4, 7, 9, 2, 8, 16, 13, 3, 6]},\n        {'Node': 11, 'Connections': [19, 17, 4, 9, 2, 16, 13, 15, 10, 18, 3, 6]},\n        {'Node': 9, 'Connections': [19, 17, 0, 12, 7, 11, 2, 8, 13, 15, 10, 18, 6]},\n        {'Node': 16, 'Connections': [19, 17, 0, 12, 11, 8, 13, 10, 18, 14]},\n        {'Node': 3, 'Connections': [19, 4, 12, 7, 11, 8, 13, 15, 10, 18, 14, 6]},\n        {'Node': 4, 'Connections': [17, 12, 11, 2, 8, 13, 15, 10, 18, 3, 6]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    G.add_node(node)\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate the clustering coefficient for node 19\nclustering_coefficient = nx.clustering(G, 19)\n\n# Output the clustering coefficient\nprint(f\"The clustering coefficient of node 19 is: {clustering_coefficient}\")\n",
                "key_api": "networkx.clustering",
                "key_experience": "1. Converted the provided JSON data into a NetworkX graph object.\n2. Leveraged NetworkX's 'clustering' function to calculate the clustering coefficient of the specified node (node 19 in this case).\n3. Ensured the graph was undirected as specified in the task description."
            }
        ]
    },
    {
        "id": 123,
        "problem": "Calculate the clustering coefficient of node <8>",
        "graph_type": "undirected",
        "experience": "In the task of calculating the clustering coefficient for a node in an undirected graph, the key steps involved included importing the necessary library (NetworkX), representing the graph using an adjacency list, and then utilizing NetworkX's built-in functions to compute the clustering coefficient.",
        "rag_data": [
            {
                "Section ID": "clustering",
                "Description": [
                    "Compute the clustering coefficient for nodes.",
                    "For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,",
                    "where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) .",
                    "For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,",
                    "The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) .",
                    "The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) .",
                    "Additionally, this weighted definition has been generalized to support negative edge weights [3] .",
                    "For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] .",
                    "where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "",
                        "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.",
                        "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
                    },
                    "Returns:": {
                        "out : float, or dictionary": "Clustering coefficient at specified nodes"
                    }
                },
                "Rubrics": {
                    "Notes": "Self loops are ignored.",
                    "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Intensity and coherence of motifs in weighted complex\nnetworks by J. P. Onnela, J. Saram\u00e4ki, J. Kert\u00e9sz, and K. Kaski,\nPhysical Review E, 71(6), 065103 (2005).  [3]Generalization of Clustering Coefficients to Signed Correlation Networks\nby G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).  [4]Clustering in complex directed networks by G. Fagiolo,\nPhysical Review E, 76(2), 026107 (2007).",
                    "Examples": "G=nx.complete_graph(5)\nprint(nx.clustering(G,0))\n# 1.0\nprint(nx.clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
                }
            },
            {
                "Section ID": "clustering",
                "Description": [
                    "Compute a bipartite clustering coefficient for nodes.",
                    "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
                    "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
                    "The mode selects the function for c_{uv} which can be:",
                    "dot :",
                    "min :",
                    "max :"
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A bipartite graph",
                        "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                        "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
                    },
                    "Returns:": {
                        "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
                    }
                },
                "Rubrics": {
                    "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
                    "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
                }
            }
        ],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <13> is connected to nodes <3>, <0>, <9>, <15>, <12>, <10>, <1>.\nNode <3> is connected to nodes <13>, <4>, <9>, <12>, <16>, <10>, <6>, <17>.\nNode <0> is connected to nodes <13>, <4>, <5>, <9>, <8>, <12>, <16>, <7>, <6>, <17>, <14>, <2>.\nNode <9> is connected to nodes <13>, <3>, <0>, <4>, <8>, <15>, <16>, <11>, <1>, <14>, <2>.\nNode <15> is connected to nodes <13>, <4>, <9>, <8>, <7>, <6>, <17>, <2>.\nNode <12> is connected to nodes <13>, <3>, <0>, <4>, <16>, <10>, <7>, <11>, <6>, <14>, <2>.\nNode <10> is connected to nodes <13>, <3>, <4>, <5>, <12>, <11>, <17>, <2>.\nNode <1> is connected to nodes <13>, <9>, <7>, <17>, <14>, <2>.\nNode <4> is connected to nodes <3>, <0>, <9>, <8>, <15>, <12>, <16>, <10>, <7>, <11>, <6>, <17>, <2>.\nNode <16> is connected to nodes <3>, <0>, <4>, <9>, <8>, <12>, <6>, <14>.\nNode <6> is connected to nodes <3>, <0>, <4>, <15>, <12>, <16>, <17>.\nNode <17> is connected to nodes <3>, <0>, <4>, <5>, <15>, <10>, <7>, <11>, <6>, <1>.\nNode <5> is connected to nodes <0>, <10>, <7>, <17>.\nNode <8> is connected to nodes <0>, <4>, <9>, <15>, <16>, <7>, <2>.\nNode <7> is connected to nodes <0>, <4>, <5>, <8>, <15>, <12>, <11>, <17>, <1>, <14>, <2>.\nNode <14> is connected to nodes <0>, <9>, <12>, <16>, <7>, <1>.\nNode <2> is connected to nodes <0>, <4>, <9>, <8>, <15>, <12>, <10>, <7>, <1>.\nNode <11> is connected to nodes <4>, <9>, <12>, <10>, <7>, <17>.\nWhat is the clustering coefficient of node <8>?\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': {\n        '13': [3, 0, 9, 15, 12, 10, 1],\n        '3': [13, 4, 9, 12, 16, 10, 6, 17],\n        '0': [13, 4, 5, 9, 8, 12, 16, 7, 6, 17, 14, 2],\n        '9': [13, 3, 0, 4, 8, 15, 16, 11, 1, 14, 2],\n        '15': [13, 4, 9, 8, 7, 6, 17, 2],\n        '12': [13, 3, 0, 4, 16, 10, 7, 11, 6, 14, 2],\n        '10': [13, 3, 4, 5, 12, 11, 17, 2],\n        '1': [13, 9, 7, 17, 14, 2],\n        '4': [3, 0, 9, 8, 15, 12, 16, 10, 7, 11, 6, 17, 2],\n        '16': [3, 0, 4, 9, 8, 12, 6, 14],\n        '6': [3, 0, 4, 15, 12, 16, 17],\n        '17': [3, 0, 4, 5, 15, 10, 7, 11, 6, 1],\n        '5': [0, 10, 7, 17],\n        '8': [0, 4, 9, 15, 16, 7, 2],\n        '7': [0, 4, 5, 8, 15, 12, 11, 17, 1, 14, 2],\n        '14': [0, 9, 12, 16, 7, 1],\n        '2': [0, 4, 9, 8, 15, 12, 10, 7, 1],\n        '11': [4, 9, 12, 10, 7, 17]\n    }\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the adjacency list\nfor node, neighbors in data['Nodes'].items():\n    for neighbor in neighbors:\n        G.add_edge(int(node), int(neighbor))\n\n# Calculate the clustering coefficient for node 8\nclustering_coefficient_node_8 = nx.clustering(G, 8)\n\n# Output the clustering coefficient\nprint(f\"Clustering Coefficient of node 8: {clustering_coefficient_node_8}\")\n",
                "key_api": "networkx.clustering()",
                "key_experience": "['Convert the adjacency list into a NetworkX graph object.', \"Utilize NetworkX's built-in methods for efficient and accurate graph computations.\", 'Focus on handling undirected graphs, using appropriate functions to prevent direction-based errors.']"
            }
        ]
    },
    {
        "id": 124,
        "problem": "Calculate the clustering coefficient of node <12>.",
        "graph_type": "directed",
        "experience": "The task involved calculating the clustering coefficient of a node in a directed graph. To solve this, we needed to model the graph using a directed structure, understand the concept of neighbors (successors in the case of directed graphs), and apply clustering coefficient calculations. The problem was approached by first defining the graph with all nodes and edges, followed by calculating the clustering coefficient using the built-in NetworkX method. The challenge was understanding the relationship between neighbors and their connectivity. By using NetworkX's DiGraph to represent directed graphs, the solution correctly handled directed relationships. We also made sure to optimize the solution by utilizing efficient API methods for clustering coefficient calculation.",
        "rag_data": [],
        "accuracy": 0.222222222,
        "example": [
            {
                "question": "Given a directed graph:\nNode <5> is connected to node <15>.\nNode <15> is connected to nodes <7>, <5>.\nNode <2> is connected to nodes <6>, <9>, <5>.\nNode <6> is connected to nodes <14>, <15>, <3>.\nNode <9> is connected to nodes <7>, <3>, <5>, <2>.\nNode <1> is connected to node <13>.\nNode <13> is connected to node <3>.\nNode <14> is connected to node <7>.\nNode <3> is connected to nodes <11>, <8>.\nNode <7> is connected to nodes <10>, <6>, <13>, <4>.\nNode <11> is connected to nodes <10>, <5>.\nNode <10> is connected to node <13>.\nNode <12> is connected to nodes <0>, <13>.\nNode <0> is connected to node <15>.\nNode <4> is connected to nodes <0>, <8>, <2>, <14>.\nNode <8> is connected to nodes <15>, <4>, <0>.\nWhat is the clustering coefficient of node <12>? For a directed graph, we consider a node's successors as its neighbors.\nAnswer:\n",
                "code": "import networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 5, 'Connections': [15]},\n        {'Node': 15, 'Connections': [7, 5]},\n        {'Node': 2, 'Connections': [6, 9, 5]},\n        {'Node': 6, 'Connections': [14, 15, 3]},\n        {'Node': 9, 'Connections': [7, 3, 5, 2]},\n        {'Node': 1, 'Connections': [13]},\n        {'Node': 13, 'Connections': [3]},\n        {'Node': 14, 'Connections': [7]},\n        {'Node': 3, 'Connections': [11, 8]},\n        {'Node': 7, 'Connections': [10, 6, 13, 4]},\n        {'Node': 11, 'Connections': [10, 5]},\n        {'Node': 10, 'Connections': [13]},\n        {'Node': 12, 'Connections': [0, 13]},\n        {'Node': 0, 'Connections': [15]},\n        {'Node': 4, 'Connections': [0, 8, 2, 14]},\n        {'Node': 8, 'Connections': [15, 4, 0]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate the clustering coefficient for node 12\nclustering_coefficient = nx.clustering(G, 12)\n\n# Output the clustering coefficient\nprint(clustering_coefficient)",
                "key_api": "The key API used was 'networkx.DiGraph()' to create the directed graph, and 'nx.clustering()' to compute the clustering coefficient.",
                "key_experience": "['Defined and properly formatted input data.', 'Built and structured the graph using NetworkX.', \"Utilized NetworkX's built-in functions for calculating the clustering coefficient.\", 'Focused on clear, modular code for easy readability and reuse.']"
            }
        ]
    },
    {
        "id": 125,
        "problem": "Calculate the clustering coefficient of node <10>",
        "graph_type": "directed",
        "experience": "In the recent task, the problem involved calculating the clustering coefficient for a specific node in a directed graph. The graph's structure was provided through a series of edges between nodes, and the focus was on understanding how the clustering coefficient is calculated in directed graphs by considering the neighbors (successors). The steps to solve the problem included constructing the graph using the provided edges, focusing on the specific node (node 10 in this case), and applying an appropriate NetworkX function to compute the coefficient. Correct use of directed graphs was crucial for accurate results.",
        "rag_data": [
            {
                "Section ID": "clustering",
                "Description": [
                    "Compute the clustering coefficient for nodes.",
                    "For unweighted graphs, the clustering of a node \\(u\\) is the fraction of possible triangles through that node that exist,",
                    "where \\(T(u)\\) is the number of triangles through node \\(u\\) and \\(deg(u)\\) is the degree of \\(u\\) .",
                    "For weighted graphs, there are several ways to define clustering [1] .\nthe one used here is defined\nas the geometric average of the subgraph edge weights [2] ,",
                    "The edge weights \\(\\hat{w}_{uv}\\) are normalized by the maximum weight\nin the network \\(\\hat{w}_{uv} = w_{uv}/\\max(w)\\) .",
                    "The value of \\(c_u\\) is assigned to 0 if \\(deg(u) < 2\\) .",
                    "Additionally, this weighted definition has been generalized to support negative edge weights [3] .",
                    "For directed graphs, the clustering is similarly defined as the fraction\nof all possible directed triangles or geometric average of the subgraph\nedge weights for unweighted and weighted directed graph respectively [4] .",
                    "where \\(T(u)\\) is the number of directed triangles through node \\(u\\) , \\(deg^{tot}(u)\\) is the sum of in degree and out degree of \\(u\\) and \\(deg^{\\leftrightarrow}(u)\\) is the reciprocal degree of \\(u\\) ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "",
                        "nodes : node, iterable of nodes, or None (default=None)": "If a singleton node, return the number of triangles for that node.\nIf an iterable, compute the number of triangles for each of those nodes.\nIfNone(the default) compute the number of triangles for all nodes inG.",
                        "weight : string or None, optional (default=None)": "The edge attribute that holds the numerical value used as a weight.\nIf None, then each edge has weight 1."
                    },
                    "Returns:": {
                        "out : float, or dictionary": "Clustering coefficient at specified nodes"
                    }
                },
                "Rubrics": {
                    "Notes": "Self loops are ignored.",
                    "References": "[1]Generalizations of the clustering coefficient to weighted\ncomplex networks by J. Saram\u00e4ki, M. Kivel\u00e4, J.-P. Onnela,\nK. Kaski, and J. Kert\u00e9sz, Physical Review E, 75 027105 (2007).http://jponnela.com/web_documents/a9.pdf  [2]Intensity and coherence of motifs in weighted complex\nnetworks by J. P. Onnela, J. Saram\u00e4ki, J. Kert\u00e9sz, and K. Kaski,\nPhysical Review E, 71(6), 065103 (2005).  [3]Generalization of Clustering Coefficients to Signed Correlation Networks\nby G. Costantini and M. Perugini, PloS one, 9(2), e88669 (2014).  [4]Clustering in complex directed networks by G. Fagiolo,\nPhysical Review E, 76(2), 026107 (2007).",
                    "Examples": "G=nx.complete_graph(5)\nprint(nx.clustering(G,0))\n# 1.0\nprint(nx.clustering(G))\n# {0: 1.0, 1: 1.0, 2: 1.0, 3: 1.0, 4: 1.0}"
                }
            },
            {
                "Section ID": "clustering",
                "Description": [
                    "Compute a bipartite clustering coefficient for nodes.",
                    "The bipartite clustering coefficient is a measure of local density\nof connections defined as [1] :",
                    "where N(N(u)) are the second order neighbors of u in G excluding u ,\nand c_{uv} is the pairwise clustering coefficient between nodes u and v .",
                    "The mode selects the function for c_{uv} which can be:",
                    "dot :",
                    "min :",
                    "max :"
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A bipartite graph",
                        "nodes : list or iterable (optional)": "Compute bipartite clustering for these nodes. The default\nis all nodes in G.",
                        "mode : string": "The pairwise bipartite clustering method to be used in the computation.\nIt must be \u201cdot\u201d, \u201cmax\u201d, or \u201cmin\u201d."
                    },
                    "Returns:": {
                        "clustering : dictionary": "A dictionary keyed by node with the clustering coefficient value."
                    }
                },
                "Rubrics": {
                    "References": "[1]Latapy, Matthieu, Cl\u00e9mence Magnien, and Nathalie Del Vecchio (2008).\nBasic notions for the analysis of large two-mode networks.\nSocial Networks 30(1), 31\u201348.",
                    "Examples": "fromnetworkx.algorithmsimportbipartite\nG=nx.path_graph(4)# path graphs are bipartite\nc=bipartite.clustering(G)\nc[0]\n# 0.5\nc=bipartite.clustering(G,mode=\"min\")\nc[0]\n# 1.0"
                }
            }
        ],
        "accuracy": 0.333333334,
        "example": [
            {
                "question": "Given a directed graph:\nNode <6> is connected to nodes <4>, <11>, <12>, <13>, <17>, <7>, <14>.\nNode <4> is connected to nodes <11>, <12>, <13>, <8>, <10>, <17>, <5>, <14>.\nNode <11> is connected to nodes <15>, <0>, <12>, <13>, <9>, <10>, <5>, <7>, <14>.\nNode <12> is connected to nodes <16>, <9>, <7>, <11>, <15>.\nNode <13> is connected to nodes <17>, <18>, <5>, <1>.\nNode <17> is connected to nodes <2>, <5>, <7>, <3>, <6>, <12>, <8>.\nNode <7> is connected to nodes <6>, <15>, <0>, <12>, <17>, <2>, <5>.\nNode <14> is connected to nodes <3>, <6>, <4>, <0>, <10>.\nNode <8> is connected to nodes <17>, <7>, <11>.\nNode <10> is connected to nodes <2>, <18>, <6>, <11>, <15>, <0>, <13>.\nNode <5> is connected to nodes <1>, <11>, <0>.\nNode <15> is connected to nodes <0>, <8>, <2>, <1>, <14>, <3>, <6>, <4>.\nNode <0> is connected to nodes <13>, <8>, <7>, <14>, <6>, <15>.\nNode <9> is connected to nodes <10>, <18>, <6>, <11>.\nNode <2> is connected to nodes <18>, <5>, <7>, <3>, <11>, <15>, <13>, <9>, <17>.\nNode <1> is connected to nodes <3>, <6>, <11>, <15>, <7>.\nNode <3> is connected to nodes <9>, <10>, <2>, <18>, <5>, <1>.\nNode <16> is connected to nodes <8>, <15>, <0>, <12>.\nNode <18> is connected to nodes <5>, <3>, <12>, <8>.\nWhat is the clustering coefficient of node <10>? For a directed graph, we consider a node's successors as its neighbors.\nAnswer:\n",
                "code": "import networkx as nx\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges based on the graph description\nedges = [\n    (6, 4), (6, 11), (6, 12), (6, 13), (6, 17), (6, 7), (6, 14),\n    (4, 11), (4, 12), (4, 13), (4, 8), (4, 10), (4, 17), (4, 5), (4, 14),\n    (11, 15), (11, 0), (11, 12), (11, 13), (11, 9), (11, 10), (11, 5), (11, 7), (11, 14),\n    (12, 16), (12, 9), (12, 7), (12, 11), (12, 15),\n    (13, 17), (13, 18), (13, 5), (13, 1),\n    (17, 2), (17, 5), (17, 7), (17, 3), (17, 6), (17, 12), (17, 8),\n    (7, 6), (7, 15), (7, 0), (7, 12), (7, 17), (7, 2), (7, 5),\n    (14, 3), (14, 6), (14, 4), (14, 0), (14, 10),\n    (8, 17), (8, 7), (8, 11),\n    (10, 2), (10, 18), (10, 6), (10, 11), (10, 15), (10, 0), (10, 13),\n    (5, 1), (5, 11), (5, 0),\n    (15, 0), (15, 8), (15, 2), (15, 1), (15, 14), (15, 3), (15, 6), (15, 4),\n    (0, 13), (0, 8), (0, 7), (0, 14), (0, 6), (0, 15),\n    (9, 10), (9, 18), (9, 6), (9, 11),\n    (2, 18), (2, 5), (2, 7), (2, 3), (2, 11), (2, 15), (2, 13), (2, 9), (2, 17),\n    (1, 3), (1, 6), (1, 11), (1, 15), (1, 7),\n    (3, 9), (3, 10), (3, 2), (3, 18), (3, 5), (3, 1),\n    (16, 8), (16, 15), (16, 0), (16, 12),\n    (18, 5), (18, 3), (18, 12), (18, 8)\n]\n\n# Add the edges to the graph\nG.add_edges_from(edges)\n\n# Calculate the clustering coefficient for node 10\nclustering_coefficient_10 = nx.clustering(G, nodes=10, weight=None)\n\nclustering_coefficient_10",
                "key_api": "networkx.clustering()",
                "key_experience": "1. Carefully parsing and inputting the graph's structure as a set of directed edges. 2. Using the appropriate NetworkX API for directed graphs. 3. Verifying that the graph's directionality is correctly handled, as clustering coefficient calculations differ between directed and undirected graphs."
            }
        ]
    },
    {
        "id": 126,
        "problem": "Identify the predecessor nodes of node <16>",
        "graph_type": "directed",
        "experience": "In the recent engagement, the task was to identify the predecessor nodes of a specified node (node <16>) in a directed graph. The nodes and their connections were provided as input in a JSON format.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <14> is connected to node <4>.\nNode <4> is connected to nodes <15>, <0>, <3>, <14>, <16>, <12>, <1>, <9>.\nNode <16> is connected to nodes <17>, <13>, <9>, <2>, <3>.\nNode <17> is connected to nodes <7>, <11>, <9>, <4>, <2>, <6>, <3>.\nNode <13> is connected to nodes <1>, <4>, <2>, <3>, <16>.\nNode <9> is connected to nodes <2>, <0>, <6>, <7>.\nNode <2> is connected to nodes <17>, <8>, <7>, <11>, <4>, <15>.\nNode <3> is connected to nodes <16>, <9>, <4>, <0>, <6>.\nNode <7> is connected to nodes <4>, <15>.\nNode <11> is connected to nodes <10>, <4>, <15>, <2>, <8>.\nNode <6> is connected to nodes <14>, <1>, <9>, <15>.\nNode <1> is connected to nodes <15>, <0>, <3>, <14>, <17>, <13>.\nNode <8> is connected to nodes <11>, <15>, <2>, <16>.\nNode <15> is connected to nodes <2>, <5>.\nNode <12> is connected to nodes <14>, <16>.\nNode <10> is connected to node <15>.\nNode <0> is connected to node <17>.\nNode <5> is connected to nodes <6>, <16>, <13>, <8>, <7>, <1>.\nWhich are the predecessor nodes of node <16>? A predecessor of n is a node m such that there exists a directed edge from m to n.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 14, 'Connections': [4]},\n        {'Node': 4, 'Connections': [15, 0, 3, 14, 16, 12, 1, 9]},\n        {'Node': 16, 'Connections': [17, 13, 9, 2, 3]},\n        {'Node': 17, 'Connections': [7, 11, 9, 4, 2, 6, 3]},\n        {'Node': 13, 'Connections': [1, 4, 2, 3, 16]},\n        {'Node': 9, 'Connections': [2, 0, 6, 7]},\n        {'Node': 2, 'Connections': [17, 8, 7, 11, 4, 15]},\n        {'Node': 3, 'Connections': [16, 9, 4, 0, 6]},\n        {'Node': 7, 'Connections': [4, 15]},\n        {'Node': 11, 'Connections': [10, 4, 15, 2, 8]},\n        {'Node': 6, 'Connections': [14, 1, 9, 15]},\n        {'Node': 1, 'Connections': [15, 0, 3, 14, 17, 13]},\n        {'Node': 8, 'Connections': [11, 15, 2, 16]},\n        {'Node': 15, 'Connections': [2, 5]},\n        {'Node': 12, 'Connections': [14, 16]},\n        {'Node': 10, 'Connections': [15]},\n        {'Node': 0, 'Connections': [17]},\n        {'Node': 5, 'Connections': [6, 16, 13, 8, 7, 1]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in input_data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Identify the predecessor nodes of node 16\npredecessors_of_16 = list(G.predecessors(16))\n\n# Output the predecessors\nprint(\"Predecessor nodes of node 16:\", predecessors_of_16)\n",
                "key_api": "NetworkX",
                "key_experience": "['Parsing input data to extract nodes and connections.', 'Creating a directed graph using NetworkX.', 'Adding nodes and edges from the parsed data to the graph.', \"Using NetworkX's functions to identify predecessor nodes of a specific node.\"]"
            }
        ]
    },
    {
        "id": 127,
        "problem": "Identify the predecessor nodes of node <12>.",
        "graph_type": "directed",
        "experience": "In this engagement, we successfully identified the predecessor nodes of a given node in a directed graph by leveraging the NetworkX library in Python. The task involved defining the graph's structure, adding the nodes and edges, and then utilizing a key API function to retrieve the predecessors.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <6> is connected to nodes <0>, <3>, <16>.\nNode <3> is connected to node <8>.\nNode <16> is connected to nodes <12>, <15>, <5>.\nNode <9> is connected to nodes <16>, <8>.\nNode <8> is connected to nodes <9>, <3>.\nNode <10> is connected to node <15>.\nNode <2> is connected to nodes <11>, <14>, <9>.\nNode <11> is connected to node <0>.\nNode <13> is connected to nodes <5>, <9>, <10>.\nNode <5> is connected to nodes <8>, <6>, <0>, <13>.\nNode <12> is connected to nodes <0>, <14>, <1>.\nNode <7> is connected to nodes <6>, <0>, <15>.\nNode <1> is connected to nodes <3>, <13>, <14>.\nNode <4> is connected to nodes <10>, <3>, <5>, <14>.\nWhich are the predecessor nodes of node <12>? A predecessor of n is a node m such that there exists a directed edge from m to n.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph structure based on the provided input\nnodes = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\nedges = [\n    {'from': 6, 'to': [0, 3, 16]},\n    {'from': 3, 'to': [8]},\n    {'from': 16, 'to': [12, 15, 5]},\n    {'from': 9, 'to': [16, 8]},\n    {'from': 8, 'to': [9, 3]},\n    {'from': 10, 'to': [15]},\n    {'from': 2, 'to': [11, 14, 9]},\n    {'from': 11, 'to': [0]},\n    {'from': 13, 'to': [5, 9, 10]},\n    {'from': 5, 'to': [8, 6, 0, 13]},\n    {'from': 12, 'to': [0, 14, 1]},\n    {'from': 7, 'to': [6, 0, 15]},\n    {'from': 1, 'to': [3, 13, 14]},\n    {'from': 4, 'to': [10, 3, 5, 14]}\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph\nfor edge in edges:\n    for target in edge['to']:\n        G.add_edge(edge['from'], target)\n\n# Identify the predecessor nodes of node 12\npredecessors_of_12 = list(G.predecessors(12))\n\n# Output the predecessors\nprint(\"Predecessors of node 12:\", predecessors_of_12)\n",
                "key_api": "networkx.DiGraph().predecessors()",
                "key_experience": "1. Define the graph structure clearly with nodes and edges. 2. Use a loop to add edges to the graph to ensure all edges are correctly incorporated. 3. Utilize appropriate NetworkX functions such as predecessors to easily retrieve related nodes. 4. Print the output in a user-friendly format for easy verification."
            }
        ]
    },
    {
        "id": 128,
        "problem": "Find a maximum matching in the bipartite graph.",
        "graph_type": "undirected",
        "experience": "The task involved writing Python code to find a maximum matching in a bipartite graph using the NetworkX library. Key steps included defining the nodes and connections, creating the bipartite graph, adding nodes and edges, and using NetworkX's `maximum_matching` function to find the matching. The task was successfully completed by considering sets of nodes from two different sets and connecting appropriate nodes based on the given data.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <6>, <11>, <14>, <15>.\nNode <1> is connected to nodes <7>, <9>, <15>.\nNode <2> is connected to nodes <5>, <7>, <12>, <15>.\nNode <3> is connected to nodes <8>, <9>, <10>, <11>, <13>.\nNode <4> is connected to nodes <10>, <12>, <15>.\nNode <5> is connected to node <2>.\nNode <6> is connected to node <0>.\nNode <7> is connected to nodes <1>, <2>.\nNode <8> is connected to node <3>.\nNode <9> is connected to nodes <1>, <3>.\nNode <10> is connected to nodes <3>, <4>.\nNode <11> is connected to nodes <0>, <3>.\nNode <12> is connected to nodes <2>, <4>.\nNode <13> is connected to node <3>.\nNode <14> is connected to node <0>.\nNode <15> is connected to nodes <0>, <1>, <2>, <4>.\nFind a maximum matching in the bipartite graph.\nNodes set 1 contains: <0> <1> <2> <3> <4>.\nNodes set 2 contains: <5> <6> <7> <8> <9> <10> <11> <12> <13> <14> <15>.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ndata = {\n    'Nodes': {\n        'Set_1': [0, 1, 2, 3, 4],\n        'Set_2': [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n    },\n    'Connections': {\n        '0': [6, 11, 14, 15],\n        '1': [7, 9, 15],\n        '2': [5, 7, 12, 15],\n        '3': [8, 9, 10, 11, 13],\n        '4': [10, 12, 15],\n        '5': [2],\n        '6': [0],\n        '7': [1, 2],\n        '8': [3],\n        '9': [1, 3],\n        '10': [3, 4],\n        '11': [0, 3],\n        '12': [2, 4],\n        '13': [3],\n        '14': [0],\n        '15': [0, 1, 2, 4]\n    }\n}\n\n# Create a bipartite graph\nB = nx.Graph()\n\n# Add nodes from both sets\nB.add_nodes_from(data['Nodes']['Set_1'], bipartite=0)  # Set_1\nB.add_nodes_from(data['Nodes']['Set_2'], bipartite=1)  # Set_2\n\n# Add edges based on connections\nfor node, connections in data['Connections'].items():\n    for connection in connections:\n        B.add_edge(int(node), connection)\n\n# Find maximum matching\nmatching = nx.bipartite.maximum_matching(B)\n\n# Print the matching result\nprint(\"Maximum Matching:\")\nfor node in matching:\n    if node in data['Nodes']['Set_1']:\n        print(f\"{node} is matched with {matching[node]}\")\n",
                "key_api": "networkx.bipartite.maximum_matching",
                "key_experience": "1. Define the input data clearly, separating nodes into two sets. 2. Utilize NetworkX's Graph functions to build the graph structure. 3. Add nodes and edges accurately to ensure the graph correctly represents the problem. 4. Use built-in functions like `maximum_matching` to solve graph-related problems efficiently. 5. Output results in a readable format by iterating through the matching dictionary."
            }
        ]
    },
    {
        "id": 129,
        "problem": "Find a maximum matching in the bipartite graph.",
        "graph_type": "undirected",
        "experience": "The task involved finding a maximum matching in a bipartite graph. A bipartite graph can be effectively handled using the NetworkX library in Python. Here are the summarized steps and practices followed:\n\n1. **Understanding the Input Data**: The graph is represented by nodes with specified connections. Nodes are divided into two sets, 'Nodes_Set_1' and 'Nodes_Set_2'.\n2. **Graph Creation and Library Selection**: The NetworkX library is very suitable for graph-related problems. NetworkX provides built-in functions to handle bipartite graph generation and maximum matching computation.\n3. **Coding Steps**:\n   - Import the NetworkX library.\n   - Parse the input data to extract nodes and edges.\n   - Use the NetworkX bipartite graph creation functions to create and populate the graph.\n   - Use the built-in `maximum_matching` function to find the maximum matching.\n\n4. **Code Output**: The output format needs to be compliant with the requirement for easy extraction by another system.\n\nThis structured approach leads to an effective and efficient solution for the problem.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <13>, <16>.\nNode <1> is connected to nodes <12>, <13>, <15>, <17>.\nNode <2> is connected to nodes <8>, <11>, <12>, <14>, <17>.\nNode <3> is connected to node <10>.\nNode <4> is connected to node <13>.\nNode <5> is connected to nodes <12>, <16>.\nNode <6> is connected to nodes <9>, <11>, <13>.\nNode <7> is connected to nodes <9>, <10>, <11>, <15>.\nNode <8> is connected to node <2>.\nNode <9> is connected to nodes <6>, <7>.\nNode <10> is connected to nodes <3>, <7>.\nNode <11> is connected to nodes <2>, <6>, <7>.\nNode <12> is connected to nodes <1>, <2>, <5>.\nNode <13> is connected to nodes <0>, <1>, <4>, <6>.\nNode <14> is connected to node <2>.\nNode <15> is connected to nodes <1>, <7>.\nNode <16> is connected to nodes <0>, <5>.\nNode <17> is connected to nodes <1>, <2>.\nFind a maximum matching in the bipartite graph.\nNodes set 1 contains: <0> <1> <2> <3> <4> <5> <6> <7>.\nNodes set 2 contains: <8> <9> <10> <11> <12> <13> <14> <15> <16> <17>.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 0, 'Connections': [13, 16]},\n        {'Node': 1, 'Connections': [12, 13, 15, 17]},\n        {'Node': 2, 'Connections': [8, 11, 12, 14, 17]},\n        {'Node': 3, 'Connections': [10]},\n        {'Node': 4, 'Connections': [13]},\n        {'Node': 5, 'Connections': [12, 16]},\n        {'Node': 6, 'Connections': [9, 11, 13]},\n        {'Node': 7, 'Connections': [9, 10, 11, 15]},\n        {'Node': 8, 'Connections': [2]},\n        {'Node': 9, 'Connections': [6, 7]},\n        {'Node': 10, 'Connections': [3, 7]},\n        {'Node': 11, 'Connections': [2, 6, 7]},\n        {'Node': 12, 'Connections': [1, 2, 5]},\n        {'Node': 13, 'Connections': [0, 1, 4, 6]},\n        {'Node': 14, 'Connections': [2]},\n        {'Node': 15, 'Connections': [1, 7]},\n        {'Node': 16, 'Connections': [0, 5]},\n        {'Node': 17, 'Connections': [1, 2]}\n    ],\n    'Nodes_Set_1': [0, 1, 2, 3, 4, 5, 6, 7],\n    'Nodes_Set_2': [8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n}\n\n# Create a bipartite graph\nB = nx.Graph()\n\n# Add nodes and edges based on the input data\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        B.add_edge(node, connection)\n\n# Find maximum matching\nmatching = nx.bipartite.maximum_matching(B)\n\n# Output the matching result\n# Note: The matching dictionary contains pairs, where each key is matched to its value\n# We will print the matching pairs\nmatching_pairs = {k: v for k, v in matching.items() if k in data['Nodes_Set_1']}\nprint(\"Maximum Matching Pairs:\")\nfor u, v in matching_pairs.items():\n    print(f\"Node {u} is matched with Node {v}\")\n",
                "key_api": "NetworkX library, NetworkX.bipartite.maximum_matching",
                "key_experience": "1. Importing necessary libraries at the beginning.\n2. Parsing the input data carefully to extract nodes and their connections.\n3. Utilizing built-in functions from trusted libraries (NetworkX) for complex operations such as creating a bipartite graph and finding maximum matchings.\n4. Maintaining clean and modular code structure for readability and maintainability.\n5. Ensuring the code is formatted and output appropriately for easy extraction and further use."
            }
        ]
    },
    {
        "id": 130,
        "problem": "Find a Hamiltonian path in this graph.",
        "graph_type": "directed",
        "experience": "In this task, the goal was to find a Hamiltonian path in a directed graph. The problem required defining a directed graph using nodes and edges, and then implementing a solution that recursively explores possible paths to determine if a Hamiltonian path exists. The approach involved backtracking to explore all possible paths, ensuring that each node is visited exactly once. The experience highlighted the importance of understanding graph traversal techniques like backtracking, path tracking, and managing visited nodes efficiently.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <8> is connected to nodes <7>, <12>, <19>.\nNode <7> is connected to node <6>.\nNode <12> is connected to nodes <0>, <6>, <18>.\nNode <19> is connected to node <15>.\nNode <6> is connected to node <4>.\nNode <17> is connected to nodes <8>, <9>, <2>, <10>.\nNode <9> is connected to node <4>.\nNode <2> is connected to node <16>.\nNode <10> is connected to nodes <4>, <1>, <0>.\nNode <13> is connected to nodes <18>, <3>, <19>.\nNode <18> is connected to nodes <17>, <8>, <6>.\nNode <3> is connected to nodes <5>, <16>, <15>, <11>, <6>.\nNode <14> is connected to node <17>.\nNode <16> is connected to nodes <17>, <1>, <3>, <7>, <6>.\nNode <1> is connected to nodes <5>, <11>, <14>.\nNode <15> is connected to nodes <14>, <10>, <18>.\nNode <11> is connected to node <2>.\nNode <4> is connected to nodes <14>, <2>, <10>, <3>.\nNode <0> is connected to nodes <7>, <11>.\nNode <5> is connected to nodes <12>, <2>.\nFind a Hamiltonian path in this graph. A Hamiltonian path in a graph is a path that visits each node exactly once, traversing along edges, and the starting node and ending node may be different. \nAnswer:\n",
                "code": "import networkx as nx\n\n# Define the graph\nG = nx.DiGraph()\n\n# Add nodes\nnodes = list(range(20))\nG.add_nodes_from(nodes)\n\n# Define edges\nedges = [\n    (8, 7), (8, 12), (8, 19),\n    (7, 6),\n    (12, 0), (12, 6), (12, 18),\n    (19, 15),\n    (6, 4),\n    (17, 8), (17, 9), (17, 2), (17, 10),\n    (9, 4),\n    (2, 16),\n    (10, 4), (10, 1), (10, 0),\n    (13, 18), (13, 3), (13, 19),\n    (18, 17), (18, 8), (18, 6),\n    (3, 5), (3, 16), (3, 15), (3, 11), (3, 6),\n    (14, 17),\n    (16, 17), (16, 1), (16, 3), (16, 7), (16, 6),\n    (1, 5), (1, 11), (1, 14),\n    (15, 14), (15, 10), (15, 18),\n    (11, 2),\n    (4, 14), (4, 2), (4, 10), (4, 3),\n    (0, 7), (0, 11),\n    (5, 12), (5, 2)\n]\n\nG.add_edges_from(edges)\n\ndef find_hamiltonian_path(G):\n    def backtrack(path, visited):\n        current = path[-1]\n        if len(path) == len(G.nodes):\n            return path\n        for neighbor in G.successors(current):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                path.append(neighbor)\n                result = backtrack(path, visited)\n                if result:\n                    return result\n                path.pop()\n                visited.remove(neighbor)\n        return None\n\n    for node in G.nodes:\n        path = [node]\n        visited = set(path)\n        result = backtrack(path, visited)\n        if result:\n            return result\n    return None\n\nhamiltonian_path = find_hamiltonian_path(G)\nif hamiltonian_path:\n    print(hamiltonian_path)\nelse:\n    print(\"No Hamiltonian Path exists in the graph.\")",
                "key_api": "The key API used was the `networkx.DiGraph` class for defining and managing the directed graph, along with its methods `add_nodes_from`, `add_edges_from`, and `successors` for graph construction and traversal.",
                "key_experience": "1. Efficient graph definition using NetworkX's `DiGraph`. 2. Recursive backtracking to explore all potential paths. 3. Using sets to track visited nodes for efficient lookup. 4. Handling base cases in the recursion for early termination when a Hamiltonian path is found. 5. Starting the search from each node to ensure all possible paths are explored."
            }
        ]
    },
    {
        "id": 131,
        "problem": "Find a Hamiltonian path in this graph.",
        "graph_type": "directed",
        "experience": "The task involved finding a Hamiltonian path in a directed graph, where the path visits each node exactly once. Initially, a brute-force method using permutations was attempted, but it was inefficient and led to a timeout due to the combinatorial explosion. Subsequently, a backtracking approach was implemented, which proved to be more efficient for this task. The backtracking method recursively explores each possible path, building it node by node and backtracking when it reaches a dead end or completes a valid path. This approach efficiently narrows down the search space compared to checking all permutations.",
        "rag_data": [
            {
                "Section ID": "neighbors",
                "Description": [
                    "Returns an iterator over all neighbors of node n.",
                    "This function wraps the G.neighbors function."
                ],
                "Field List": {},
                "Rubrics": {}
            }
        ],
        "accuracy": 0.8,
        "example": [
            {
                "question": "Given a directed graph:\nNode <13> is connected to nodes <14>, <1>.\nNode <14> is connected to nodes <17>, <8>.\nNode <1> is connected to node <4>.\nNode <17> is connected to node <13>.\nNode <8> is connected to nodes <15>, <12>, <5>, <6>.\nNode <11> is connected to node <0>.\nNode <0> is connected to nodes <8>, <15>.\nNode <15> is connected to node <6>.\nNode <12> is connected to node <5>.\nNode <5> is connected to nodes <2>, <12>.\nNode <6> is connected to nodes <1>, <16>, <12>.\nNode <2> is connected to nodes <14>, <8>.\nNode <4> is connected to nodes <13>, <2>, <7>.\nNode <7> is connected to nodes <15>, <10>, <9>.\nNode <16> is connected to node <10>.\nNode <10> is connected to nodes <8>, <0>.\nNode <3> is connected to nodes <6>, <2>, <1>.\nNode <9> is connected to node <11>.\nFind a Hamiltonian path in this graph. A Hamiltonian path in a graph is a path that visits each node exactly once, traversing along edges, and the starting node and ending node may be different. \nAnswer:\n",
                "code": "# Backtracking approach to find Hamiltonian Path\n\n# Graph structure based on the user's description\ngraph = {\n    13: [14, 1],\n    14: [17, 8],\n    1: [4],\n    17: [13],\n    8: [15, 12, 5, 6],\n    11: [0],\n    0: [8, 15],\n    15: [6],\n    12: [5],\n    5: [2, 12],\n    6: [1, 16, 12],\n    2: [14, 8],\n    4: [13, 2, 7],\n    7: [15, 10, 9],\n    16: [10],\n    10: [8, 0],\n    3: [6, 2, 1],\n    9: [11]\n}\n\n# Recursive backtracking function to find Hamiltonian Path\ndef find_hamiltonian_path(graph, path, visited):\n    # If the path includes all nodes, return it as a solution\n    if len(path) == len(graph):\n        return path\n    \n    # Current node is the last in the path\n    current = path[-1]\n    \n    # Explore each neighbor of the current node\n    for neighbor in graph[current]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            result = find_hamiltonian_path(graph, path + [neighbor], visited)\n            if result:\n                return result\n            visited.remove(neighbor)\n    \n    return None\n\n# Function to try starting from each node to find a Hamiltonian path\ndef find_hamiltonian_path_in_graph(graph):\n    for start_node in graph:\n        visited = {start_node}\n        path = find_hamiltonian_path(graph, [start_node], visited)\n        if path:\n            return path\n    return None\n\n# Find the Hamiltonian path\nhamiltonian_path = find_hamiltonian_path_in_graph(graph)\nhamiltonian_path",
                "key_api": "The main Python concepts used included dictionaries for graph representation and sets for tracking visited nodes. Recursive functions were pivotal in implementing the backtracking approach.",
                "key_experience": "Using backtracking to solve the Hamiltonian path problem is a best practice when dealing with graph traversal problems that require visiting each node exactly once. The use of sets to track visited nodes and avoid revisiting them optimizes the search process. Structuring the recursive function to handle path extension and backtracking within the loop through neighbors ensures that all possible paths are considered without redundant computations."
            }
        ]
    },
    {
        "id": 132,
        "problem": "Find a Hamiltonian path in this graph.",
        "graph_type": "undirected",
        "experience": "The task involved solving for a Hamiltonian path in an undirected graph. The approach taken was to recursively explore paths from each node, checking if all nodes could be visited exactly once without repetition. This involved using depth-first search (DFS) principles. The challenge was identifying a path that traverses the graph efficiently while meeting the Hamiltonian path constraints.",
        "rag_data": [],
        "accuracy": 1.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <0> is connected to nodes <3>, <14>, <12>, <7>, <2>.\nNode <3> is connected to nodes <0>, <18>, <14>, <16>, <6>, <4>, <13>, <15>, <5>, <9>.\nNode <14> is connected to nodes <0>, <3>, <11>, <4>, <10>, <8>.\nNode <12> is connected to nodes <0>, <18>, <5>, <13>, <7>, <17>.\nNode <7> is connected to nodes <0>, <18>, <6>, <1>, <12>.\nNode <2> is connected to nodes <0>, <10>, <1>, <17>.\nNode <18> is connected to nodes <3>, <4>, <15>, <8>, <1>, <12>, <7>, <10>, <6>, <16>.\nNode <16> is connected to nodes <3>, <18>, <11>, <6>, <1>, <9>, <5>, <8>, <13>.\nNode <6> is connected to nodes <3>, <18>, <11>, <16>, <13>, <9>, <8>, <5>, <7>.\nNode <4> is connected to nodes <3>, <18>, <14>, <10>, <8>.\nNode <13> is connected to nodes <3>, <6>, <16>, <5>, <12>, <1>, <15>, <17>.\nNode <15> is connected to nodes <3>, <18>, <10>, <11>, <13>, <17>.\nNode <5> is connected to nodes <3>, <10>, <11>, <6>, <16>, <13>, <1>, <12>.\nNode <9> is connected to nodes <3>, <10>, <6>, <16>, <1>.\nNode <8> is connected to nodes <18>, <14>, <6>, <16>, <4>, <17>.\nNode <1> is connected to nodes <18>, <16>, <5>, <13>, <9>, <2>, <7>.\nNode <10> is connected to nodes <18>, <14>, <11>, <5>, <17>, <2>, <4>, <9>, <15>.\nNode <11> is connected to nodes <14>, <10>, <16>, <15>, <6>, <5>.\nNode <17> is connected to nodes <10>, <13>, <2>, <15>, <12>, <8>.\nFind a Hamiltonian path in this graph. A Hamiltonian path in a graph is a path that visits each node exactly once, traversing along edges, and the starting node and ending node may be different. \nAnswer:\n",
                "code": "import networkx as nx\nfrom itertools import permutations\n\n# Define the graph\nedges = [\n    (0, 3), (0, 14), (0, 12), (0, 7), (0, 2),\n    (3, 0), (3, 18), (3, 14), (3, 16), (3, 6), (3, 4), (3, 13), (3, 15), (3, 5), (3, 9),\n    (14, 0), (14, 3), (14, 11), (14, 4), (14, 10), (14, 8),\n    (12, 0), (12, 18), (12, 5), (12, 13), (12, 7), (12, 17),\n    (7, 0), (7, 18), (7, 6), (7, 1), (7, 12),\n    (2, 0), (2, 10), (2, 1), (2, 17),\n    (18, 3), (18, 4), (18, 15), (18, 8), (18, 1), (18, 12), (18, 7), (18, 10), (18, 6), (18, 16),\n    (16, 3), (16, 18), (16, 11), (16, 6), (16, 1), (16, 9), (16, 5), (16, 8), (16, 13),\n    (6, 3), (6, 18), (6, 11), (6, 16), (6, 13), (6, 9), (6, 8), (6, 5), (6, 7),\n    (4, 3), (4, 18), (4, 14), (4, 10), (4, 8),\n    (13, 3), (13, 6), (13, 16), (13, 5), (13, 12), (13, 1), (13, 15), (13, 17),\n    (15, 3), (15, 18), (15, 10), (15, 11), (15, 13), (15, 17),\n    (5, 3), (5, 10), (5, 11), (5, 6), (5, 16), (5, 13), (5, 1), (5, 12),\n    (9, 3), (9, 10), (9, 6), (9, 16), (9, 1),\n    (8, 18), (8, 14), (8, 6), (8, 16), (8, 4), (8, 17),\n    (1, 18), (1, 16), (1, 5), (1, 13), (1, 9), (1, 2), (1, 7),\n    (10, 18), (10, 14), (10, 11), (10, 5), (10, 17), (10, 2), (10, 4), (10, 9), (10, 15),\n    (11, 14), (11, 10), (11, 16), (11, 15), (11, 6), (11, 5),\n    (17, 10), (17, 13), (17, 2), (17, 15), (17, 12), (17, 8)\n]\n\n# Create a graph\nG = nx.Graph()\nG.add_edges_from(edges)\n\n# Function to find a Hamiltonian path\ndef hamiltonian_path_util(graph, path, visited):\n    if len(path) == len(graph.nodes):\n        return path\n\n    current_node = path[-1]\n\n    for neighbor in graph.neighbors(current_node):\n        if neighbor not in visited:\n            visited.add(neighbor)\n            result = hamiltonian_path_util(graph, path + [neighbor], visited)\n            if result:\n                return result\n            visited.remove(neighbor)\n    return None\n\ndef find_hamiltonian_path(graph):\n    for start_node in graph.nodes():\n        visited = {start_node}\n        path = hamiltonian_path_util(graph, [start_node], visited)\n        if path:\n            return path\n    return None\n\n# Find the Hamiltonian path\nhamiltonian_path = find_hamiltonian_path(G)\nhamiltonian_path",
                "key_api": "The key API used was the 'networkx' library, specifically its methods to handle graph structures, node neighbors, and traversal algorithms. This included methods like 'graph.neighbors()' and recursive DFS logic for path exploration.",
                "key_experience": "The best practices included: \n  1. Recursion to handle path traversal in a structured way.\n  2. Keeping track of visited nodes to prevent cycles and revisiting nodes.\n  3. Iterating through possible start nodes to ensure all potential Hamiltonian paths are explored.\n  4. Checking path length to validate that all nodes have been visited, ensuring a valid solution."
            }
        ]
    },
    {
        "id": 133,
        "problem": "Find a Hamiltonian path in this graph.",
        "graph_type": "undirected",
        "experience": "The experience involved solving a Hamiltonian Path problem in a graph. Initially, a brute-force solution was considered using permutations of the nodes, which was inefficient for larger graphs. The final approach shifted to a more optimal backtracking method that builds the path incrementally and ensures validity at each step. This provided a more efficient solution while maintaining correctness. The problem was solved by understanding the structure of the graph, exploring recursive strategies, and applying constraints to prune invalid solutions early.",
        "rag_data": [],
        "accuracy": 0.9444444439999999,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <11> is connected to nodes <6>, <1>, <12>, <15>.\nNode <6> is connected to nodes <11>, <7>, <1>.\nNode <1> is connected to nodes <11>, <6>, <15>.\nNode <12> is connected to nodes <11>, <9>, <17>.\nNode <15> is connected to nodes <11>, <1>, <7>.\nNode <7> is connected to nodes <6>, <8>, <15>.\nNode <3> is connected to nodes <18>, <0>, <2>.\nNode <18> is connected to node <3>.\nNode <0> is connected to nodes <3>, <9>, <16>, <5>.\nNode <2> is connected to nodes <3>, <14>, <16>.\nNode <14> is connected to nodes <2>, <13>, <5>.\nNode <13> is connected to nodes <14>, <17>, <4>.\nNode <5> is connected to nodes <14>, <0>.\nNode <16> is connected to nodes <2>, <0>.\nNode <8> is connected to nodes <7>, <4>.\nNode <4> is connected to nodes <8>, <10>, <13>.\nNode <10> is connected to nodes <9>, <4>.\nNode <9> is connected to nodes <10>, <12>, <0>.\nNode <17> is connected to nodes <12>, <13>.\nFind a Hamiltonian path in this graph. A Hamiltonian path in a graph is a path that visits each node exactly once, traversing along edges, and the starting node and ending node may be different. \nAnswer:\n",
                "code": "import networkx as nx\n\n# Input data\nnodes = [11, 6, 1, 12, 15, 7, 3, 18, 0, 2, 14, 13, 5, 16, 8, 4, 10, 9, 17]\nedges = [[11, 6], [11, 1], [11, 12], [11, 15], [6, 7], [6, 1], [1, 15], [12, 9], [12, 17], [15, 7], [7, 8], [3, 18], [3, 0], [3, 2], [0, 9], [0, 16], [0, 5], [2, 14], [2, 16], [14, 13], [14, 5], [13, 17], [13, 4], [5, 14], [8, 4], [4, 10], [10, 9]]\n\n# Create the graph\nG = nx.Graph()\nG.add_nodes_from(nodes)\nG.add_edges_from(edges)\n\n# Function to check if the current path is Hamiltonian\ndef is_valid_vertex(v, pos, path, G):\n    # Check if this vertex is an adjacent vertex of the previously added vertex in path\n    if v not in G[path[pos - 1]]:\n        return False\n    # Check if the vertex has already been included in the path\n    if v in path:\n        return False\n    return True\n\n# Recursive utility function to solve the Hamiltonian Path problem\ndef hamiltonian_path_util(G, path, pos):\n    # Base case: If all vertices are included in the path\n    if pos == len(G.nodes):\n        return True\n\n    # Try different vertices as the next candidate in the Hamiltonian path\n    for v in G.nodes:\n        if is_valid_vertex(v, pos, path, G):\n            path[pos] = v\n            # Recur to construct rest of the path\n            if hamiltonian_path_util(G, path, pos + 1):\n                return True\n            # If adding vertex v doesn't lead to a solution, remove it\n            path[pos] = -1\n\n    return False\n\n# Function to find a Hamiltonian Path\ndef find_hamiltonian_path(G):\n    path = [-1] * len(G.nodes)\n\n    # Let\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u00a1\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u00afs start with the first node (can be any node in the graph)\n    for starting_node in G.nodes:\n        path[0] = starting_node\n        if hamiltonian_path_util(G, path, 1):\n            return path\n    \n    return None\n\n# Find and print the Hamiltonian path\nhamiltonian_path = find_hamiltonian_path(G)\nprint(hamiltonian_path if hamiltonian_path else \"No Hamiltonian Path found\")",
                "key_api": "The key API used in the code was `networkx`, specifically the functions `add_nodes_from`, `add_edges_from`, and general graph traversal logic.",
                "key_experience": "1. Adopted a backtracking algorithm to explore possible paths without generating unnecessary permutations. 2. Used early termination and pruning techniques in recursive calls to stop exploring invalid paths. 3. Leveraged graph adjacency checks to ensure only valid steps were taken when constructing the path, ensuring efficiency."
            }
        ]
    },
    {
        "id": 134,
        "problem": "Output a sequence of traversal in depth-first search [DFS] order starting from node <16>",
        "graph_type": "undirected",
        "experience": "In a recent task, users needed to perform a depth-first search traversal starting from a specific node in a graph defined by given nodes and edges. The task utilized the NetworkX library for graph operations.",
        "rag_data": [
            {
                "Section ID": "dfs_preorder_nodes",
                "Description": [
                    "Generate nodes in a depth-first-search pre-ordering starting at source."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node, optional": "Specify starting node for depth-first search and return nodes in\nthe component reachable from source.",
                        "depth_limit : int, optional (default=len(G))": "Specify the maximum search depth.",
                        "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
                    },
                    "Returns:": {
                        "nodes: generator": "A generator of nodes in a depth-first-search pre-ordering."
                    }
                },
                "Rubrics": {
                    "Notes": "If a source is not specified then a source is chosen arbitrarily and\nrepeatedly until all components in the graph are searched. The implementation of this function is adapted from David Eppstein\u2019s\ndepth-first search function in PADS , with modifications\nto allow depth limits based on the Wikipedia article\n\u201c Depth-limited search \u201d.",
                    "Examples": "G=nx.path_graph(5)\nlist(nx.dfs_preorder_nodes(G,source=0))\n# [0, 1, 2, 3, 4]\nlist(nx.dfs_preorder_nodes(G,source=0,depth_limit=2))\n# [0, 1, 2]"
                }
            }
        ],
        "accuracy": 0.95,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <19> is connected to nodes <2>, <16>, <6>, <8>, <7>, <14>, <4>, <13>, <12>, <3>, <9>.\nNode <2> is connected to node <19>.\nNode <16> is connected to nodes <19>, <15>.\nNode <6> is connected to node <19>.\nNode <8> is connected to node <19>.\nNode <7> is connected to nodes <19>, <18>, <1>, <11>.\nNode <14> is connected to nodes <19>, <17>.\nNode <4> is connected to node <19>.\nNode <13> is connected to node <19>.\nNode <12> is connected to node <19>.\nNode <3> is connected to node <19>.\nNode <9> is connected to node <19>.\nNode <17> is connected to nodes <0>, <14>, <10>, <5>.\nNode <0> is connected to node <17>.\nNode <10> is connected to node <17>.\nNode <5> is connected to node <17>.\nNode <18> is connected to node <7>.\nNode <1> is connected to node <7>.\nNode <11> is connected to node <7>.\nNode <15> is connected to node <16>.\nStart from node <16>, output a sequence of traversal in depth-first search (DFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input graph data\ninput_data = {\n    'Nodes': [19, 2, 16, 6, 8, 7, 14, 4, 13, 12, 3, 9, 17, 0, 10, 5, 18, 1, 11, 15],\n    'Edges': [[19, 2], [19, 16], [19, 6], [19, 8], [19, 7], [19, 14], \n              [19, 4], [19, 13], [19, 12], [19, 3], [19, 9], [16, 15], \n              [17, 0], [17, 10], [17, 5], [7, 18], [7, 1], [7, 11], \n              [14, 17]]\n}\n\n# Create a directed graph from the input data\nG = nx.DiGraph()\nG.add_nodes_from(input_data['Nodes'])\nG.add_edges_from(input_data['Edges'])\n\n# Perform depth-first search starting from node 16\ndfs_traversal = list(nx.dfs_preorder_nodes(G, source=16))\n\n# Output the DFS traversal order\nprint(dfs_traversal)\n",
                "key_api": "The key API used in this code was `networkx.dfs_preorder_nodes` to perform a depth-first search traversal of the graph starting from a specified node.",
                "key_experience": "Best practices included creating a directed graph using `nx.DiGraph`, adding nodes and edges to the graph with `add_nodes_from` and `add_edges_from`, executing the DFS traversal with `dfs_preorder_nodes`, and finally, outputting the traversal sequence."
            }
        ]
    },
    {
        "id": 135,
        "problem": "Output a sequence of traversal in depth-first search [DFS] order starting from node <8>",
        "graph_type": "undirected",
        "experience": "Analyzed the input graph structure, constructed the graph using NetworkX, added all necessary edges based on node connections, and performed a depth-first search (DFS) traversal starting from the specified node.",
        "rag_data": [],
        "accuracy": 0.95,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <15> is connected to nodes <7>, <12>, <0>, <17>.\nNode <7> is connected to nodes <15>, <1>, <4>, <6>, <10>, <13>, <5>, <14>, <8>.\nNode <12> is connected to nodes <15>, <11>, <2>.\nNode <0> is connected to node <15>.\nNode <17> is connected to node <15>.\nNode <1> is connected to node <7>.\nNode <4> is connected to node <7>.\nNode <6> is connected to nodes <7>, <9>, <3>.\nNode <10> is connected to node <7>.\nNode <13> is connected to node <7>.\nNode <5> is connected to nodes <7>, <16>.\nNode <14> is connected to node <7>.\nNode <8> is connected to node <7>.\nNode <11> is connected to node <12>.\nNode <2> is connected to node <12>.\nNode <16> is connected to node <5>.\nNode <9> is connected to node <6>.\nNode <3> is connected to node <6>.\nStart from node <8>, output a sequence of traversal in depth-first search (DFS) order.\nAnswer:\n",
                "code": "import networkx as nx\n\n# Define the graph\nG = nx.Graph()\n\n# Define the nodes and their connections\nnodes = [\n    {'Node': 15, 'Connections': [7, 12, 0, 17]},\n    {'Node': 7, 'Connections': [15, 1, 4, 6, 10, 13, 5, 14, 8]},\n    {'Node': 12, 'Connections': [15, 11, 2]},\n    {'Node': 0, 'Connections': [15]},\n    {'Node': 17, 'Connections': [15]},\n    {'Node': 1, 'Connections': [7]},\n    {'Node': 4, 'Connections': [7]},\n    {'Node': 6, 'Connections': [7, 9, 3]},\n    {'Node': 10, 'Connections': [7]},\n    {'Node': 13, 'Connections': [7]},\n    {'Node': 5, 'Connections': [7, 16]},\n    {'Node': 14, 'Connections': [7]},\n    {'Node': 8, 'Connections': [7]},\n    {'Node': 11, 'Connections': [12]},\n    {'Node': 2, 'Connections': [12]},\n    {'Node': 16, 'Connections': [5]},\n    {'Node': 9, 'Connections': [6]},\n    {'Node': 3, 'Connections': [6]}\n]\n\n# Add edges to the graph\nfor node in nodes:\n    for conn in node['Connections']:\n        G.add_edge(node['Node'], conn)\n\n# Perform DFS starting from node 8\ndfs_traversal = list(nx.dfs_preorder_nodes(G, source=8))\n\nprint(dfs_traversal)",
                "key_api": "networkx.Graph(), G.add_edge(), networkx.dfs_preorder_nodes()",
                "key_experience": "Structured the graph data clearly, iterated through nodes to add connections systematically, utilized built-in NetworkX functions for efficient graph traversal, and ensured the code is readable and maintainable by following standard coding conventions."
            }
        ]
    },
    {
        "id": 136,
        "problem": "Output a sequence of traversal in depth-first search [DFS] order starting from node <3>",
        "graph_type": "directed",
        "experience": "The task involved writing Python code to output a sequence of DFS traversal starting from node 3. The key steps included parsing the input data, constructing the graph using NetworkX, performing DFS, and finally printing the traversal sequence.",
        "rag_data": [],
        "accuracy": 0.666666668,
        "example": [
            {
                "question": "Given a directed graph:\nNode <14> is connected to nodes <12>, <15>, <10>.\nNode <12> is connected to nodes <9>, <15>.\nNode <15> is connected to nodes <1>, <10>, <14>, <16>.\nNode <10> is connected to node <0>.\nNode <16> is connected to nodes <12>, <7>.\nNode <7> is connected to nodes <13>, <15>, <10>.\nNode <9> is connected to nodes <0>, <10>, <2>, <5>, <16>.\nNode <6> is connected to nodes <13>, <11>, <16>.\nNode <13> is connected to nodes <1>, <0>, <16>, <9>.\nNode <11> is connected to nodes <13>, <3>, <10>, <4>.\nNode <0> is connected to nodes <8>, <14>, <12>, <3>.\nNode <2> is connected to nodes <5>, <6>, <15>.\nNode <5> is connected to nodes <9>, <13>, <1>.\nNode <1> is connected to node <6>.\nNode <3> is connected to nodes <10>, <4>, <5>, <6>.\nNode <4> is connected to nodes <6>, <3>, <15>, <1>, <2>.\nNode <8> is connected to nodes <5>, <10>.\nStart from node <3>, output a sequence of traversal in depth-first search (DFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'nodes': [\n        {'node': 14, 'connections': [12, 15, 10]},\n        {'node': 12, 'connections': [9, 15]},\n        {'node': 15, 'connections': [1, 10, 14, 16]},\n        {'node': 10, 'connections': [0]},\n        {'node': 16, 'connections': [12, 7]},\n        {'node': 7, 'connections': [13, 15, 10]},\n        {'node': 9, 'connections': [0, 10, 2, 5, 16]},\n        {'node': 6, 'connections': [13, 11, 16]},\n        {'node': 13, 'connections': [1, 0, 16, 9]},\n        {'node': 11, 'connections': [13, 3, 10, 4]},\n        {'node': 0, 'connections': [8, 14, 12, 3]},\n        {'node': 2, 'connections': [5, 6, 15]},\n        {'node': 5, 'connections': [9, 13, 1]},\n        {'node': 1, 'connections': [6]},\n        {'node': 3, 'connections': [10, 4, 5, 6]},\n        {'node': 4, 'connections': [6, 3, 15, 1, 2]},\n        {'node': 8, 'connections': [5, 10]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in input_data['nodes']:\n    node = node_info['node']\n    connections = node_info['connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Perform depth-first search (DFS) starting from node 3\ndfs_traversal = list(nx.dfs_preorder_nodes(G, source=3))\n\n# Output the sequence of traversal\nprint(dfs_traversal)\n",
                "key_api": "The key API used was the NetworkX library, specifically the functions for adding nodes and edges and performing a depth-first search.",
                "key_experience": "Best practices included clearly defining the input data, using a well-regarded graph processing library (NetworkX), and ensuring the output format matched the required traversal sequence."
            }
        ]
    },
    {
        "id": 137,
        "problem": "Output a sequence of traversal in depth-first search [DFS] order starting from node <3>",
        "graph_type": "directed",
        "experience": "Successfully implemented a depth-first search (DFS) algorithm to traverse a graph starting from a specified node. The task required creating a graph using the networkx library in Python and performing DFS to output the traversal sequence.",
        "rag_data": [],
        "accuracy": 0.666666668,
        "example": [
            {
                "question": "Given a directed graph:\nNode <12> is connected to nodes <9>, <11>, <0>, <13>, <8>, <15>.\nNode <9> is connected to nodes <4>, <7>, <3>, <0>, <1>, <12>.\nNode <11> is connected to nodes <14>, <6>, <1>, <9>.\nNode <0> is connected to nodes <15>, <2>, <4>, <7>.\nNode <13> is connected to nodes <15>, <2>, <4>, <10>, <14>.\nNode <8> is connected to nodes <15>, <2>, <9>, <11>, <7>, <14>, <13>.\nNode <15> is connected to nodes <2>, <9>, <7>, <3>, <6>, <0>, <13>, <5>.\nNode <2> is connected to nodes <4>, <10>, <3>, <0>, <5>, <15>.\nNode <4> is connected to nodes <14>, <6>, <0>, <12>, <2>.\nNode <10> is connected to nodes <7>, <14>, <0>, <5>, <1>, <8>, <2>, <9>, <4>.\nNode <3> is connected to nodes <0>, <13>, <5>, <8>, <9>, <4>, <11>, <7>.\nNode <5> is connected to nodes <1>, <15>, <2>, <4>, <11>, <7>.\nNode <7> is connected to nodes <3>, <14>, <6>, <0>, <13>, <8>, <2>, <11>.\nNode <1> is connected to nodes <8>, <12>, <3>, <5>.\nNode <14> is connected to nodes <0>, <13>, <1>, <15>, <12>, <4>, <10>.\nNode <6> is connected to nodes <13>, <2>, <9>, <4>, <3>, <14>.\nStart from node <3>, output a sequence of traversal in depth-first search (DFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [\n        {'Node': 12, 'Connections': [9, 11, 0, 13, 8, 15]},\n        {'Node': 9, 'Connections': [4, 7, 3, 0, 1, 12]},\n        {'Node': 11, 'Connections': [14, 6, 1, 9]},\n        {'Node': 0, 'Connections': [15, 2, 4, 7]},\n        {'Node': 13, 'Connections': [15, 2, 4, 10, 14]},\n        {'Node': 8, 'Connections': [15, 2, 9, 11, 7, 14, 13]},\n        {'Node': 15, 'Connections': [2, 9, 7, 3, 6, 0, 13, 5]},\n        {'Node': 2, 'Connections': [4, 10, 3, 0, 5, 15]},\n        {'Node': 4, 'Connections': [14, 6, 0, 12, 2]},\n        {'Node': 10, 'Connections': [7, 14, 0, 5, 1, 8, 2, 9, 4]},\n        {'Node': 3, 'Connections': [0, 13, 5, 8, 9, 4, 11, 7]},\n        {'Node': 5, 'Connections': [1, 15, 2, 4, 11, 7]},\n        {'Node': 7, 'Connections': [3, 14, 6, 0, 13, 8, 2, 11]},\n        {'Node': 1, 'Connections': [8, 12, 3, 5]},\n        {'Node': 14, 'Connections': [0, 13, 1, 15, 12, 4, 10]},\n        {'Node': 6, 'Connections': [13, 2, 9, 4, 3, 14]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node in input_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Perform DFS starting from node 3\ndfs_traversal = list(nx.dfs_preorder_nodes(G, source=3))\n\n# Output the DFS traversal sequence\nprint(dfs_traversal)\n",
                "key_api": "networkx (nx)",
                "key_experience": "['Translate provided data into a format compatible with the networkx library.', 'Use networkx to create a graph structure from the input data.', 'Implement and execute the DFS algorithm.', 'Use efficient stack-based DFS implementation to handle traversal and avoid recursion limits.']"
            }
        ]
    },
    {
        "id": 138,
        "problem": "Output a sequence of traversal in breadth-first search [BFS] order starting from node <15>",
        "graph_type": "directed",
        "experience": "The recent engagement focused on solving a problem related to performing a breadth-first search (BFS) traversal starting from a given node on a directed graph.",
        "rag_data": [],
        "accuracy": 0.888888888,
        "example": [
            {
                "question": "Given a directed graph:\nNode <0> is connected to node <2>.\nNode <2> is connected to nodes <3>, <4>, <9>, <12>, <19>.\nNode <10> is connected to nodes <13>, <12>, <2>, <5>, <3>.\nNode <13> is connected to nodes <17>, <8>, <9>, <11>.\nNode <12> is connected to nodes <6>, <3>.\nNode <5> is connected to nodes <19>, <2>.\nNode <3> is connected to nodes <8>, <13>.\nNode <9> is connected to nodes <6>, <15>, <5>, <8>.\nNode <6> is connected to nodes <15>, <18>, <17>.\nNode <15> is connected to node <7>.\nNode <8> is connected to nodes <6>, <7>, <3>.\nNode <16> is connected to nodes <12>, <5>, <9>.\nNode <11> is connected to nodes <5>, <7>, <0>, <10>.\nNode <7> is connected to node <8>.\nNode <17> is connected to node <8>.\nNode <1> is connected to nodes <6>, <3>.\nNode <18> is connected to nodes <7>, <16>.\nNode <19> is connected to node <12>.\nNode <4> is connected to nodes <5>, <17>.\nNode <14> is connected to nodes <3>, <15>.\nStart from node <15>, output a sequence of traversal in breadth-first search (BFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\nfrom collections import deque\n\n# Input data\ndata = {\n    'nodes': [\n        {'node': 0, 'connected_to': [2]},\n        {'node': 2, 'connected_to': [3, 4, 9, 12, 19]},\n        {'node': 10, 'connected_to': [13, 12, 2, 5, 3]},\n        {'node': 13, 'connected_to': [17, 8, 9, 11]},\n        {'node': 12, 'connected_to': [6, 3]},\n        {'node': 5, 'connected_to': [19, 2]},\n        {'node': 3, 'connected_to': [8, 13]},\n        {'node': 9, 'connected_to': [6, 15, 5, 8]},\n        {'node': 6, 'connected_to': [15, 18, 17]},\n        {'node': 15, 'connected_to': [7]},\n        {'node': 8, 'connected_to': [6, 7, 3]},\n        {'node': 16, 'connected_to': [12, 5, 9]},\n        {'node': 11, 'connected_to': [5, 7, 0, 10]},\n        {'node': 7, 'connected_to': [8]},\n        {'node': 17, 'connected_to': [8]},\n        {'node': 1, 'connected_to': [6, 3]},\n        {'node': 18, 'connected_to': [7, 16]},\n        {'node': 19, 'connected_to': [12]},\n        {'node': 4, 'connected_to': [5, 17]},\n        {'node': 14, 'connected_to': [3, 15]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node_info in data['nodes']:\n    node = node_info['node']\n    for connected_node in node_info['connected_to']:\n        G.add_edge(node, connected_node)\n\n# Function to perform BFS traversal\ndef bfs_traversal(graph, start_node):\n    visited = set()\n    queue = deque([start_node])\n    traversal_order = []\n\n    while queue:\n        current_node = queue.popleft()\n        if current_node not in visited:\n            visited.add(current_node)\n            traversal_order.append(current_node)\n            # Add connected nodes to the queue\n            queue.extend(neighbor for neighbor in graph[current_node] if neighbor not in visited)\n    \n    return traversal_order\n\n# Perform BFS starting from node 15\nbfs_result = bfs_traversal(G, 15)\n\n# Output the BFS traversal order\nprint(bfs_result)\n",
                "key_api": "networkx (for graph creation and manipulation), collections.deque (for efficient queue operations in BFS)",
                "key_experience": "['Using networkx.DiGraph to create a directed graph.', 'Adding edges to the graph by iterating through input data.', 'Using a deque from the collections module for efficient pop and append operations during BFS traversal.', 'Maintaining a set for visited nodes to avoid revisiting.', 'Appending the traversal order as nodes are visited.', 'Extending the queue with unvisited neighboring nodes for further traversal.']"
            }
        ]
    },
    {
        "id": 139,
        "problem": "Output a sequence of traversal in breadth-first search [BFS] order starting from node <15>",
        "graph_type": "directed",
        "experience": "The recent engagement focused on solving a problem related to performing a breadth-first search (BFS) traversal starting from a given node on a directed graph.",
        "rag_data": [],
        "accuracy": 0.888888888,
        "example": [
            {
                "question": "Given a directed graph:\nNode <0> is connected to node <2>.\nNode <2> is connected to nodes <3>, <4>, <9>, <12>, <19>.\nNode <10> is connected to nodes <13>, <12>, <2>, <5>, <3>.\nNode <13> is connected to nodes <17>, <8>, <9>, <11>.\nNode <12> is connected to nodes <6>, <3>.\nNode <5> is connected to nodes <19>, <2>.\nNode <3> is connected to nodes <8>, <13>.\nNode <9> is connected to nodes <6>, <15>, <5>, <8>.\nNode <6> is connected to nodes <15>, <18>, <17>.\nNode <15> is connected to node <7>.\nNode <8> is connected to nodes <6>, <7>, <3>.\nNode <16> is connected to nodes <12>, <5>, <9>.\nNode <11> is connected to nodes <5>, <7>, <0>, <10>.\nNode <7> is connected to node <8>.\nNode <17> is connected to node <8>.\nNode <1> is connected to nodes <6>, <3>.\nNode <18> is connected to nodes <7>, <16>.\nNode <19> is connected to node <12>.\nNode <4> is connected to nodes <5>, <17>.\nNode <14> is connected to nodes <3>, <15>.\nStart from node <15>, output a sequence of traversal in breadth-first search (BFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\nfrom collections import deque\n\n# Input data\ndata = {\n    'nodes': [\n        {'node': 0, 'connected_to': [2]},\n        {'node': 2, 'connected_to': [3, 4, 9, 12, 19]},\n        {'node': 10, 'connected_to': [13, 12, 2, 5, 3]},\n        {'node': 13, 'connected_to': [17, 8, 9, 11]},\n        {'node': 12, 'connected_to': [6, 3]},\n        {'node': 5, 'connected_to': [19, 2]},\n        {'node': 3, 'connected_to': [8, 13]},\n        {'node': 9, 'connected_to': [6, 15, 5, 8]},\n        {'node': 6, 'connected_to': [15, 18, 17]},\n        {'node': 15, 'connected_to': [7]},\n        {'node': 8, 'connected_to': [6, 7, 3]},\n        {'node': 16, 'connected_to': [12, 5, 9]},\n        {'node': 11, 'connected_to': [5, 7, 0, 10]},\n        {'node': 7, 'connected_to': [8]},\n        {'node': 17, 'connected_to': [8]},\n        {'node': 1, 'connected_to': [6, 3]},\n        {'node': 18, 'connected_to': [7, 16]},\n        {'node': 19, 'connected_to': [12]},\n        {'node': 4, 'connected_to': [5, 17]},\n        {'node': 14, 'connected_to': [3, 15]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node_info in data['nodes']:\n    node = node_info['node']\n    for connected_node in node_info['connected_to']:\n        G.add_edge(node, connected_node)\n\n# Function to perform BFS traversal\ndef bfs_traversal(graph, start_node):\n    visited = set()\n    queue = deque([start_node])\n    traversal_order = []\n\n    while queue:\n        current_node = queue.popleft()\n        if current_node not in visited:\n            visited.add(current_node)\n            traversal_order.append(current_node)\n            # Add connected nodes to the queue\n            queue.extend(neighbor for neighbor in graph[current_node] if neighbor not in visited)\n    \n    return traversal_order\n\n# Perform BFS starting from node 15\nbfs_result = bfs_traversal(G, 15)\n\n# Output the BFS traversal order\nprint(bfs_result)\n",
                "key_api": "networkx (for graph creation and manipulation), collections.deque (for efficient queue operations in BFS)",
                "key_experience": "['Using networkx.DiGraph to create a directed graph.', 'Adding edges to the graph by iterating through input data.', 'Using a deque from the collections module for efficient pop and append operations during BFS traversal.', 'Maintaining a set for visited nodes to avoid revisiting.', 'Appending the traversal order as nodes are visited.', 'Extending the queue with unvisited neighboring nodes for further traversal.']"
            }
        ]
    },
    {
        "id": 140,
        "problem": "Output a sequence of traversal in breadth-first search [BFS] order starting from node <4>",
        "graph_type": "undirected",
        "experience": "In the recent engagement, the task was to perform a Breadth-First Search (BFS) traversal starting from a specified node (node 4) in a graph. The user provided a structured graph data as input, and the sequence of traversal needed to be output in BFS order.",
        "rag_data": [
            {
                "Section ID": "bfs_edges",
                "Description": [
                    "Iterate over edges in a breadth-first-search starting at source."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX graph": "",
                        "source : node": "Specify starting node for breadth-first search; this function\niterates over only those edges in the component reachable from\nthis node.",
                        "reverse : bool, optional": "If True traverse a directed graph in the reverse direction",
                        "depth_limit : int, optional(default=len(G))": "Specify the maximum search depth",
                        "sort_neighbors : function (default=None)": "A function that takes an iterator over nodes as the input, and\nreturns an iterable of the same nodes with a custom ordering.\nFor example,sortedwill sort the nodes in increasing order."
                    },
                    "Yields:": {
                        "edge: 2-tuple of nodes": "Yields edges resulting from the breadth-first search."
                    }
                },
                "Rubrics": {
                    "Notes": "The naming of this function is very similar to edge_bfs() . The difference\nis that edge_bfs yields edges even if they extend back to an already\nexplored node while this generator yields the edges of the tree that results\nfrom a breadth-first-search (BFS) so no edges are reported if they extend\nto already explored nodes. That means edge_bfs reports all edges while bfs_edges only reports those traversed by a node-based BFS. Yet another\ndescription is that bfs_edges reports the edges traversed during BFS\nwhile edge_bfs reports all edges in the order they are explored. Based on the breadth-first search implementation in PADS [1] by D. Eppstein, July 2004; with modifications to allow depth limits\nas described in [2] .",
                    "References": "[1]http://www.ics.uci.edu/~eppstein/PADS/BFS.py.  [2]https://en.wikipedia.org/wiki/Depth-limited_search",
                    "Examples": "To get the edges in a breadth-first search:\nG=nx.path_graph(3)\nlist(nx.bfs_edges(G,0))\n# [(0, 1), (1, 2)]\nlist(nx.bfs_edges(G,source=0,depth_limit=1))\n# [(0, 1)]\nTo get the nodes in a breadth-first search order:\nG=nx.path_graph(3)\nroot=2\nedges=nx.bfs_edges(G,root)\nnodes=[root]+[vforu,vinedges]\nnodes\n# [2, 1, 0]"
                }
            }
        ],
        "accuracy": 0.8,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <5> is connected to nodes <3>, <12>, <8>, <11>, <4>.\nNode <3> is connected to nodes <5>, <13>.\nNode <12> is connected to nodes <5>, <13>, <8>, <17>.\nNode <8> is connected to nodes <5>, <13>, <9>, <12>, <0>, <14>, <2>, <7>, <10>.\nNode <11> is connected to nodes <5>, <7>.\nNode <4> is connected to nodes <5>, <16>.\nNode <13> is connected to nodes <3>, <16>, <8>, <17>, <14>, <15>, <2>, <12>, <9>.\nNode <16> is connected to nodes <4>, <0>, <13>, <10>.\nNode <0> is connected to nodes <16>, <8>, <7>.\nNode <10> is connected to nodes <16>, <8>, <1>, <15>.\nNode <17> is connected to nodes <13>, <12>.\nNode <14> is connected to nodes <13>, <8>, <6>.\nNode <15> is connected to nodes <13>, <10>.\nNode <2> is connected to nodes <13>, <8>.\nNode <9> is connected to nodes <13>, <8>, <1>.\nNode <7> is connected to nodes <8>, <11>, <0>, <6>.\nNode <1> is connected to nodes <9>, <10>.\nNode <6> is connected to nodes <7>, <14>.\nStart from node <4>, output a sequence of traversal in breadth-first search (BFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ngraph_data = {\n    'Nodes': [\n        {'Node': 5, 'Connections': [3, 12, 8, 11, 4]},\n        {'Node': 3, 'Connections': [5, 13]},\n        {'Node': 12, 'Connections': [5, 13, 8, 17]},\n        {'Node': 8, 'Connections': [5, 13, 9, 12, 0, 14, 2, 7, 10]},\n        {'Node': 11, 'Connections': [5, 7]},\n        {'Node': 4, 'Connections': [5, 16]},\n        {'Node': 13, 'Connections': [3, 16, 8, 17, 14, 15, 2, 12, 9]},\n        {'Node': 16, 'Connections': [4, 0, 13, 10]},\n        {'Node': 0, 'Connections': [16, 8, 7]},\n        {'Node': 10, 'Connections': [16, 8, 1, 15]},\n        {'Node': 17, 'Connections': [13, 12]},\n        {'Node': 14, 'Connections': [13, 8, 6]},\n        {'Node': 15, 'Connections': [13, 10]},\n        {'Node': 2, 'Connections': [13, 8]},\n        {'Node': 9, 'Connections': [13, 8, 1]},\n        {'Node': 7, 'Connections': [8, 11, 0, 6]},\n        {'Node': 1, 'Connections': [9, 10]},\n        {'Node': 6, 'Connections': [7, 14]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add nodes and edges to the graph\nfor node in graph_data['Nodes']:\n    G.add_node(node['Node'])\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Perform BFS starting from node 4\nbfs_traversal = list(nx.bfs_edges(G, source=4))\n\n# Extract the order of traversal\nbfs_order = []\nfor edge in bfs_traversal:\n    if edge[0] not in bfs_order:\n        bfs_order.append(edge[0])\n    if edge[1] not in bfs_order:\n        bfs_order.append(edge[1])\n\n# Output the BFS order\nprint(\"BFS Traversal Order starting from node 4:\", bfs_order)\n",
                "key_api": "networkx.bfs_edges(G, source=4)",
                "key_experience": "['Creating an undirected graph using NetworkX.', 'Adding nodes and edges to the graph from structured data.', 'Using the bfs_edges function from NetworkX to execute the BFS traversal.', 'Extracting the BFS order from the sequence of edges returned by bfs_edges.', 'Ensuring each node is added to the BFS order list only once.']"
            }
        ]
    },
    {
        "id": 141,
        "problem": "Output a sequence of traversal in breadth-first search [BFS] order starting from node <13>",
        "graph_type": "undirected",
        "experience": "The task was to perform a BFS traversal on a graph starting from node 13. The code used the NetworkX library to create an undirected graph based on the provided data, and implemented a BFS algorithm using a queue (deque) and a set to track visited nodes.",
        "rag_data": [],
        "accuracy": 0.8,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <5> is connected to nodes <0>, <12>, <11>, <3>, <6>, <14>, <8>, <13>, <9>, <2>.\nNode <0> is connected to nodes <5>, <7>.\nNode <12> is connected to nodes <5>, <15>, <4>.\nNode <11> is connected to node <5>.\nNode <3> is connected to nodes <5>, <1>, <10>.\nNode <6> is connected to node <5>.\nNode <14> is connected to node <5>.\nNode <8> is connected to node <5>.\nNode <13> is connected to node <5>.\nNode <9> is connected to node <5>.\nNode <2> is connected to node <5>.\nNode <7> is connected to node <0>.\nNode <15> is connected to node <12>.\nNode <4> is connected to node <12>.\nNode <1> is connected to node <3>.\nNode <10> is connected to node <3>.\nStart from node <13>, output a sequence of traversal in breadth-first search (BFS) order.\nAnswer:\n",
                "code": "\nimport networkx as nx\nfrom collections import deque\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 5, 'Connections': [0, 12, 11, 3, 6, 14, 8, 13, 9, 2]},\n        {'Node': 0, 'Connections': [5, 7]},\n        {'Node': 12, 'Connections': [5, 15, 4]},\n        {'Node': 11, 'Connections': [5]},\n        {'Node': 3, 'Connections': [5, 1, 10]},\n        {'Node': 6, 'Connections': [5]},\n        {'Node': 14, 'Connections': [5]},\n        {'Node': 8, 'Connections': [5]},\n        {'Node': 13, 'Connections': [5]},\n        {'Node': 9, 'Connections': [5]},\n        {'Node': 2, 'Connections': [5]},\n        {'Node': 7, 'Connections': [0]},\n        {'Node': 15, 'Connections': [12]},\n        {'Node': 4, 'Connections': [12]},\n        {'Node': 1, 'Connections': [3]},\n        {'Node': 10, 'Connections': [3]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph based on the input data\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Function to perform BFS traversal\ndef bfs_traversal(graph, start_node):\n    visited = set()  # Set to keep track of visited nodes\n    queue = deque([start_node])  # Initialize the queue with the start node\n    traversal_order = []  # List to store the order of traversal\n\n    while queue:\n        current_node = queue.popleft()  # Dequeue a node\n        if current_node not in visited:\n            visited.add(current_node)  # Mark the node as visited\n            traversal_order.append(current_node)  # Add to traversal order\n\n            # Enqueue all unvisited neighbors\n            for neighbor in graph.neighbors(current_node):\n                if neighbor not in visited:\n                    queue.append(neighbor)\n\n    return traversal_order\n\n# Perform BFS starting from node 13\nbfs_result = bfs_traversal(G, 13)\n\n# Output the BFS traversal order\nprint(\"BFS Traversal Order starting from node 13:\", bfs_result)\n",
                "key_api": "NetworkX (nx.Graph, nx.Graph.add_edge, nx.Graph.neighbors), collections.deque",
                "key_experience": "1. Creating an undirected graph from input data by iterating over nodes and their connections. 2. Implementing BFS using a queue to manage the nodes to be visited next. 3. Maintaining a set to track visited nodes and avoid re-processing them. 4. Using a list to record the order of traversal. 5. Checking neighbors to enqueue only unvisited nodes to ensure correct BFS behavior."
            }
        ]
    },
    {
        "id": 142,
        "problem": "Determine which node has the largest PageRank value.",
        "graph_type": "undirected",
        "experience": "In solving the PageRank problem with network data involving directed graphs, the solution involves creating the graph structure, adding nodes and edges based on input data, computing the PageRank values, and identifying the node with the highest PageRank value.",
        "rag_data": [
            {
                "Section ID": "pagerank",
                "Description": [
                    "Returns the PageRank of the nodes in the graph.",
                    "PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                        "alpha : float, optional": "Damping parameter for PageRank, default=0.85.",
                        "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                        "max_iter : integer, optional": "Maximum number of iterations in power method eigenvalue solver.",
                        "tol : float, optional": "Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.",
                        "nstart : dictionary, optional": "Starting value of PageRank iteration for each node.",
                        "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                        "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict."
                    },
                    "Returns:": {
                        "pagerank : dictionary": "Dictionary of nodes with PageRank as value"
                    },
                    "Raises:": {
                        "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
                    }
                },
                "Rubrics": {
                    "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.",
                    "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf",
                    "Examples": "G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)"
                }
            }
        ],
        "accuracy": 0.3,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <17> is connected to nodes <4>, <18>, <9>, <10>, <1>, <15>, <11>, <5>, <7>, <0>, <6>, <13>.\nNode <4> is connected to nodes <17>, <9>, <7>, <2>, <19>, <16>, <1>, <13>, <15>, <12>, <8>.\nNode <18> is connected to nodes <17>, <16>, <5>, <11>, <0>, <6>, <8>.\nNode <9> is connected to nodes <17>, <4>, <11>, <8>, <19>.\nNode <10> is connected to nodes <17>, <1>, <8>, <14>.\nNode <1> is connected to nodes <17>, <4>, <11>, <6>, <2>, <8>, <14>, <15>, <5>, <10>, <7>.\nNode <15> is connected to nodes <17>, <4>, <11>, <1>.\nNode <11> is connected to nodes <17>, <18>, <9>, <8>, <1>, <15>, <7>.\nNode <5> is connected to nodes <17>, <18>, <1>, <7>, <16>.\nNode <7> is connected to nodes <17>, <4>, <11>, <1>, <14>, <2>, <12>, <5>, <3>.\nNode <0> is connected to nodes <17>, <18>, <12>, <3>.\nNode <6> is connected to nodes <17>, <18>, <1>, <3>, <2>.\nNode <13> is connected to nodes <17>, <4>, <16>, <12>.\nNode <2> is connected to nodes <4>, <1>, <6>, <8>, <7>, <19>.\nNode <19> is connected to nodes <4>, <9>, <2>, <12>.\nNode <16> is connected to nodes <4>, <18>, <14>, <5>, <13>.\nNode <12> is connected to nodes <4>, <8>, <7>, <13>, <0>, <19>, <3>.\nNode <8> is connected to nodes <4>, <18>, <11>, <9>, <1>, <14>, <12>, <10>, <2>.\nNode <14> is connected to nodes <1>, <8>, <16>, <10>, <7>.\nNode <3> is connected to nodes <6>, <7>, <12>, <0>.\nWhich node has the largest PageRank value? The dampling factor is 0.85. The number of iterations is 3. The initial PageRank values for all nodes are initialized equally as 1/N, where N is the number of nodes.\nAnswer:\n",
                "code": "import numpy as np\n\ndef main():\n    # Define the adjacency list for the undirected graph\n    adjacency_list = {\n        0: [3, 2, 1, 4],\n        1: [2, 0, 3, 4],\n        2: [3, 1, 4, 0],\n        3: [5, 2, 0, 4, 1],\n        4: [2, 0, 5, 3, 1],\n        5: [3, 4]\n    }\n    \n    # List of nodes\n    nodes = sorted(adjacency_list.keys())\n    N = len(nodes)\n    \n    # Mapping from node to index\n    node_to_index = {node: idx for idx, node in enumerate(nodes)}\n    \n    # Initialize adjacency matrix A where A[i][j] = 1 if node j links to node i\n    A = np.zeros((N, N))\n    \n    for node, neighbors in adjacency_list.items():\n        j = node_to_index[node]\n        for neighbor in neighbors:\n            i = node_to_index[neighbor]\n            A[i][j] = 1  # Node j links to node i\n    \n    # Compute out-degree for each node (number of outgoing links)\n    out_degree = A.sum(axis=0)\n    \n    # Handle dangling nodes (nodes with no outgoing links)\n    dangling_nodes = (out_degree == 0)\n    if np.any(dangling_nodes):\n        # If a dangling node is found, distribute its rank uniformly\n        A[:, dangling_nodes] = 1.0 / N\n        out_degree = A.sum(axis=0)  # Recompute out-degree after handling dangling nodes\n    \n    # Normalize adjacency matrix column-wise to create stochastic matrix M\n    M = A / out_degree\n    \n    # Define damping factor\n    d = 0.85\n    \n    # Create transition probability matrix M_hat\n    M_hat = d * M + (1 - d) / N\n    \n    # Initialize PageRank vector with equal values\n    PR = np.full(N, 1.0 / N)\n    \n    # Number of iterations\n    iterations = 3\n    \n    # Perform PageRank iterations\n    for _ in range(iterations):\n        PR = M_hat.dot(PR)\n    \n    # Identify the node with the highest PageRank\n    highest_PR_node = np.argmax(PR)\n    \n    print(f\"Node {highest_PR_node}\")\n\nif __name__ == \"__main__\":\n    main()",
                "key_api": "networkx.pagerank",
                "key_experience": "['Reading and parsing input data to construct the graph.', \"Using NetworkX's DiGraph to handle directed graphs.\", 'Adding nodes and edges to the graph iteratively based on the connections specified in the input.', 'Using the NetworkX pagerank function to compute PageRank values for the graph nodes.', \"Identifying the node with the maximum PageRank value using Python's max function with a key parameter.\"]"
            }
        ]
    },
    {
        "id": 143,
        "problem": "Determine which node has the largest PageRank value.",
        "graph_type": "undirected",
        "experience": "In solving the PageRank problem with network data involving directed graphs, the solution involves creating the graph structure, adding nodes and edges based on input data, computing the PageRank values, and identifying the node with the highest PageRank value.",
        "rag_data": [
            {
                "Section ID": "pagerank",
                "Description": [
                    "Returns the PageRank of the nodes in the graph.",
                    "PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                        "alpha : float, optional": "Damping parameter for PageRank, default=0.85.",
                        "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                        "max_iter : integer, optional": "Maximum number of iterations in power method eigenvalue solver.",
                        "tol : float, optional": "Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.",
                        "nstart : dictionary, optional": "Starting value of PageRank iteration for each node.",
                        "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                        "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict."
                    },
                    "Returns:": {
                        "pagerank : dictionary": "Dictionary of nodes with PageRank as value"
                    },
                    "Raises:": {
                        "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
                    }
                },
                "Rubrics": {
                    "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.",
                    "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf",
                    "Examples": "G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)"
                }
            }
        ],
        "accuracy": 0.3,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <17> is connected to nodes <4>, <18>, <9>, <10>, <1>, <15>, <11>, <5>, <7>, <0>, <6>, <13>.\nNode <4> is connected to nodes <17>, <9>, <7>, <2>, <19>, <16>, <1>, <13>, <15>, <12>, <8>.\nNode <18> is connected to nodes <17>, <16>, <5>, <11>, <0>, <6>, <8>.\nNode <9> is connected to nodes <17>, <4>, <11>, <8>, <19>.\nNode <10> is connected to nodes <17>, <1>, <8>, <14>.\nNode <1> is connected to nodes <17>, <4>, <11>, <6>, <2>, <8>, <14>, <15>, <5>, <10>, <7>.\nNode <15> is connected to nodes <17>, <4>, <11>, <1>.\nNode <11> is connected to nodes <17>, <18>, <9>, <8>, <1>, <15>, <7>.\nNode <5> is connected to nodes <17>, <18>, <1>, <7>, <16>.\nNode <7> is connected to nodes <17>, <4>, <11>, <1>, <14>, <2>, <12>, <5>, <3>.\nNode <0> is connected to nodes <17>, <18>, <12>, <3>.\nNode <6> is connected to nodes <17>, <18>, <1>, <3>, <2>.\nNode <13> is connected to nodes <17>, <4>, <16>, <12>.\nNode <2> is connected to nodes <4>, <1>, <6>, <8>, <7>, <19>.\nNode <19> is connected to nodes <4>, <9>, <2>, <12>.\nNode <16> is connected to nodes <4>, <18>, <14>, <5>, <13>.\nNode <12> is connected to nodes <4>, <8>, <7>, <13>, <0>, <19>, <3>.\nNode <8> is connected to nodes <4>, <18>, <11>, <9>, <1>, <14>, <12>, <10>, <2>.\nNode <14> is connected to nodes <1>, <8>, <16>, <10>, <7>.\nNode <3> is connected to nodes <6>, <7>, <12>, <0>.\nWhich node has the largest PageRank value? The dampling factor is 0.85. The number of iterations is 3. The initial PageRank values for all nodes are initialized equally as 1/N, where N is the number of nodes.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 17, 'Connections': [4, 18, 9, 10, 1, 15, 11, 5, 7, 0, 6, 13]},\n        {'Node': 4, 'Connections': [17, 9, 7, 2, 19, 16, 1, 13, 15, 12, 8]},\n        {'Node': 18, 'Connections': [17, 16, 5, 11, 0, 6, 8]},\n        {'Node': 9, 'Connections': [17, 4, 11, 8, 19]},\n        {'Node': 10, 'Connections': [17, 1, 8, 14]},\n        {'Node': 1, 'Connections': [17, 4, 11, 6, 2, 8, 14, 15, 5, 10, 7]},\n        {'Node': 15, 'Connections': [17, 4, 11, 1]},\n        {'Node': 11, 'Connections': [17, 18, 9, 8, 1, 15, 7]},\n        {'Node': 5, 'Connections': [17, 18, 1, 7, 16]},\n        {'Node': 7, 'Connections': [17, 4, 11, 1, 14, 2, 12, 5, 3]},\n        {'Node': 0, 'Connections': [17, 18, 12, 3]},\n        {'Node': 6, 'Connections': [17, 18, 1, 3, 2]},\n        {'Node': 13, 'Connections': [17, 4, 16, 12]},\n        {'Node': 2, 'Connections': [4, 1, 6, 8, 7, 19]},\n        {'Node': 19, 'Connections': [4, 9, 2, 12]},\n        {'Node': 16, 'Connections': [4, 18, 14, 5, 13]},\n        {'Node': 12, 'Connections': [4, 8, 7, 13, 0, 19, 3]},\n        {'Node': 8, 'Connections': [4, 18, 11, 9, 1, 14, 12, 10, 2]},\n        {'Node': 14, 'Connections': [1, 8, 16, 10, 7]},\n        {'Node': 3, 'Connections': [6, 7, 12, 0]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate PageRank\npagerank_values = nx.pagerank(G)\n\n# Find the node with the largest PageRank value\nmax_node = max(pagerank_values, key=pagerank_values.get)\nmax_value = pagerank_values[max_node]\n\n# Output the result\nprint(f\"Node with the largest PageRank: {max_node} (PageRank value: {max_value})\")\n",
                "key_api": "networkx.pagerank",
                "key_experience": "['Reading and parsing input data to construct the graph.', \"Using NetworkX's DiGraph to handle directed graphs.\", 'Adding nodes and edges to the graph iteratively based on the connections specified in the input.', 'Using the NetworkX pagerank function to compute PageRank values for the graph nodes.', \"Identifying the node with the maximum PageRank value using Python's max function with a key parameter.\"]"
            }
        ]
    },
    {
        "id": 144,
        "problem": "Determine which node has the largest PageRank value after 3 iterations with a damping factor of 0.85.",
        "graph_type": "directed",
        "experience": "In the recent code-writing task for determining the node with the largest PageRank value after 3 iterations with a damping factor of 0.85, the task was successfully completed by following a clear sequence of steps. Key points include understanding the structure of input data, utilizing the NetworkX library to create and manipulate the graph, calculating PageRank values, and identifying the node with the highest PageRank.",
        "rag_data": [
            {
                "Section ID": "pagerank",
                "Description": [
                    "Returns the PageRank of the nodes in the graph.",
                    "PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                        "alpha : float, optional": "Damping parameter for PageRank, default=0.85.",
                        "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                        "max_iter : integer, optional": "Maximum number of iterations in power method eigenvalue solver.",
                        "tol : float, optional": "Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.",
                        "nstart : dictionary, optional": "Starting value of PageRank iteration for each node.",
                        "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                        "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict."
                    },
                    "Returns:": {
                        "pagerank : dictionary": "Dictionary of nodes with PageRank as value"
                    },
                    "Raises:": {
                        "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
                    }
                },
                "Rubrics": {
                    "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.",
                    "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf",
                    "Examples": "G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)"
                }
            }
        ],
        "accuracy": 0.2,
        "example": [
            {
                "question": "Given a directed graph:\nNode <2> is connected to nodes <7>, <13>, <10>, <14>, <3>.\nNode <7> is connected to nodes <4>, <0>, <15>, <5>, <12>, <6>, <3>.\nNode <13> is connected to nodes <11>, <15>, <5>, <6>, <4>.\nNode <10> is connected to nodes <11>, <0>, <14>, <6>, <8>.\nNode <14> is connected to nodes <12>, <6>, <1>, <9>, <7>, <4>, <13>, <11>, <5>.\nNode <3> is connected to nodes <2>, <11>, <0>, <15>, <12>.\nNode <4> is connected to nodes <13>, <10>, <11>, <0>, <15>, <5>, <6>, <3>, <9>, <2>.\nNode <0> is connected to nodes <15>, <14>, <3>, <4>, <8>, <13>.\nNode <15> is connected to nodes <6>, <1>, <9>, <4>.\nNode <5> is connected to nodes <6>, <1>, <4>, <8>, <13>, <10>.\nNode <12> is connected to nodes <6>, <3>, <9>, <2>, <8>, <13>, <0>, <5>, <14>.\nNode <6> is connected to nodes <9>, <7>, <8>, <10>, <0>, <15>, <5>, <12>.\nNode <11> is connected to nodes <15>, <12>, <1>, <2>, <7>, <4>, <13>, <10>.\nNode <9> is connected to nodes <4>, <13>, <10>, <15>, <6>, <1>, <3>.\nNode <8> is connected to nodes <15>, <5>, <12>, <1>, <2>.\nNode <1> is connected to nodes <9>, <2>, <13>, <11>, <0>, <14>, <6>.\nWhich node has the largest PageRank value? The dampling factor is 0.85. The number of iterations is 3. The initial PageRank values for all nodes are initialized equally as 1/N, where N is the number of nodes.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the graph based on the provided input\ninput_data = {\n    'Nodes': [\n        {'Node': 2, 'Connections': [7, 13, 10, 14, 3]},\n        {'Node': 7, 'Connections': [4, 0, 15, 5, 12, 6, 3]},\n        {'Node': 13, 'Connections': [11, 15, 5, 6, 4]},\n        {'Node': 10, 'Connections': [11, 0, 14, 6, 8]},\n        {'Node': 14, 'Connections': [12, 6, 1, 9, 7, 4, 13, 11, 5]},\n        {'Node': 3, 'Connections': [2, 11, 0, 15, 12]},\n        {'Node': 4, 'Connections': [13, 10, 11, 0, 15, 5, 6, 3, 9, 2]},\n        {'Node': 0, 'Connections': [15, 14, 3, 4, 8, 13]},\n        {'Node': 15, 'Connections': [6, 1, 9, 4]},\n        {'Node': 5, 'Connections': [6, 1, 4, 8, 13, 10]},\n        {'Node': 12, 'Connections': [6, 3, 9, 2, 8, 13, 0, 5, 14]},\n        {'Node': 6, 'Connections': [9, 7, 8, 10, 0, 15, 5, 12]},\n        {'Node': 11, 'Connections': [15, 12, 1, 2, 7, 4, 13, 10]},\n        {'Node': 9, 'Connections': [4, 13, 10, 15, 6, 1, 3]},\n        {'Node': 8, 'Connections': [15, 5, 12, 1, 2]},\n        {'Node': 1, 'Connections': [9, 2, 13, 11, 0, 14, 6]}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add edges to the graph based on the input data\nfor node in input_data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Calculate PageRank with a damping factor of 0.85\npagerank_scores = nx.pagerank(G, alpha=0.85, max_iter=3)\n\n# Find the node with the largest PageRank value\nmax_node = max(pagerank_scores, key=pagerank_scores.get)\nmax_value = pagerank_scores[max_node]\n\n# Output the node with the largest PageRank value\nprint(f\"Node with the largest PageRank value: {max_node} (PageRank: {max_value})\")\n",
                "key_api": "NetworkX (nx.pagerank())",
                "key_experience": "['1. Parsing input data correctly: Structured the input data to represent nodes and their connections clearly.', \"2. Using NetworkX for graph creation: Leveraged NetworkX's DiGraph to create a directed graph from the input data.\", \"3. Efficient PageRank calculation: Used NetworkX's nx.pagerank() function with the specified parameters (damping factor of 0.85 and max_iter of 3) to compute PageRank scores.\", \"4. Extracting the maximum value: Found the node with the highest PageRank value using Python's max function with an appropriate key.\"]"
            }
        ]
    },
    {
        "id": 145,
        "problem": "Determine which node has the largest PageRank value.",
        "graph_type": "directed",
        "experience": "The task was to determine which node has the largest PageRank value from given input data. The steps involved included creating a directed graph using NetworkX library, adding nodes and edges to the graph based on given connections, calculating PageRank using the damping factor and iterations specified, and identifying the node with the highest PageRank value.",
        "rag_data": [
            {
                "Section ID": "pagerank",
                "Description": [
                    "Returns the PageRank of the nodes in the graph.",
                    "PageRank computes a ranking of the nodes in the graph G based on\nthe structure of the incoming links. It was originally designed as\nan algorithm to rank web pages."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : graph": "A NetworkX graph.  Undirected graphs will be converted to a directed\ngraph with two directed edges for each undirected edge.",
                        "alpha : float, optional": "Damping parameter for PageRank, default=0.85.",
                        "personalization: dict, optional": "The \u201cpersonalization vector\u201d consisting of a dictionary with a\nkey some subset of graph nodes and personalization value each of those.\nAt least one personalization value must be non-zero.\nIf not specified, a nodes personalization value will be zero.\nBy default, a uniform distribution is used.",
                        "max_iter : integer, optional": "Maximum number of iterations in power method eigenvalue solver.",
                        "tol : float, optional": "Error tolerance used to check convergence in power method solver.\nThe iteration will stop after a tolerance oflen(G)*tolis reached.",
                        "nstart : dictionary, optional": "Starting value of PageRank iteration for each node.",
                        "weight : key, optional": "Edge data key to use as weight.  If None weights are set to 1.",
                        "dangling: dict, optional": "The outedges to be assigned to any \u201cdangling\u201d nodes, i.e., nodes without\nany outedges. The dict key is the node the outedge points to and the dict\nvalue is the weight of that outedge. By default, dangling nodes are given\noutedges according to the personalization vector (uniform if not\nspecified). This must be selected to result in an irreducible transition\nmatrix (see notes under google_matrix). It may be common to have the\ndangling dict to be the same as the personalization dict."
                    },
                    "Returns:": {
                        "pagerank : dictionary": "Dictionary of nodes with PageRank as value"
                    },
                    "Raises:": {
                        "PowerIterationFailedConvergence": "If the algorithm fails to converge to the specified tolerance\nwithin the specified number of iterations of the power iteration\nmethod."
                    }
                },
                "Rubrics": {
                    "Notes": "The eigenvector calculation is done by the power iteration method\nand has no guarantee of convergence.  The iteration will stop after\nan error tolerance of len(G)*tol has been reached. If the\nnumber of iterations exceed max_iter , a networkx.exception.PowerIterationFailedConvergence exception\nis raised. The PageRank algorithm was designed for directed graphs but this\nalgorithm does not check if the input graph is directed and will\nexecute on undirected graphs by converting each edge in the\ndirected graph to two edges.",
                    "References": "[1]A. Langville and C. Meyer,\n\u201cA survey of eigenvector methods of web information retrieval.\u201dhttp://citeseer.ist.psu.edu/713792.html  [2]Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,\nThe PageRank citation ranking: Bringing order to the Web. 1999http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf",
                    "Examples": "G=nx.DiGraph(nx.path_graph(4))\npr=nx.pagerank(G,alpha=0.9)"
                }
            }
        ],
        "accuracy": 0.1,
        "example": [
            {
                "question": "Given a directed graph:\nNode <2> is connected to nodes <7>, <13>, <10>, <14>, <3>.\nNode <7> is connected to nodes <4>, <0>, <15>, <5>, <12>, <6>, <3>.\nNode <13> is connected to nodes <11>, <15>, <5>, <6>, <4>.\nNode <10> is connected to nodes <11>, <0>, <14>, <6>, <8>.\nNode <14> is connected to nodes <12>, <6>, <1>, <9>, <7>, <4>, <13>, <11>, <5>.\nNode <3> is connected to nodes <2>, <11>, <0>, <15>, <12>.\nNode <4> is connected to nodes <13>, <10>, <11>, <0>, <15>, <5>, <6>, <3>, <9>, <2>.\nNode <0> is connected to nodes <15>, <14>, <3>, <4>, <8>, <13>.\nNode <15> is connected to nodes <6>, <1>, <9>, <4>.\nNode <5> is connected to nodes <6>, <1>, <4>, <8>, <13>, <10>.\nNode <12> is connected to nodes <6>, <3>, <9>, <2>, <8>, <13>, <0>, <5>, <14>.\nNode <6> is connected to nodes <9>, <7>, <8>, <10>, <0>, <15>, <5>, <12>.\nNode <11> is connected to nodes <15>, <12>, <1>, <2>, <7>, <4>, <13>, <10>.\nNode <9> is connected to nodes <4>, <13>, <10>, <15>, <6>, <1>, <3>.\nNode <8> is connected to nodes <15>, <5>, <12>, <1>, <2>.\nNode <1> is connected to nodes <9>, <2>, <13>, <11>, <0>, <14>, <6>.\nWhich node has the largest PageRank value? The dampling factor is 0.85. The number of iterations is 3. The initial PageRank values for all nodes are initialized equally as 1/N, where N is the number of nodes.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 2, 'Connections': [7, 13, 10, 14, 3]},\n        {'Node': 7, 'Connections': [4, 0, 15, 5, 12, 6, 3]},\n        {'Node': 13, 'Connections': [11, 15, 5, 6, 4]},\n        {'Node': 10, 'Connections': [11, 0, 14, 6, 8]},\n        {'Node': 14, 'Connections': [12, 6, 1, 9, 7, 4, 13, 11, 5]},\n        {'Node': 3, 'Connections': [2, 11, 0, 15, 12]},\n        {'Node': 4, 'Connections': [13, 10, 11, 0, 15, 5, 6, 3, 9, 2]},\n        {'Node': 0, 'Connections': [15, 14, 3, 4, 8, 13]},\n        {'Node': 15, 'Connections': [6, 1, 9, 4]},\n        {'Node': 5, 'Connections': [6, 1, 4, 8, 13, 10]},\n        {'Node': 12, 'Connections': [6, 3, 9, 2, 8, 13, 0, 5, 14]},\n        {'Node': 6, 'Connections': [9, 7, 8, 10, 0, 15, 5, 12]},\n        {'Node': 11, 'Connections': [15, 12, 1, 2, 7, 4, 13, 10]},\n        {'Node': 9, 'Connections': [4, 13, 10, 15, 6, 1, 3]},\n        {'Node': 8, 'Connections': [15, 5, 12, 1, 2]},\n        {'Node': 1, 'Connections': [9, 2, 13, 11, 0, 14, 6]}\n    ],\n    'Damping_Factor': 0.85,\n    'Iterations': 3,\n    'Initial_PageRank': '1/N'\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nfor node_info in data['Nodes']:\n    node = node_info['Node']\n    connections = node_info['Connections']\n    for connection in connections:\n        G.add_edge(node, connection)\n\n# Calculate PageRank\npagerank = nx.pagerank(G, alpha=data['Damping_Factor'], max_iter=data['Iterations'])\n\n# Find the node with the largest PageRank value\nmax_node = max(pagerank, key=pagerank.get)\nmax_value = pagerank[max_node]\n\n# Output the node with the largest PageRank value\nprint(f\"Node with the largest PageRank: {max_node} with value: {max_value}\")\n",
                "key_api": "networkx.pagerank",
                "key_experience": "1. Data parsing: Extract nodes and connections from input data and handle the graph construction efficiently. 2. Use of NetworkX library to create the directed graph and compute PageRank values. 3. Efficiently find the node with the maximum PageRank using Python\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u00a2\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0080\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0083\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0083\u00c3\u0082\u00c2\u0082\u00c3\u0083\u00c2\u0082\u00c3\u0082\u00c2\u0099s built-in `max` function with a custom key."
            }
        ]
    },
    {
        "id": 146,
        "problem": "Find a Euler path in this graph.",
        "graph_type": "undirected",
        "experience": "During the recent engagement, the task was to find an Euler path in a given graph. The user provided specific nodes and their connections, which were processed to determine the Euler path using Python. The need to construct the graph using NetworkX and then apply Eulerian path algorithms was identified as critical steps in solving the problem.",
        "rag_data": [],
        "accuracy": 0.15,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <17> is connected to nodes <14>, <15>, <7>, <3>, <11>, <5>, <9>.\nNode <14> is connected to nodes <17>, <7>, <15>, <3>.\nNode <15> is connected to nodes <17>, <14>, <3>, <0>.\nNode <7> is connected to nodes <17>, <14>, <4>, <10>, <12>, <1>, <2>, <5>.\nNode <3> is connected to nodes <17>, <14>, <11>, <9>, <15>, <1>.\nNode <11> is connected to nodes <17>, <3>, <8>, <16>.\nNode <5> is connected to nodes <17>, <7>, <9>, <13>.\nNode <9> is connected to nodes <17>, <3>, <5>, <13>.\nNode <8> is connected to nodes <11>, <4>.\nNode <16> is connected to nodes <11>, <6>.\nNode <1> is connected to nodes <3>, <7>, <6>.\nNode <0> is connected to nodes <15>, <2>.\nNode <4> is connected to nodes <7>, <13>, <10>, <2>, <8>, <6>.\nNode <10> is connected to nodes <7>, <4>.\nNode <12> is connected to nodes <7>, <2>.\nNode <2> is connected to nodes <7>, <4>, <12>, <0>.\nNode <13> is connected to nodes <4>, <9>, <5>, <6>.\nNode <6> is connected to nodes <4>, <13>, <16>, <1>.\nFind a Euler path in this graph. An Euler path in a graph is a path that traverses each edge exactly once, but not necessarily every node. The starting node and ending node may be different. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 17, 'Connections': [14, 15, 7, 3, 11, 5, 9]},\n        {'Node': 14, 'Connections': [17, 7, 15, 3]},\n        {'Node': 15, 'Connections': [17, 14, 3, 0]},\n        {'Node': 7, 'Connections': [17, 14, 4, 10, 12, 1, 2, 5]},\n        {'Node': 3, 'Connections': [17, 14, 11, 9, 15, 1]},\n        {'Node': 11, 'Connections': [17, 3, 8, 16]},\n        {'Node': 5, 'Connections': [17, 7, 9, 13]},\n        {'Node': 9, 'Connections': [17, 3, 5, 13]},\n        {'Node': 8, 'Connections': [11, 4]},\n        {'Node': 16, 'Connections': [11, 6]},\n        {'Node': 1, 'Connections': [3, 7, 6]},\n        {'Node': 0, 'Connections': [15, 2]},\n        {'Node': 4, 'Connections': [7, 13, 10, 2, 8, 6]},\n        {'Node': 10, 'Connections': [7, 4]},\n        {'Node': 12, 'Connections': [7, 2]},\n        {'Node': 2, 'Connections': [7, 4, 12, 0]},\n        {'Node': 13, 'Connections': [4, 9, 5, 6]},\n        {'Node': 6, 'Connections': [4, 13, 16, 1]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check for Euler path conditions\nodd_degree_nodes = [node for node, degree in G.degree() if degree % 2 == 1]\n\n# A Euler path exists if there are 0 or 2 vertices of odd degree\nif len(odd_degree_nodes) in [0, 2]:\n    # Find the Euler path\n    euler_path = list(nx.eulerian_path(G))\n    print(\"Euler Path:\", euler_path)\nelse:\n    print(\"No Euler Path exists in this graph.\")\n",
                "key_api": "networkx",
                "key_experience": "1. Constructing the graph correctly using the NetworkX library. 2. Using NetworkX's built-in functionalities for finding Eulerian paths. 3. Verifying the nodes and connections are correctly added to the graph. 4. Handling potential issues such as disconnected components or incorrect inputs. 5. Structuring the code in a clean, readable format."
            }
        ]
    },
    {
        "id": 147,
        "problem": "Find a Euler path in this graph.",
        "graph_type": "undirected",
        "experience": "In recent engagements, the task was to find a Euler path in a given graph. The problem inputs were extensive and included nodes and their connections. We approached the problem using the NetworkX library in Python, which provides a comprehensive set of graph algorithms and utilities.",
        "rag_data": [],
        "accuracy": 0.15,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <7> is connected to nodes <5>, <13>, <16>, <8>, <3>, <11>, <10>, <15>, <1>, <9>.\nNode <5> is connected to nodes <7>, <2>, <13>, <3>, <1>, <12>, <8>, <4>.\nNode <13> is connected to nodes <7>, <5>, <2>, <9>, <15>, <16>, <1>, <4>, <12>, <3>, <14>, <6>.\nNode <16> is connected to nodes <7>, <13>, <0>, <12>, <10>, <6>, <14>, <8>, <2>, <1>.\nNode <8> is connected to nodes <7>, <5>, <16>, <10>, <9>, <0>, <1>, <12>, <11>, <15>.\nNode <3> is connected to nodes <7>, <5>, <13>, <10>, <6>, <0>, <15>.\nNode <11> is connected to nodes <7>, <10>, <0>, <8>.\nNode <10> is connected to nodes <7>, <16>, <2>, <4>, <15>, <8>, <11>, <3>, <12>, <14>.\nNode <15> is connected to nodes <7>, <13>, <2>, <4>, <10>, <6>, <0>, <8>, <12>, <3>.\nNode <1> is connected to nodes <7>, <5>, <13>, <16>, <0>, <14>, <8>, <12>.\nNode <9> is connected to nodes <7>, <13>, <2>, <6>, <12>, <8>.\nNode <2> is connected to nodes <5>, <13>, <16>, <12>, <15>, <9>, <4>, <10>.\nNode <12> is connected to nodes <5>, <13>, <16>, <2>, <4>, <10>, <9>, <6>, <1>, <8>, <15>.\nNode <4> is connected to nodes <5>, <13>, <2>, <10>, <12>, <15>.\nNode <14> is connected to nodes <13>, <16>, <10>, <1>.\nNode <6> is connected to nodes <13>, <16>, <9>, <3>, <15>, <12>.\nNode <0> is connected to nodes <16>, <1>, <3>, <15>, <11>, <8>.\nFind a Euler path in this graph. An Euler path in a graph is a path that traverses each edge exactly once, but not necessarily every node. The starting node and ending node may be different. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 7, 'Connections': [5, 13, 16, 8, 3, 11, 10, 15, 1, 9]},\n        {'Node': 5, 'Connections': [7, 2, 13, 3, 1, 12, 8, 4]},\n        {'Node': 13, 'Connections': [7, 5, 2, 9, 15, 16, 1, 4, 12, 3, 14, 6]},\n        {'Node': 16, 'Connections': [7, 13, 0, 12, 10, 6, 14, 8, 2, 1]},\n        {'Node': 8, 'Connections': [7, 5, 16, 10, 9, 0, 1, 12, 11, 15]},\n        {'Node': 3, 'Connections': [7, 5, 13, 10, 6, 0, 15]},\n        {'Node': 11, 'Connections': [7, 10, 0, 8]},\n        {'Node': 10, 'Connections': [7, 16, 2, 4, 15, 8, 11, 3, 12, 14]},\n        {'Node': 15, 'Connections': [7, 13, 2, 4, 10, 6, 0, 8, 12, 3]},\n        {'Node': 1, 'Connections': [7, 5, 13, 16, 0, 14, 8, 12]},\n        {'Node': 9, 'Connections': [7, 13, 2, 6, 12, 8]},\n        {'Node': 2, 'Connections': [5, 13, 16, 12, 15, 9, 4, 10]},\n        {'Node': 12, 'Connections': [5, 13, 16, 2, 4, 10, 9, 6, 1, 8, 15]},\n        {'Node': 4, 'Connections': [5, 13, 2, 10, 12, 15]},\n        {'Node': 14, 'Connections': [13, 16, 10, 1]},\n        {'Node': 6, 'Connections': [13, 16, 9, 3, 15, 12]},\n        {'Node': 0, 'Connections': [16, 1, 3, 15, 11, 8]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Check for Euler path\ndef find_euler_path(graph):\n    # Check the degree of each node\n    odd_degree_nodes = [node for node, degree in graph.degree() if degree % 2 == 1]\n    \n    # A Euler path exists if there are 0 or 2 nodes of odd degree\n    if len(odd_degree_nodes) not in [0, 2]:\n        return None  # No Euler path exists\n\n    # Start from a node with an odd degree if it exists, otherwise start from any node\n    start_node = odd_degree_nodes[0] if odd_degree_nodes else list(graph.nodes())[0]\n    \n    # Find the Euler path\n    euler_path = list(nx.eulerian_path(graph, source=start_node))\n    \n    return euler_path\n\n# Get the Euler path\neuler_path = find_euler_path(G)\n\n# Print the Euler path if it exists\nif euler_path:\n    print(\"Euler Path:\", list(euler_path))\nelse:\n    print(\"No Euler Path exists.\")\n",
                "key_api": "networkx (nx)",
                "key_experience": "1. Parse the input data to create a graph structure. 2. Use NetworkX to manage graph data and operations due to its robust feature set for handling complex graph algorithms like finding Euler paths. 3. Implement a conditional check to determine if a Euler path exists based on graph properties (checking for nodes of odd degree). 4. Utilize appropriate NetworkX functions such as `is_eulerian` for Eulerian cycle checks and path-finding functions if the graph has an Eulerian path. 5. Efficiently output or handle results to match the expected output format."
            }
        ]
    },
    {
        "id": 148,
        "problem": "Find a Euler path in this graph.",
        "graph_type": "directed",
        "experience": "During the recent engagement with GPT-4o-mini for finding an Euler path in a directed graph, the focus was on leveraging the NetworkX library. Here are the steps and key points extracted from the interaction: The problem provided was to find an Euler path for a directed graph with specific nodes and edges. The user provided node and edge data as dictionaries. The solution required organizing this data into a format usable by the NetworkX library. The code needed graph construction, adding edges, and algorithmic path finding. Focusing on these aspects helped in creating a working solution.",
        "rag_data": [],
        "accuracy": 0.1,
        "example": [
            {
                "question": "Given a directed graph:\nNode <5> is connected to node <11>.\nNode <11> is connected to nodes <9>, <13>, <16>.\nNode <9> is connected to nodes <11>, <2>, <14>.\nNode <13> is connected to nodes <10>, <7>, <1>, <16>, <12>.\nNode <16> is connected to nodes <11>, <3>, <8>, <10>, <15>, <6>.\nNode <2> is connected to nodes <0>, <16>, <13>.\nNode <14> is connected to nodes <1>, <13>.\nNode <3> is connected to nodes <15>, <11>, <4>.\nNode <8> is connected to nodes <4>, <10>, <9>.\nNode <10> is connected to nodes <7>, <1>, <8>, <13>.\nNode <15> is connected to nodes <1>, <6>, <13>, <10>.\nNode <6> is connected to nodes <3>, <16>.\nNode <7> is connected to nodes <12>, <14>.\nNode <1> is connected to nodes <0>, <2>, <8>, <16>.\nNode <12> is connected to nodes <15>, <9>.\nNode <0> is connected to nodes <15>, <16>.\nNode <4> is connected to nodes <2>, <5>.\nFind a Euler path in this graph. An Euler path in a graph is a path that traverses each edge exactly once, but not necessarily every node. The starting node and ending node may be different. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Define the input data\ninput_data = {\n    'Nodes': [5, 11, 9, 13, 16, 2, 14, 3, 8, 10, 15, 6, 7, 1, 12, 0, 4],\n    'Edges': [\n        {'from': 5, 'to': 11}, {'from': 11, 'to': 9}, {'from': 11, 'to': 13},\n        {'from': 11, 'to': 16}, {'from': 9, 'to': 11}, {'from': 9, 'to': 2},\n        {'from': 9, 'to': 14}, {'from': 13, 'to': 10}, {'from': 13, 'to': 7},\n        {'from': 13, 'to': 1}, {'from': 13, 'to': 16}, {'from': 13, 'to': 12},\n        {'from': 16, 'to': 11}, {'from': 16, 'to': 3}, {'from': 16, 'to': 8},\n        {'from': 16, 'to': 10}, {'from': 16, 'to': 15}, {'from': 16, 'to': 6},\n        {'from': 2, 'to': 0}, {'from': 2, 'to': 16}, {'from': 2, 'to': 13},\n        {'from': 14, 'to': 1}, {'from': 14, 'to': 13}, {'from': 3, 'to': 15},\n        {'from': 3, 'to': 11}, {'from': 3, 'to': 4}, {'from': 8, 'to': 4},\n        {'from': 8, 'to': 10}, {'from': 8, 'to': 9}, {'from': 10, 'to': 7},\n        {'from': 10, 'to': 1}, {'from': 10, 'to': 8}, {'from': 10, 'to': 13},\n        {'from': 15, 'to': 1}, {'from': 15, 'to': 6}, {'from': 15, 'to': 13},\n        {'from': 15, 'to': 10}, {'from': 6, 'to': 3}, {'from': 6, 'to': 16},\n        {'from': 7, 'to': 12}, {'from': 7, 'to': 14}, {'from': 1, 'to': 0},\n        {'from': 1, 'to': 2}, {'from': 1, 'to': 8}, {'from': 1, 'to': 16},\n        {'from': 12, 'to': 15}, {'from': 12, 'to': 9}, {'from': 0, 'to': 15},\n        {'from': 0, 'to': 16}, {'from': 4, 'to': 2}, {'from': 4, 'to': 5}\n    ]\n}\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges to the graph\nG.add_nodes_from(input_data['Nodes'])\nfor edge in input_data['Edges']:\n    G.add_edge(edge['from'], edge['to'])\n\n# Check for Euler path\ndef find_euler_path(graph):\n    # Check if the graph has an Euler path\n    if nx.is_eulerian(graph):\n        return list(nx.eulerian_circuit(graph))\n    else:\n        # Check the in-degree and out-degree of each node\n        odd_degree_nodes = [node for node in graph.nodes if graph.in_degree(node) != graph.out_degree(node)]\n        if len(odd_degree_nodes) == 0 or len(odd_degree_nodes) == 2:\n            return list(nx.eulerian_path(graph))\n        else:\n            return None\n\n# Find the Euler path\neuler_path = find_euler_path(G)\n\n# Output the result\nif euler_path:\n    print(\"Euler Path:\", euler_path)\nelse:\n    print(\"No Euler Path exists in the graph.\")\n",
                "key_api": "networkx library",
                "key_experience": "1. Efficiently organize input data. 2. Construct the graph using NetworkX. 3. Add edges from the input data to the graph. 4. Use NetworkX specific functions to find an Euler path. 5. Ensure code is well-documented and modular."
            }
        ]
    },
    {
        "id": 149,
        "problem": "Find a Euler path in this graph.",
        "graph_type": "directed",
        "experience": "To find an Euler path in a given graph, the initial solution was to utilize the NetworkX library in Python. The task involved creating a network graph using the input data and then utilizing a function from NetworkX to identify and return the Euler path.",
        "rag_data": [
            {
                "Section ID": "eulerian_path",
                "Description": [
                    "Return an iterator over the edges of an Eulerian path in G ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : NetworkX Graph": "The graph in which to look for an eulerian path.",
                        "source : node or None (default: None)": "The node at which to start the search. None means search over all\nstarting nodes.",
                        "keys : Bool (default: False)": "Indicates whether to yield edge 3-tuples (u, v, edge_key).\nThe default yields edge 2-tuples"
                    },
                    "Yields:": {
                        "Edge tuples along the eulerian path.": "",
                        "Warning: If : source : provided is not the start node of an Euler path": "",
                        "will raise error even if an Euler Path exists.": ""
                    }
                },
                "Rubrics": {}
            }
        ],
        "accuracy": 0.0,
        "example": [
            {
                "question": "Given a directed graph:\nNode <16> is connected to nodes <10>, <5>, <11>.\nNode <10> is connected to nodes <1>, <4>, <5>, <7>, <11>, <2>.\nNode <5> is connected to nodes <10>, <1>, <9>, <6>, <0>, <14>, <2>.\nNode <11> is connected to nodes <10>, <2>, <13>, <0>.\nNode <1> is connected to nodes <13>, <8>, <9>, <12>, <10>, <2>, <14>.\nNode <4> is connected to nodes <14>, <7>, <2>, <8>, <5>.\nNode <7> is connected to nodes <14>, <4>, <8>.\nNode <2> is connected to nodes <14>, <3>, <1>, <6>, <13>.\nNode <14> is connected to nodes <9>, <10>, <3>, <5>, <12>, <13>, <0>, <8>.\nNode <8> is connected to nodes <12>, <13>, <16>, <10>.\nNode <9> is connected to nodes <16>, <5>, <1>, <6>, <7>, <14>.\nNode <3> is connected to nodes <9>, <13>, <15>, <14>.\nNode <12> is connected to nodes <3>, <13>, <9>, <16>, <11>, <4>.\nNode <13> is connected to nodes <1>, <12>, <5>, <9>, <14>, <7>, <0>, <3>.\nNode <0> is connected to nodes <12>, <1>, <5>, <4>.\nNode <6> is connected to nodes <4>, <15>, <11>.\nNode <15> is connected to nodes <12>, <13>.\nFind a Euler path in this graph. An Euler path in a graph is a path that traverses each edge exactly once, but not necessarily every node. The starting node and ending node may be different. \nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 16, 'Connections': [10, 5, 11]},\n        {'Node': 10, 'Connections': [1, 4, 5, 7, 11, 2]},\n        {'Node': 5, 'Connections': [10, 1, 9, 6, 0, 14, 2]},\n        {'Node': 11, 'Connections': [10, 2, 13, 0]},\n        {'Node': 1, 'Connections': [13, 8, 9, 12, 10, 2, 14]},\n        {'Node': 4, 'Connections': [14, 7, 2, 8, 5]},\n        {'Node': 7, 'Connections': [14, 4, 8]},\n        {'Node': 2, 'Connections': [14, 3, 1, 6, 13]},\n        {'Node': 14, 'Connections': [9, 10, 3, 5, 12, 13, 0, 8]},\n        {'Node': 8, 'Connections': [12, 13, 16, 10]},\n        {'Node': 9, 'Connections': [16, 5, 1, 6, 7, 14]},\n        {'Node': 3, 'Connections': [9, 13, 15, 14]},\n        {'Node': 12, 'Connections': [3, 13, 9, 16, 11, 4]},\n        {'Node': 13, 'Connections': [1, 12, 5, 9, 14, 7, 0, 3]},\n        {'Node': 0, 'Connections': [12, 1, 5, 4]},\n        {'Node': 6, 'Connections': [4, 15, 11]},\n        {'Node': 15, 'Connections': [12, 13]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection)\n\n# Function to find Euler path\ndef find_euler_path(graph):\n    # Check the number of vertices with odd degree\n    odd_degree_nodes = [node for node, degree in graph.degree() if degree % 2 == 1]\n    \n    # Euler path conditions\n    if len(odd_degree_nodes) not in [0, 2]:\n        return None  # No Euler path exists\n    \n    # If there are 0 odd degree nodes, start from any node, if 2, start from one of the odd degree nodes\n    start_node = odd_degree_nodes[0] if odd_degree_nodes else list(graph.nodes())[0]\n    \n    # Find the Euler path\n    euler_path = list(nx.eulerian_path(graph, source=start_node))\n    \n    return euler_path\n\n# Find and print the Euler path\neuler_path = find_euler_path(G)\nif euler_path:\n    print(\"Euler Path:\", list(euler_path))\nelse:\n    print(\"No Euler Path exists.\")\n",
                "key_api": "networkx.eulerian_path",
                "key_experience": "['Using NetworkX library for efficient graph management and path algorithms.', 'Converting input data into a graph structure that can be processed by NetworkX.', 'Utilizing well-established algorithms and functions provided by libraries to solve specific problems efficiently.']"
            }
        ]
    },
    {
        "id": 150,
        "problem": "Output the total weight of the minimum spanning tree [MST] for this graph.",
        "graph_type": "undirected",
        "experience": "The user provided a problem where we needed to output the total weight of the minimum spanning tree (MST) for a given graph. The essential part of solving the problem involves using graph algorithms, specifically for MST calculation (like Prim's or Kruskal's algorithm). NetworkX, a Python library for the creation, manipulation, and study of complex networks, is well-suited for this task.",
        "rag_data": [
            {
                "Section ID": "minimum_spanning_tree",
                "Description": [
                    "Returns a minimum spanning tree or forest on an undirected graph G ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : undirected graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                        "weight : str": "Data key to use for edge weights.",
                        "algorithm : string": "The algorithm to use when finding a minimum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is\n\u2018kruskal\u2019.",
                        "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
                    },
                    "Returns:": {
                        "G : NetworkX Graph": "A minimum spanning tree or forest."
                    }
                },
                "Rubrics": {
                    "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.",
                    "Examples": "G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.minimum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (1, 2, {}), (2, 3, {})]"
                }
            }
        ],
        "accuracy": 0.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <9> is connected to nodes <0>, <15>, <14>, <11>, <4>, <1>, <17>, <3>, <7>.\nNode <0> is connected to nodes <9>, <6>, <5>, <4>, <12>, <16>, <3>, <13>.\nNode <15> is connected to nodes <9>, <11>, <17>, <14>, <3>, <10>.\nNode <14> is connected to nodes <9>, <15>, <1>, <7>, <5>, <13>, <8>, <2>.\nNode <11> is connected to nodes <9>, <15>, <6>, <16>, <5>, <4>, <7>.\nNode <4> is connected to nodes <9>, <0>, <11>, <8>, <16>, <13>.\nNode <1> is connected to nodes <9>, <14>, <10>, <16>, <7>.\nNode <17> is connected to nodes <9>, <15>, <2>, <10>, <3>.\nNode <3> is connected to nodes <9>, <0>, <15>, <17>, <6>, <12>, <2>, <10>.\nNode <7> is connected to nodes <9>, <14>, <11>, <1>, <12>, <5>, <2>.\nNode <6> is connected to nodes <0>, <11>, <3>, <12>.\nNode <5> is connected to nodes <0>, <14>, <11>, <7>.\nNode <12> is connected to nodes <0>, <3>, <7>, <6>, <2>.\nNode <16> is connected to nodes <0>, <11>, <4>, <1>, <13>, <18>, <8>.\nNode <13> is connected to nodes <0>, <14>, <4>, <16>, <2>, <18>, <8>.\nNode <10> is connected to nodes <15>, <1>, <17>, <3>.\nNode <8> is connected to nodes <14>, <4>, <16>, <13>, <18>.\nNode <2> is connected to nodes <14>, <17>, <3>, <7>, <12>, <13>.\nNode <18> is connected to nodes <16>, <13>, <8>.\nOutput the total weight of the minimum spanning tree (MST) for this graph.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 9, 'Connections': [0, 15, 14, 11, 4, 1, 17, 3, 7]},\n        {'Node': 0, 'Connections': [9, 6, 5, 4, 12, 16, 3, 13]},\n        {'Node': 15, 'Connections': [9, 11, 17, 14, 3, 10]},\n        {'Node': 14, 'Connections': [9, 15, 1, 7, 5, 13, 8, 2]},\n        {'Node': 11, 'Connections': [9, 15, 6, 16, 5, 4, 7]},\n        {'Node': 4, 'Connections': [9, 0, 11, 8, 16, 13]},\n        {'Node': 1, 'Connections': [9, 14, 10, 16, 7]},\n        {'Node': 17, 'Connections': [9, 15, 2, 10, 3]},\n        {'Node': 3, 'Connections': [9, 0, 15, 17, 6, 12, 2, 10]},\n        {'Node': 7, 'Connections': [9, 14, 11, 1, 12, 5, 2]},\n        {'Node': 6, 'Connections': [0, 11, 3, 12]},\n        {'Node': 5, 'Connections': [0, 14, 11, 7]},\n        {'Node': 12, 'Connections': [0, 3, 7, 6, 2]},\n        {'Node': 16, 'Connections': [0, 11, 4, 1, 13, 18, 8]},\n        {'Node': 13, 'Connections': [0, 14, 4, 16, 2, 18, 8]},\n        {'Node': 10, 'Connections': [15, 1, 17, 3]},\n        {'Node': 8, 'Connections': [14, 4, 16, 13, 18]},\n        {'Node': 2, 'Connections': [14, 17, 3, 7, 12, 13]},\n        {'Node': 18, 'Connections': [16, 13, 8]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection, weight=1)  # Assuming weight of 1 for each edge\n\n# Compute the minimum spanning tree (MST)\nmst = nx.minimum_spanning_tree(G)\n\n# Calculate the total weight of the MST\ntotal_weight = mst.size(weight='weight')\n\n# Output the total weight\nprint(\"Total weight of the minimum spanning tree (MST):\", total_weight)\n",
                "key_api": "NetworkX, specifically using methods to create graphs and calculate MSTs such as `nx.Graph()`, `G.add_edge()`, `nx.minimum_spanning_tree()`.",
                "key_experience": "[\"Loading graph data: Converting the problem's data into a suitable format for NetworkX.\", 'Graph Creation: Using `nx.Graph()` to initialize a graph object and `G.add_edge()` to add edges between nodes.', 'MST Calculation: Using `nx.minimum_spanning_tree(G)` to compute the MST.', 'Weight Calculation: Summing up edge weights from the MST.']"
            }
        ]
    },
    {
        "id": 151,
        "problem": "Output the total weight of the minimum spanning tree [MST] for this graph.",
        "graph_type": "undirected",
        "experience": "Based on the recent engagement, solving the problem of outputting the total weight of the minimum spanning tree (MST) involved using the NetworkX library, which is well-suited for dealing with graph structures. The problem required parsing input data, representing it as a graph using NetworkX, and then computing the MST.",
        "rag_data": [
            {
                "Section ID": "minimum_spanning_tree",
                "Description": [
                    "Returns a minimum spanning tree or forest on an undirected graph G ."
                ],
                "Field List": {
                    "Parameters:": {
                        "G : undirected graph": "An undirected graph. IfGis connected, then the algorithm finds a\nspanning tree. Otherwise, a spanning forest is found.",
                        "weight : str": "Data key to use for edge weights.",
                        "algorithm : string": "The algorithm to use when finding a minimum spanning tree. Valid\nchoices are \u2018kruskal\u2019, \u2018prim\u2019, or \u2018boruvka\u2019. The default is\n\u2018kruskal\u2019.",
                        "ignore_nan : bool (default: False)": "If a NaN is found as an edge weight normally an exception is raised.\nIfignore_nanisTruethen that edge is ignored instead."
                    },
                    "Returns:": {
                        "G : NetworkX Graph": "A minimum spanning tree or forest."
                    }
                },
                "Rubrics": {
                    "Notes": "For Bor\u016fvka\u2019s algorithm, each edge must have a weight attribute, and\neach edge weight must be distinct. For the other algorithms, if the graph edges do not have a weight\nattribute a default weight of 1 will be used. There may be more than one tree with the same minimum or maximum weight.\nSee networkx.tree.recognition for more detailed definitions. Isolated nodes with self-loops are in the tree as edgeless isolated nodes.",
                    "Examples": "G=nx.cycle_graph(4)\nG.add_edge(0,3,weight=2)\nT=nx.minimum_spanning_tree(G)\nsorted(T.edges(data=True))\n# [(0, 1, {}), (1, 2, {}), (2, 3, {})]"
                }
            }
        ],
        "accuracy": 0.0,
        "example": [
            {
                "question": "Given an undirected graph:\nNode <9> is connected to nodes <12>, <11>, <2>.\nNode <12> is connected to nodes <9>, <1>, <7>, <14>.\nNode <11> is connected to nodes <9>, <13>, <6>.\nNode <2> is connected to nodes <9>, <14>, <4>, <8>, <6>.\nNode <1> is connected to nodes <12>, <4>, <5>, <10>.\nNode <7> is connected to nodes <12>, <6>, <4>, <10>.\nNode <14> is connected to nodes <12>, <2>, <0>, <15>, <5>.\nNode <13> is connected to nodes <11>, <15>, <3>.\nNode <6> is connected to nodes <11>, <2>, <7>, <8>, <15>, <16>, <0>.\nNode <4> is connected to nodes <2>, <1>, <7>, <16>, <8>.\nNode <8> is connected to nodes <2>, <4>, <6>, <0>.\nNode <5> is connected to nodes <1>, <14>, <10>.\nNode <10> is connected to nodes <1>, <7>, <0>, <5>.\nNode <0> is connected to nodes <14>, <8>, <6>, <10>.\nNode <15> is connected to nodes <14>, <6>, <13>, <3>.\nNode <16> is connected to nodes <4>, <6>, <3>.\nNode <3> is connected to nodes <15>, <13>, <16>.\nOutput the total weight of the minimum spanning tree (MST) for this graph.\nAnswer:\n",
                "code": "\nimport networkx as nx\n\n# Input data\ndata = {\n    'Nodes': [\n        {'Node': 9, 'Connections': [12, 11, 2]},\n        {'Node': 12, 'Connections': [9, 1, 7, 14]},\n        {'Node': 11, 'Connections': [9, 13, 6]},\n        {'Node': 2, 'Connections': [9, 14, 4, 8, 6]},\n        {'Node': 1, 'Connections': [12, 4, 5, 10]},\n        {'Node': 7, 'Connections': [12, 6, 4, 10]},\n        {'Node': 14, 'Connections': [12, 2, 0, 15, 5]},\n        {'Node': 13, 'Connections': [11, 15, 3]},\n        {'Node': 6, 'Connections': [11, 2, 7, 8, 15, 16, 0]},\n        {'Node': 4, 'Connections': [2, 1, 7, 16, 8]},\n        {'Node': 8, 'Connections': [2, 4, 6, 0]},\n        {'Node': 5, 'Connections': [1, 14, 10]},\n        {'Node': 10, 'Connections': [1, 7, 0, 5]},\n        {'Node': 0, 'Connections': [14, 8, 6, 10]},\n        {'Node': 15, 'Connections': [14, 6, 13, 3]},\n        {'Node': 16, 'Connections': [4, 6, 3]},\n        {'Node': 3, 'Connections': [15, 13, 16]}\n    ]\n}\n\n# Create an undirected graph\nG = nx.Graph()\n\n# Add edges to the graph with a weight of 1\nfor node in data['Nodes']:\n    for connection in node['Connections']:\n        G.add_edge(node['Node'], connection, weight=1)\n\n# Compute the Minimum Spanning Tree (MST)\nmst = nx.minimum_spanning_tree(G)\n\n# Calculate the total weight of the MST\ntotal_weight = mst.size(weight='weight')\n\n# Output the total weight of the MST\nprint(\"Total weight of the Minimum Spanning Tree:\", total_weight)\n",
                "key_api": "networkx.minimum_spanning_tree",
                "key_experience": "1. Parsing and structuring input data correctly.\n2. Representing the input graph accurately using NetworkX's Graph class.\n3. Using NetworkX's built-in functions to compute the MST and its total weight.\n4. Ensuring the solution is efficient and minimal by leveraging appropriate libraries."
            }
        ]
    }
]